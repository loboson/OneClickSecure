[
  {
    "id": 1,
    "name": "ubuntu_check",
    "description": "SH 스크립트",
    "lastRun": "실행 안됨",
    "status": "대기중",
    "tasks": 1,
    "filename": "ubuntu_check.sh",
    "sections": [
      {
        "id": "section_1",
        "name": "전체 스크립트",
        "description": "전체 스크립트 실행",
        "content": "#!/bin/bash\nhost_id=$HOST_ID\nusername=$USERNAME\nhostname=$HOSTNAME\nresultfile=\"/tmp/Results_${host_id}_${username}_$(date '+%F_%H:%M:%S').txt\"\nU_01() {\n\techo \"\"  >> $resultfile 2>&1\n\techo \"▶ U-01(상) | 1. 계정관리 > 1.1 root 계정 원격접속 제한 ◀\"  >> $resultfile 2>&1\n\techo \" 양호 판단 기준 : 원격 터미널 서비스를 사용하지 않거나, 사용 시 root 직접 접속을 차단한 경우\"  >> $resultfile 2>&1\n\tif [ -f /etc/services ]; then\n\t\t# /etc/services 파일 내 telnet 서비스의 포트 번호가 설정되어 있는지 확인하고, 설정되어 있다면 실행 중인지 확인함\n\t\ttelnet_port_count=`grep -vE '^#|^\\s#' /etc/services | awk 'tolower($1)==\"telnet\" {print $2}' | awk -F / 'tolower($2)==\"tcp\" {print $1}' | wc -l`\n\t\tif [ $telnet_port_count -gt 0 ]; then\n\t\t\ttelnet_port=(`grep -vE '^#|^\\s#' /etc/services | awk 'tolower($1)==\"telnet\" {print $2}' | awk -F / 'tolower($2)==\"tcp\" {print $1}'`)\n\t\t\tfor ((i=0; i<${#telnet_port[@]}; i++))\n\t\t\tdo\n\t\t\t\tnetstat_telnet_count=`netstat -nat 2>/dev/null | grep -w 'tcp' | grep -Ei 'listen|established|syn_sent|syn_received' | grep \":${telnet_port[$i]} \" | wc -l`\n\t\t\t\tif [ $netstat_telnet_count -gt 0 ]; then\n\t\t\t\t\tif [ -f /etc/pam.d/login ]; then\n\t\t\t\t\t\tpam_securetty_so_count=`grep -vE '^#|^\\s#' /etc/pam.d/login | grep -i 'pam_securetty.so' | wc -l`\n\t\t\t\t\t\tif [ $pam_securetty_so_count -gt 0 ]; then\n\t\t\t\t\t\t\tif [ -f /etc/securetty ]; then\n\t\t\t\t\t\t\t\tetc_securetty_pts_count=`grep -vE '^#|^\\s#' /etc/securetty | grep '^ *pts' | wc -l`\n\t\t\t\t\t\t\t\tif [ $etc_securetty_pts_count -gt 0 ]; then\n\t\t\t\t\t\t\t\t\techo \"※ U-01 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\t\t\t\techo \" telnet 서비스를 사용하고, /etc/securetty 파일에 pts 부분이 제거 또는 주석 처리되어 있지 않습니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\t\t\t\treturn 0\n\t\t\t\t\t\t\t\tfi\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\techo \"※ U-01 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\t\t\techo \" telnet 서비스를 사용하고, /etc/securetty 파일이 없습니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\t\t\treturn 0\n\t\t\t\t\t\t\tfi\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\techo \"※ U-01 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\t\techo \" telnet 서비스를 사용하고, /etc/pam.d/login 파일에 pam_securetty.so 모듈이 제거 또는 주석 처리되어 있습니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\t\treturn 0\n\t\t\t\t\t\tfi\n\t\t\t\t\telse\n\t\t\t\t\t\techo \"※ U-01 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\techo \" telnet 서비스를 사용하고, /etc/pam.d/login 파일이 없습니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\treturn 0\n\t\t\t\t\tfi\n\t\t\t\tfi\n\t\t\tdone\n\t\tfi\n\tfi\n\t# 위 과정에서 확인되지 않을 경우를 대비하여 ps 명령으로 telnet 서비스가 실행 중인지 확인함\n\tps_telnet_count=`ps -ef | grep -i 'telnet' | grep -v 'grep' | wc -l`\n\tif [ $ps_telnet_count -gt 0 ]; then\n\t\tif [ -f /etc/pam.d/login ]; then\n\t\t\tpam_securetty_so_count=`grep -vE '^#|^\\s#' /etc/pam.d/login | grep -i 'pam_securetty.so' | wc -l`\n\t\t\tif [ $pam_securetty_so_count -gt 0 ]; then\n\t\t\t\tif [ -f /etc/securetty ]; then\n\t\t\t\t\tetc_securetty_pts_count=`grep -vE '^#|^\\s#' /etc/securetty | grep '^ *pts' | wc -l`\n\t\t\t\t\tif [ $etc_securetty_pts_count -gt 0 ]; then\n\t\t\t\t\t\techo \"※ U-01 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\techo \" telnet 서비스를 사용하고, /etc/securetty 파일에 pts 부분이 제거 또는 주석 처리되어 있지 않습니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\treturn 0\n\t\t\t\t\tfi\n\t\t\t\telse\n\t\t\t\t\techo \"※ U-01 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\techo \" telnet 서비스를 사용하고, /etc/securetty 파일이 없습니다.\" >> $resultfile 2>&1\n\t\t\t\t\treturn 0\n\t\t\t\tfi\n\t\t\telse\n\t\t\t\techo \"※ U-01 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\techo \" telnet 서비스를 사용하고, /etc/pam.d/login 파일에 pam_securetty.so 모듈이 제거 또는 주석 처리되어 있습니다.\" >> $resultfile 2>&1\n\t\t\t\treturn 0\n\t\t\tfi\n\t\telse\n\t\t\techo \"※ U-01 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\techo \" telnet 서비스를 사용하고, /etc/pam.d/login 파일이 없습니다.\" >> $resultfile 2>&1\n\t\t\treturn 0\n\t\t\n\t\tfi\n\tfi\n\t# sshd_config 파일의 존재 여부를 검색하고, 존재한다면 ssh 서비스가 실행 중일 때 점검할 별도의 배열에 저장함\n\tsshd_config_count=`find / -name 'sshd_config' -type f 2> /dev/null | wc -l`\n\tif [ $sshd_config_count -gt 0 ]; then\n\t\tsshd_config_file=(`find / -name 'sshd_config' -type f 2> /dev/null`)\n\tfi\n\t# /etc/services 파일 내 ssh 서비스의 포트 번호가 설정되어 있는지 확인하고, 설정되어 있다면 실행 중인지 확인함\n\tif [ -f /etc/services ]; then\n\t\tssh_port_count=`grep -vE '^#|^\\s#' /etc/services | awk 'tolower($1)==\"ssh\" {print $2}' | awk -F / 'tolower($2)==\"tcp\" {print $1}' | wc -l`\n\t\tif [ $ssh_port_count -gt 0 ]; then\n\t\t\tssh_port=(`grep -vE '^#|^\\s#' /etc/services | awk 'tolower($1)==\"ssh\" {print $2}' | awk -F / 'tolower($2)==\"tcp\" {print $1}'`)\n\t\t\tfor ((i=0; i<${#ssh_port[@]}; i++))\n\t\t\tdo\n\t\t\t\tnetstat_sshd_enable_count=`netstat -nat 2>/dev/null | grep -w 'tcp' | grep -Ei 'listen|established|syn_sent|syn_received' | grep \":${ssh_port[$i]} \" | wc -l`\n\t\t\t\tif [ $netstat_sshd_enable_count -gt 0 ]; then\n\t\t\t\t\tif [ ${#sshd_config_file[@]} -eq 0 ]; then\n\t\t\t\t\t\techo \"※ U-01 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\techo \" ssh 서비스를 사용하고, sshd_config 파일이 없습니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\treturn 0\n\t\t\t\t\tfi\n\t\t\t\t\tfor ((j=0; j<${#sshd_config_file[@]}; j++))\n\t\t\t\t\tdo\n\t\t\t\t\t\tsshd_permitrootlogin_no_count=`grep -vE '^#|^\\s#' ${sshd_config_file[$j]} | grep -i 'permitrootlogin' | grep -i 'no' | wc -l`\n\t\t\t\t\t\tif [ $sshd_permitrootlogin_no_count -eq 0 ]; then\n\t\t\t\t\t\t\techo \"※ U-01 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\t\techo \" ssh 서비스를 사용하고, sshd_config 파일에서 root 계정의 원격 접속이 허용되어 있습니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\t\treturn 0\n\t\t\t\t\t\tfi\n\t\t\t\t\tdone\n\t\t\t\tfi\n\t\t\tdone\n\t\tfi\n\tfi\n\t# 위 과정에서 확인되지 않을 경우를 대비하여 sshd_config 파일 내 ssh 서비스의 포트 번호가 설정되어 있는지 확인하고, 설정되어 있다면 실행 중인지 확인함\n\tif [ ${#sshd_config_file[@]} -gt 0 ]; then\n\t\tfor ((i=0; i<${#sshd_config_file[@]}; i++))\n\t\tdo\n\t\t\tssh_port_count=`grep -vE '^#|^\\s#' ${sshd_config_file[$i]} | grep -i 'port'  | awk '{print $2}' | wc -l`\n\t\t\tif [ $ssh_port_count -gt 0 ]; then\n\t\t\t\tssh_port=(`grep -vE '^#|^\\s#' ${sshd_config_file[$i]} | grep -i 'port'  | awk '{print $2}'`)\n\t\t\t\tfor ((j=0; j<${#ssh_port[@]}; j++))\n\t\t\t\tdo\n\t\t\t\t\tnetstat_sshd_enable_count=`netstat -nat 2>/dev/null | grep -w 'tcp' | grep -Ei 'listen|established|syn_sent|syn_received' | grep \":${ssh_port[$j]} \" | wc -l`\n\t\t\t\t\tif [ $netstat_sshd_enable_count -gt 0 ]; then\n\t\t\t\t\t\tfor ((k=0; k<${#sshd_config_file[@]}; k++))\n\t\t\t\t\t\tdo\n\t\t\t\t\t\t\tsshd_permitrootlogin_no_count=`grep -vE '^#|^\\s#' ${sshd_config_file[$k]} | grep -i 'permitrootlogin' | grep -i 'no' | wc -l`\n\t\t\t\t\t\t\tif [ $sshd_permitrootlogin_no_count -eq 0 ]; then\n\t\t\t\t\t\t\t\techo \"※ U-01 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\t\t\techo \" ssh 서비스를 사용하고, sshd_config 파일에서 root 계정의 원격 접속이 허용되어 있습니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\t\t\treturn 0\n\t\t\t\t\t\t\tfi\n\t\t\t\t\t\tdone\n\t\t\t\t\tfi\n\t\t\t\tdone\n\t\t\tfi\n\t\tdone\n\tfi\n\t# 위 과정에서 확인되지 않을 경우를 대비하여 ps 명령으로 ssh 서비스가 실행 중인지 확인함\n\tps_sshd_enable_count=`ps -ef | grep -i 'sshd' | grep -v 'grep' | wc -l`\n\tif [ $ps_sshd_enable_count -gt 0 ]; then\n\t\tif [ ${#sshd_config_file[@]} -eq 0 ]; then\n\t\t\techo \"※ U-01 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\techo \" ssh 서비스를 사용하고, sshd_config 파일이 없습니다.\" >> $resultfile 2>&1\n\t\t\treturn 0\n\t\tfi\n\t\tfor ((i=0; i<${#sshd_config_file[@]}; i++))\n\t\tdo\n\t\t\tsshd_permitrootlogin_no_count=`grep -vE '^#|^\\s#' ${sshd_config_file[$i]} | grep -i 'permitrootlogin' | grep -i 'no' | wc -l`\n\t\t\tif [ $sshd_permitrootlogin_no_count -eq 0 ]; then\n\t\t\t\techo \"※ U-01 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\techo \" ssh 서비스를 사용하고, sshd_config 파일에서 root 계정의 원격 접속이 허용되어 있습니다.\" >> $resultfile 2>&1\n\t\t\t\treturn 0\n\t\t\tfi\n\t\tdone\n\tfi\n\techo \"※ U-01 결과 : 양호(Good)\" >> $resultfile 2>&1\n\treturn 0\n}\n\nU_02() {\n\techo \"\"  >> $resultfile 2>&1\n\techo \"▶ U-02(상) | 1. 계정관리 > 1.2 패스워드 복잡성 설정 ◀\"  >> $resultfile 2>&1\n\techo \" 양호 판단 기준 : 패스워드 최소길이 8자리 이상, 영문·숫자·특수문자 최소 입력 기능이 설정된 경우\"  >> $resultfile 2>&1\n\tfile_exists_count=0 # 패스워드 설정 파일 존재 시 카운트할 변수\n\tminlen_file_exists_count=0 # 패스워드 최소 길이 설정 파일 존재 시 카운트할 변수\n\tno_settings_in_minlen_file=0 # 설정 파일 존재하는데, 최소 길이에 대한 설정이 없을 때 카운트할 변수 -> 추후 file_exists_count 변수와 값을 비교하여 동일하면 모든 파일에 패스워드 최소 길이 설정이 없는 것이므로 취약으로 판단함\n\tmininput_file_exists_count=0 # 패스워드 최소 입력 설정 파일 존재 시 카운트할 변수\n\tno_settings_in_mininput_file=0 # 설정 파일 존재하는데, 최소 입력에 대한 설정이 없을 때 카운트할 변수 -> 추후 mininput_file_exists_count 변수와 값을 비교하여 동일하면 모든 파일에 패스워드 최소 입력 설정이 없는 것이므로 취약으로 판단함\n\tinput_options=(\"lcredit\" \"ucredit\" \"dcredit\" \"ocredit\")\n\tinput_modules=(\"pam_pwquality.so\" \"pam_cracklib.so\" \"pam_unix.so\")\n\t# /etc/login.defs 파일 내 패스워드 최소 길이 설정 확인함\n\tif [ -f /etc/login.defs ]; then\n\t\t((file_exists_count++))\n\t\t((minlen_file_exists_count++))\n\t\tetc_logindefs_minlen_count=`grep -vE '^#|^\\s#' /etc/login.defs  | grep -i 'PASS_MIN_LEN' | awk '{print $2}' | wc -l`\n\t\tif [ $etc_logindefs_minlen_count -gt 0 ]; then\n\t\t\tetc_logindefs_minlen_value=`grep -vE '^#|^\\s#' /etc/login.defs  | grep -i 'PASS_MIN_LEN' | awk '{print $2}'`\n\t\t\tif [ $etc_logindefs_minlen_value -lt 8 ]; then\n\t\t\t\techo \"※ U-02 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\techo \" /etc/login.defs 파일에 최소 길이(PASS_MIN_LEN)가 8 미만으로 설정되어 있습니다.\" >> $resultfile 2>&1\n\t\t\t\treturn 0\n\t\t\tfi\n\t\telse\n\t\t\t((no_settings_in_minlen_file++))\n\t\tfi\n\tfi\n\t# /etc/security/pwquality 파일 내 패스워드 최소 길이와 최소 입력 확인함\n\tif [ -f /etc/security/pwquality.conf ]; then\n\t\t((file_exists_count++))\n\t\t# 패스워드 최소 길이 체크\n\t\t((minlen_file_exists_count++))\n\t\tetc_security_pwqualityconf_minlen_count=`grep -vE '^#|^\\s#' /etc/security/pwquality.conf  | grep -i 'minlen' | wc -l`\n\t\tif [ $etc_security_pwqualityconf_minlen_count -gt 0 ]; then\n\t\t\tetc_security_pwqualityconf_minlen_value=`grep -vE '^#|^\\s#' /etc/security/pwquality.conf  | grep -i 'minlen' | awk -F 'minlen' '{gsub(\" \", \"\", $0); print substr($2,2,1)}'`\n\t\t\tif [ $etc_security_pwqualityconf_minlen_value -lt 8 ]; then\n\t\t\t\tetc_security_pwqualityconf_minlen_second_value=`grep -vE '^#|^\\s#' /etc/security/pwquality.conf  | grep -i 'minlen' | awk -F 'minlen' '{gsub(\" \", \"\", $0); print substr($2,3,1)}'`\n\t\t\t\tif [[ $etc_security_pwqualityconf_minlen_second_value != [0-9] ]]; then\n\t\t\t\t\techo \"※ U-02 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\techo \" /etc/security/pwquality.conf 파일에 최소 길이(minlen)가 8 미만으로 설정되어 있습니다.\" >> $resultfile 2>&1\n\t\t\t\t\treturn 0\n\t\t\t\tfi\n\t\t\telse\n\t\t\t\tif [ -f /etc/pam.d/common-password ]; then\n\t\t\t\t\tetc_pamd_commonpassword_module_count=`grep -vE '^#|^\\s#' /etc/pam.d/common-password | grep -i 'pam_pwquality.so' | wc -l`\n\t\t\t\t\tif [ $etc_pamd_commonpassword_module_count -eq 0 ]; then\n\t\t\t\t\t\techo \"※ U-02 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\techo \" /etc/security/pwquality.conf 파일에 최소 길이(minlen)를 8 이상으로 설정하고, /etc/pam.d/common-password 파일에 pam_pwquality.so 모듈을 추가하지 않았습니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\treturn 0\n\t\t\t\t\tfi\n\t\t\t\telse\n\t\t\t\t\techo \"※ U-02 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\techo \" /etc/security/pwquality.conf 파일에 최소 길이(minlen)를 8 이상으로 설정하고, /etc/pam.d/common-password 파일에 pam_pwquality.so 모듈을 추가하지 않았습니다.\" >> $resultfile 2>&1\n\t\t\t\t\treturn 0\n\t\t\t\tfi\n\t\t\tfi\n\t\telse\n\t\t\t((no_settings_in_minlen_file++))\n\t\tfi\n\t\t# 패스워드 최소 입력 체크\n\t\tfor ((i=0; i<${#input_options[@]}; i++))\n\t\tdo\n\t\t\t((mininput_file_exists_count++))\n\t\t\tetc_security_pwqualityconf_mininput_count=`grep -vE '^#|^\\s#' /etc/security/pwquality.conf | grep -i ${input_options[$i]} | wc -l`\n\t\t\tif [ $etc_security_pwqualityconf_mininput_count -gt 0 ]; then\n\t\t\t\tetc_security_pwqualityconf_mininput_dash=`grep -vE '^#|^\\s#' /etc/security/pwquality.conf | grep -i ${input_options[$i]} | awk -F ${input_options[$i]} '{gsub(\" \", \"\", $0); print substr($2,2,1)}'`\n\t\t\t\tif [[ $etc_security_pwqualityconf_mininput_dash =~ - ]]; then\n\t\t\t\t\tetc_security_pwqualityconf_mininput_value=`grep -vE '^#|^\\s#' /etc/security/pwquality.conf | grep -i ${input_options[$i]} | awk -F ${input_options[$i]} '{gsub(\" \", \"\", $0); print substr($2,3,1)}'`\n\t\t\t\t\tif [ $etc_security_pwqualityconf_mininput_value -ge 1 ]; then\n\t\t\t\t\t\tif [ -f /etc/pam.d/common-password ]; then\n\t\t\t\t\t\t\tetc_pamd_commonpassword_module_count=`grep -vE '^#|^\\s#' /etc/pam.d/common-password | grep -i 'pam_pwquality.so' | wc -l`\n\t\t\t\t\t\t\tif [ $etc_pamd_commonpassword_module_count -eq 0 ]; then\n\t\t\t\t\t\t\t\techo \"※ U-02 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\t\t\techo \" /etc/security/pwquality.conf 파일에 영문, 숫자, 특수문자의 최소 입력을 설정하고, /etc/pam.d/common-password 파일에 pam_pwquality.so 모듈을 추가하지 않았습니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\t\t\treturn 0\n\t\t\t\t\t\t\tfi\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\techo \"※ U-02 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\t\techo \" /etc/security/pwquality.conf 파일에 영문, 숫자, 특수문자의 최소 입력을 설정하고, /etc/pam.d/common-password 파일에 pam_pwquality.so 모듈을 추가하지 않았습니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\t\treturn 0\n\t\t\t\t\t\tfi\n\t\t\t\t\telse\n\t\t\t\t\t\techo \"※ U-02 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\techo \" /etc/security/pwquality.conf 파일에 영문, 숫자, 특수문자의 최소 입력이 1 미만으로 설정되어 있습니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\treturn 0\n\t\t\t\t\tfi\n\t\t\t\telse\n\t\t\t\t\techo \"※ U-02 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\techo \" /etc/security/pwquality.conf 파일에 영문, 숫자, 특수문자의 최소 입력에 대한 설정이 없습니다.\" >> $resultfile 2>&1\n\t\t\t\t\treturn 0\n\t\t\t\tfi\n\t\t\telse\n\t\t\t\t((no_settings_in_mininput_file++))\n\t\t\tfi\n\t\tdone\n\tfi\n\t# /etc/pam.d/common-password 파일 내 패스워드 최소 길이와 최소 입력 확인함\n\tif [ -f /etc/pam.d/common-password ]; then\n\t\t((file_exists_count++))\n\t\t# 패스워드 최소 길이 체크\n\t\tfor ((i=0; i<${#input_modules[@]}; i++))\n\t\tdo\n\t\t\t((minlen_file_exists_count++))\n\t\t\tetc_pamd_commonpassword_minlen_count=`grep -vE '^#|^\\s#' /etc/pam.d/common-password | grep -i 'minlen' | grep -i ${input_modules[$i]} | wc -l`\n\t\t\tif [ $etc_pamd_commonpassword_minlen_count -gt 0 ]; then\n\t\t\t\tetc_pamd_commonpassword_minlen_value=`grep -vE '^#|^\\s#' /etc/pam.d/common-password | grep -i 'minlen' | grep -i ${input_modules[$i]} | awk '{gsub(\" \", \"\", $0); print}' | awk -F 'minlen' '{print substr($2,2,1)}'`\n\t\t\t\tif [ $etc_pamd_commonpassword_minlen_value -lt 8 ]; then\n\t\t\t\t\tetc_pamd_commonpassword_minlen_second_value=`grep -vE '^#|^\\s#' /etc/pam.d/common-password | grep -i 'minlen' | grep -i ${input_modules[$i]} | awk '{gsub(\" \", \"\", $0); print}' | awk -F 'minlen' '{print substr($2,3,1)}'`\n\t\t\t\t\tif [[ $etc_pamd_commonpassword_minlen_second_value != [0-9] ]]; then\n\t\t\t\t\t\techo \"※ U-02 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\techo \" /etc/pam.d/common-password 파일에 최소 길이(minlen)가 8 미만으로 설정되어 있습니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\treturn 0\n\t\t\t\t\tfi\n\t\t\t\tfi\n\t\t\telse\n\t\t\t\t((no_settings_in_minlen_file++))\n\t\t\tfi\n\t\tdone\n\t\t# 패스워드 최소 입력 체크\n\t\tfor ((i=0; i<${#input_modules[@]}; i++))\n\t\tdo\n\t\t\t\n\t\t\tfor ((j=0; j<${#input_options[@]}; j++))\n\t\t\tdo\n\t\t\t\t((mininput_file_exists_count++))\n\t\t\t\tetc_pamd_commonpassword_mininput_count=`grep -vE '^#|^\\s#' /etc/pam.d/common-password | grep -i ${input_options[$j]} | grep -i ${input_modules[$i]} | wc -l`\n\t\t\t\tif [ $etc_pamd_commonpassword_mininput_count -gt 0 ]; then\n\t\t\t\t\tetc_pamd_commonpassword_mininput_dash=`grep -vE '^#|^\\s#' /etc/pam.d/common-password | grep -i ${input_options[$j]} | grep -i ${input_modules[$i]} | awk -F ${input_options[$j]} '{gsub(\" \", \"\", $0); print substr($2,2,1)}'`\n\t\t\t\t\tif [[ $etc_pamd_commonpassword_mininput_dash =~ - ]]; then\n\t\t\t\t\t\tetc_pamd_commonpassword_mininput_number=`grep -vE '^#|^\\s#' /etc/pam.d/common-password | grep -i ${input_options[$j]} | grep -i ${input_modules[$i]} | awk -F ${input_options[$j]} '{gsub(\" \", \"\", $0); print substr($2,3,1)}'`\n\t\t\t\t\t\tif [ $etc_pamd_commonpassword_mininput_number -lt 1 ]; then\n\t\t\t\t\t\t\techo \"※ U-02 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\t\techo \" /etc/pam.d/common-password 파일에 영문, 숫자, 특수문자의 최소 입력이 1 미만으로 설정되어 있습니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\t\treturn 0\n\t\t\t\t\t\tfi\n\t\t\t\t\telse\n\t\t\t\t\t\techo \"※ U-02 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\techo \" /etc/pam.d/common-password 파일에 영문, 숫자, 특수문자의 최소 입력이 설정되어 있지 않습니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\treturn 0\n\t\t\t\t\tfi\n\t\t\t\telse\n\t\t\t\t\t((no_settings_in_mininput_file++))\n\t\t\t\tfi\n\t\t\tdone\n\t\tdone\n\tfi\n\tif [ $file_exists_count -eq 0 ]; then\n\t\techo \"※ U-02 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\techo \" 패스워드의 복잡성을 설정하는 파일이 없습니다.\" >> $resultfile 2>&1\n\t\treturn 0\n\telif [ $minlen_file_exists_count -eq $no_settings_in_minlen_file ]; then\n\t\techo \"※ U-02 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\techo \" 패스워드의 최소 길이를 설정한 파일이 없습니다.\" >> $resultfile 2>&1\n\t\treturn 0\n\telif [ $mininput_file_exists_count -eq $no_settings_in_mininput_file ]; then\n\t\techo \"※ U-02 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\techo \" 패스워드의 영문, 숫자, 특수문자의 최소 입력을 설정한 파일이 없습니다.\" >> $resultfile 2>&1\n\t\treturn 0\n\tfi\n\techo \"※ U-02 결과 : 양호(Good)\" >> $resultfile 2>&1\n\treturn 0\n}\n\nU_03() {\n\techo \"\"  >> $resultfile 2>&1\n\techo \"▶ U-03(상) | 1. 계정관리 > 1.3 계정 잠금 임계값 설정 ◀\"  >> $resultfile 2>&1\n\techo \" 양호 판단 기준 : 계정 잠금 임계값이 10회 이하의 값으로 설정되어 있는 경우\"  >> $resultfile 2>&1\n\tfile_exists_count=0\n\tdeny_file_exists_count=0\n\tno_settings_in_deny_file=0\n\tdeny_modules=(\"pam_tally2.so\" \"pam_faillock.so\")\n\t# /etc/pam.d/common-auth 파일 내 계정 잠금 임계값 설정 확인함\n\tif [ -f /etc/pam.d/common-auth ]; then\n\t\t((file_exists_count++))\n\t\tfor ((i=0; i<${#deny_modules[@]}; i++))\n\t\tdo\n\t\t\t((deny_file_exists_count++))\n\t\t\tetc_pamd_commonauth_deny_count=`grep -vE '^#|^\\s#' /etc/pam.d/common-auth | grep -i ${deny_modules[$i]} | grep -i 'deny' | wc -l`\n\t\t\tif [ $etc_pamd_commonauth_deny_count -gt 0 ]; then\n\t\t\t\tetc_pamd_commonauth_deny_value=`grep -vE '^#|^\\s#' /etc/pam.d/common-auth | grep -i ${deny_modules[$i]} | grep -i 'deny' | awk -F 'deny' '{gsub(\" \", \"\", $0); print substr($2,2,1)}'`\n\t\t\t\tetc_pamd_commonauth_deny_second_value=`grep -vE '^#|^\\s#' /etc/pam.d/common-auth | grep -i ${deny_modules[$i]} | grep -i 'deny' | awk -F 'deny' '{gsub(\" \", \"\", $0); print substr($2,3,1)}'`\n\t\t\t\tetc_pamd_commonauth_deny_third_value=`grep -vE '^#|^\\s#' /etc/pam.d/common-auth | grep -i ${deny_modules[$i]} | grep -i 'deny' | awk -F 'deny' '{gsub(\" \", \"\", $0); print substr($2,4,1)}'`\n\t\t\t\tif [ $etc_pamd_commonauth_deny_value -eq 0 ]; then\n\t\t\t\t\tcontinue\n\t\t\t\telif [ $etc_pamd_commonauth_deny_value -eq 1 ]; then\n\t\t\t\t\tif [[ $etc_pamd_commonauth_deny_second_value =~ [1-9] ]]; then\n\t\t\t\t\t\techo \"※ U-03 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\techo \" /etc/pam.d/common-auth 파일에 계정 잠금 임계값이 11회 이상으로 설정되어 있습니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\treturn 0\n\t\t\t\t\telse\n\t\t\t\t\t\tif [[ $etc_pamd_commonauth_deny_third_value =~ [0-9] ]]; then\n\t\t\t\t\t\t\techo \"※ U-03 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\t\techo \" /etc/pam.d/common-auth 파일에 계정 잠금 임계값이 11회 이상으로 설정되어 있습니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\t\treturn 0\n\t\t\t\t\t\tfi\n\t\t\t\t\tfi\n\t\t\t\telse\n\t\t\t\t\tif [[ $etc_pamd_commonauth_deny_second_value =~ [0-9] ]]; then\n\t\t\t\t\t\techo \"※ U-03 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\techo \" /etc/pam.d/common-auth 파일에 계정 잠금 임계값이 11회 이상으로 설정되어 있습니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\treturn 0\n\t\t\t\t\tfi\n\t\t\t\tfi\n\t\t\telse\n\t\t\t\t((no_settings_in_deny_file++))\n\t\t\tfi\n\t\tdone\n\tfi\n\t# /etc/pam.d/common-password 파일 내 계정 잠금 임계값 설정 확인함\n\tif [ -f /etc/pam.d/common-password ]; then\n\t\t((file_exists_count++))\n\t\tfor ((i=0; i<${#deny_modules[@]}; i++))\n\t\tdo\n\t\t\t((deny_file_exists_count++))\n\t\t\tetc_pamd_commonauth_deny_count=`grep -vE '^#|^\\s#' /etc/pam.d/common-password | grep -i ${deny_modules[$i]} | grep -i 'deny' | wc -l`\n\t\t\tif [ $etc_pamd_commonauth_deny_count -gt 0 ]; then\n\t\t\t\tetc_pamd_commonauth_deny_value=`grep -vE '^#|^\\s#' /etc/pam.d/common-password | grep -i ${deny_modules[$i]} | grep -i 'deny' | awk -F 'deny' '{gsub(\" \", \"\", $0); print substr($2,2,1)}'`\n\t\t\t\tetc_pamd_commonauth_deny_second_value=`grep -vE '^#|^\\s#' /etc/pam.d/common-password | grep -i ${deny_modules[$i]} | grep -i 'deny' | awk -F 'deny' '{gsub(\" \", \"\", $0); print substr($2,3,1)}'`\n\t\t\t\tetc_pamd_commonauth_deny_third_value=`grep -vE '^#|^\\s#' /etc/pam.d/common-password | grep -i ${deny_modules[$i]} | grep -i 'deny' | awk -F 'deny' '{gsub(\" \", \"\", $0); print substr($2,4,1)}'`\n\t\t\t\tif [ $etc_pamd_commonauth_deny_value -eq 0 ]; then\n\t\t\t\t\tcontinue\n\t\t\t\telif [ $etc_pamd_commonauth_deny_value -eq 1 ]; then\n\t\t\t\t\tif [[ $etc_pamd_commonauth_deny_second_value =~ [1-9] ]]; then\n\t\t\t\t\t\techo \"※ U-03 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\techo \" /etc/pam.d/common-password 파일에 계정 잠금 임계값이 11회 이상으로 설정되어 있습니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\treturn 0\n\t\t\t\t\telse\n\t\t\t\t\t\tif [[ $etc_pamd_commonauth_deny_third_value =~ [0-9] ]]; then\n\t\t\t\t\t\t\techo \"※ U-03 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\t\techo \" /etc/pam.d/common-password 파일에 계정 잠금 임계값이 11회 이상으로 설정되어 있습니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\t\treturn 0\n\t\t\t\t\t\tfi\n\t\t\t\t\tfi\n\t\t\t\telse\n\t\t\t\t\tif [[ $etc_pamd_commonauth_deny_second_value =~ [0-9] ]]; then\n\t\t\t\t\t\techo \"※ U-03 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\techo \" /etc/pam.d/common-password 파일에 계정 잠금 임계값이 11회 이상으로 설정되어 있습니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\treturn 0\n\t\t\t\t\tfi\n\t\t\t\tfi\n\t\t\telse\n\t\t\t\t((no_settings_in_deny_file++))\n\t\t\tfi\n\t\tdone\n\tfi\n\tif [ $file_exists_count -eq 0 ]; then\n\t\techo \"※ U-03 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\techo \" 계정 잠금 임계값을 설정하는 파일이 없습니다.\" >> $resultfile 2>&1\n\t\treturn 0\n\telif [ $deny_file_exists_count -eq $no_settings_in_deny_file ]; then\n\t\techo \"※ U-03 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\techo \" 계정 잠금 임계값을 설정한 파일이 없습니다.\" >> $resultfile 2>&1\n\t\treturn 0\n\tfi\n\techo \"※ U-03 결과 : 양호(Good)\" >> $resultfile 2>&1\n\treturn 0\n}\n\nU_04() {\n\techo \"\"  >> $resultfile 2>&1\n\techo \"▶ U-04(상) | 1. 계정관리 > 1.4 패스워드 파일 보호 ◀\"  >> $resultfile 2>&1\n\techo \" 양호 판단 기준 : 쉐도우 패스워드를 사용하거나, 패스워드를 암호화하여 저장하는 경우\"  >> $resultfile 2>&1\n\tif [ `awk -F : '$2!=\"x\"' /etc/passwd | wc -l` -gt 0 ]; then\n\t\techo \"※ U-04 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\techo \" 쉐도우 패스워드를 사용하고 있지 않습니다.\" >> $resultfile 2>&1\n\t\treturn 0\n\telse\n\t\techo \"※ U-04 결과 : 양호(Good)\" >> $resultfile 2>&1\n\t\treturn 0\n\tfi\n}\n\nU_05() {\n\techo \"\"  >> $resultfile 2>&1\n\techo \"▶ U-05(상) | 2. 파일 및 디렉토리 관리 > 2.1 root홈, 패스 디렉터리 권한 및 패스 설정 ◀\"  >> $resultfile 2>&1\n\techo \" 양호 판단 기준 : PATH 환경변수에 “.” 이 맨 앞이나 중간에 포함되지 않은 경우\"  >> $resultfile 2>&1\n\tif [ `echo $PATH | grep -E '\\.:|::' | wc -l` -gt 0 ]; then\n\t\techo \"※ U-05 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\techo \" PATH 환경 변수 내에 \".\" 또는 \"::\"이 포함되어 있습니다.\" >> $resultfile 2>&1\n\t\treturn 0\n\telse\n\t\t# /etc 디렉터리 내 설정 파일의 PATH 변수 중 누락이 있을 가능성을 생각하여 추가 확인함\n\t\tpath_settings_files=(\"/etc/profile\" \"/etc/.login\" \"/etc/csh.cshrc\" \"/etc/csh.login\" \"/etc/environment\")\n\t\tfor ((i=0; i<${#path_settings_files[@]}; i++))\n\t\tdo\n\t\t\tif [ -f ${path_settings_files[$i]} ]; then\n\t\t\t\tpath_settings_file_path_variable_exists_count=`grep -vE '^#|^\\s#' ${path_settings_files[$i]} | grep 'PATH=' | wc -l`\n\t\t\t\tif [ $path_settings_file_path_variable_exists_count -gt 0 ]; then\n\t\t\t\t\tpath_settings_file_path_variable_value_count=`grep -vE '^#|^\\s#' ${path_settings_files[$i]} | grep 'PATH=' | grep -E '\\.:|::' | wc -l`\n\t\t\t\t\tif [ $path_settings_file_path_variable_value_count -gt 0 ]; then\n\t\t\t\t\t\techo \"※ U-05 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\techo \" /etc 디렉터리 내 Start Profile에 설정된 PATH 환경 변수 내에 \".\" 또는 \"::\"이 포함되어 있습니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\treturn 0\n\t\t\t\t\tfi\n\t\t\t\tfi\n\t\t\tfi\n\t\tdone\n\t\t# 사용자 홈 디렉터리 내 설정 파일의 PATH 변수 중 누락이 있을 가능성을 생각하여 추가 확인함\n\t\tpath_settings_files=(\".profile\" \".cshrc\" \".login\" \".kshrc\" \".bash_profile\" \".bashrc\" \".bash_login\")\n\t\tuser_homedirectory_path=(`awk -F : '$7!=\"/bin/false\" && $7!=\"/sbin/nologin\" && $6!=null {print $6}' /etc/passwd | uniq`) # /etc/passwd 파일에 설정된 홈 디렉터리 배열 생성\n\t\tuser_homedirectory_path2=(/home/*) # /home 디렉터래 내 위치한 홈 디렉터리 배열 생성\n\t\tfor ((i=0; i<${#user_homedirectory_path2[@]}; i++))\n\t\tdo\n\t\t\tuser_homedirectory_path[${#user_homedirectory_path[@]}]=${user_homedirectory_path2[$i]} # 두 개의 배열 합침\n\t\tdone\n\t\tuser_homedirectory_path[${#user_homedirectory_path[@]}]=/root\n\t\tfor ((i=0; i<${#user_homedirectory_path[@]}; i++))\n\t\tdo\n\t\t\tfor ((j=0; j<${#path_settings_files[@]}; j++))\n\t\t\tdo\n\t\t\t\tif [ -f ${user_homedirectory_path[$i]}/${path_settings_files[$j]} ]; then\n\t\t\t\t\tpath_settings_file_path_variable_exists_count=`grep -vE '^#|^\\s#' ${user_homedirectory_path[$i]}/${path_settings_files[$j]} | grep 'PATH=' | wc -l`\n\t\t\t\t\tif [ $path_settings_file_path_variable_exists_count -gt 0 ]; then\n\t\t\t\t\t\tpath_settings_file_path_variable_value_count=`grep -vE '^#|^\\s#' ${user_homedirectory_path[$i]}/${path_settings_files[$j]} | grep 'PATH=' | grep -E '\\.:|::' | wc -l`\n\t\t\t\t\t\tif [ $path_settings_file_path_variable_value_count -gt 0 ]; then\n\t\t\t\t\t\t\techo \"※ U-05 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\t\techo \" ${user_homedirectory_path[$i]} 디렉터리 내 ${path_settings_files[$j]} 파일에 설정된 PATH 환경 변수 내에 \".\" 또는 \"::\"이 포함되어 있습니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\t\treturn 0\n\t\t\t\t\t\tfi\n\t\t\t\t\tfi\n\t\t\t\tfi\n\t\t\tdone\n\t\tdone\n\tfi\n\techo \"※ U-05 결과 : 양호(Good)\" >> $resultfile 2>&1\n\treturn 0\n}\n\nU_06() {\n\techo \"\"  >> $resultfile 2>&1\n\techo \"▶ U-06(상) | 2. 파일 및 디렉토리 관리 > 2.2 파일 및 디렉터리 소유자 설정 ◀\"  >> $resultfile 2>&1\n\techo \" 양호 판단 기준 : 소유자가 존재하지 않는 파일 및 디렉터리가 존재하지 않는 경우\"  >> $resultfile 2>&1\n\tif [ `find / \\( -nouser -or -nogroup \\) 2>/dev/null | wc -l` -gt 0 ]; then\n\t\techo \"※ U-06 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\techo \" 소유자가 존재하지 않는 파일 및 디렉터리가 존재합니다.\" >> $resultfile 2>&1\n\t\treturn 0\n\telse\n\t\techo \"※ U-06 결과 : 양호(Good)\" >> $resultfile 2>&1\n\t\treturn 0\n\tfi\n}\n\nU_07() {\n\techo \"\"  >> $resultfile 2>&1\n\techo \"▶ U-07(상) | 2. 파일 및 디렉토리 관리 > 2.3 /etc/passwd 파일 소유자 및 권한 설정 ◀\"  >> $resultfile 2>&1\n\techo \" 양호 판단 기준 : /etc/passwd 파일의 소유자가 root이고, 권한이 644 이하인 경우\"  >> $resultfile 2>&1\n\tif [ -f /etc/passwd ]; then\t\t\n\t\tetc_passwd_owner_name=`ls -l /etc/passwd | awk '{print $3}'`\n\t\tif [[ $etc_passwd_owner_name =~ root ]]; then\n\t\t\tetc_passwd_permission=`stat /etc/passwd | grep -i 'Uid' | awk '{print $2}' | awk -F / '{print substr($1,3,3)}'`\n\t\t\tif [ $etc_passwd_permission -le 644 ]; then\n\t\t\t\tetc_passwd_owner_permission=`stat /etc/passwd | grep -i 'Uid' | awk '{print $2}' | awk -F / '{print substr($1,3,1)}'`\n\t\t\t\tif [ $etc_passwd_owner_permission -eq 0 ] || [ $etc_passwd_owner_permission -eq 2 ] || [ $etc_passwd_owner_permission -eq 4 ] || [ $etc_passwd_owner_permission -eq 6 ]; then\n\t\t\t\t\tetc_passwd_group_permission=`stat /etc/passwd | grep -i 'Uid' | awk '{print $2}' | awk -F / '{print substr($1,4,1)}'`\n\t\t\t\t\tif [ $etc_passwd_group_permission -eq 0 ] || [ $etc_passwd_group_permission -eq 4 ]; then\n\t\t\t\t\t\tetc_passwd_other_permission=`stat /etc/passwd | grep -i 'Uid' | awk '{print $2}' | awk -F / '{print substr($1,5,1)}'`\n\t\t\t\t\t\tif [ $etc_passwd_other_permission -eq 0 ] || [ $etc_passwd_other_permission -eq 4 ]; then\n\t\t\t\t\t\t\techo \"※ U-07 결과 : 양호(Good)\" >> $resultfile 2>&1\n\t\t\t\t\t\t\treturn 0\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\techo \"※ U-07 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\t\techo \" /etc/passwd 파일의 다른 사용자(other)에 대한 권한이 취약합니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\t\treturn 0\n\t\t\t\t\t\tfi\n\t\t\t\t\telse\n\t\t\t\t\t\techo \"※ U-07 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\techo \" /etc/passwd 파일의 그룹 사용자(group)에 대한 권한이 취약합니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\treturn 0\n\t\t\t\t\tfi\n\t\t\t\telse\n\t\t\t\t\techo \"※ U-07 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\techo \" /etc/passwd 파일의 사용자(owner)에 대한 권한이 취약합니다.\" >> $resultfile 2>&1\n\t\t\t\t\treturn 0\n\t\t\t\tfi\n\t\t\telse\n\t\t\t\techo \"※ U-07 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\techo \" /etc/passwd 파일의 권한이 644보다 큽니다.\" >> $resultfile 2>&1\n\t\t\t\treturn 0\n\t\t\tfi\n\t\telse\n\t\t\techo \"※ U-07 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\techo \" /etc/passwd 파일의 소유자(owner)가 root가 아닙니다.\" >> $resultfile 2>&1\n\t\t\treturn 0\n\t\tfi\n\telse\n\t\techo \"※ U-07 결과 : N/A\" >> $resultfile 2>&1\n\t\techo \" /etc/passwd 파일이 없습니다.\" >> $resultfile 2>&1\n\t\treturn 0\n\tfi\n}\n\nU_08() {\n\techo \"\"  >> $resultfile 2>&1\n\techo \"▶ U-08(상) | 2. 파일 및 디렉토리 관리 > 2.4 /etc/shadow 파일 소유자 및 권한 설정 ◀\"  >> $resultfile 2>&1\n\techo \" 양호 판단 기준 : /etc/shadow 파일의 소유자가 root이고, 권한이 400 이하인 경우\"  >> $resultfile 2>&1\n\tif [ -f /etc/shadow ]; then\n\t\tetc_shadow_owner_name=`ls -l /etc/shadow | awk '{print $3}'`\n\t\tif [[ $etc_shadow_owner_name =~ root ]]; then\n\t\t\tetc_shadow_permission=`stat /etc/shadow | grep -i 'Uid' | awk '{print $2}' | awk -F / '{print substr($1,3,3)}'`\n\t\t\tif [ $etc_shadow_permission -le 400 ]; then\n\t\t\t\tetc_shadow_owner_permission=`stat /etc/shadow | grep -i 'Uid' | awk '{print $2}' | awk -F / '{print substr($1,3,1)}'`\n\t\t\t\tif [ $etc_shadow_owner_permission -eq 0 ] || [ $etc_shadow_owner_permission -eq 4 ]; then\n\t\t\t\t\tetc_shadow_group_permission=`stat /etc/shadow | grep -i 'Uid' | awk '{print $2}' | awk -F / '{print substr($1,4,1)}'`\n\t\t\t\t\tif [ $etc_shadow_group_permission -eq 0 ]; then\n\t\t\t\t\t\tetc_shadow_other_permission=`stat /etc/shadow | grep -i 'Uid' | awk '{print $2}' | awk -F / '{print substr($1,5,1)}'`\n\t\t\t\t\t\tif [ $etc_shadow_other_permission -eq 0 ]; then\n\t\t\t\t\t\t\techo \"※ U-08 결과 : 양호(Good)\" >> $resultfile 2>&1\n\t\t\t\t\t\t\treturn 0\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\techo \"※ U-08 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\t\techo \" /etc/shadow 파일의 다른 사용자(other)에 대한 권한이 취약합니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\t\treturn 0\n\t\t\t\t\t\tfi\n\t\t\t\t\telse\n\t\t\t\t\t\techo \"※ U-08 결과 : N/A\" >> $resultfile 2>&1\n\t\t\t\t\t\techo \" /etc/shadow 파일의 그룹 사용자(group)에 대한 권한이 취약합니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\treturn 0\n\t\t\t\t\tfi\n\t\t\t\telse\n\t\t\t\t\techo \"※ U-08 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\techo \" /etc/shadow 파일의 사용자(owner)에 대한 권한이 취약합니다.\" >> $resultfile 2>&1\n\t\t\t\t\treturn 0\n\t\t\t\tfi\n\t\t\telse\n\t\t\t\techo \"※ U-08 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\techo \" /etc/shadow 파일의 권한이 400보다 큽니다.\" >> $resultfile 2>&1\n\t\t\t\treturn 0\n\t\t\tfi\n\t\telse\n\t\t\techo \"※ U-08 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\techo \" /etc/shadow 파일의 소유자(owner)가 root가 아닙니다.\" >> $resultfile 2>&1\n\t\t\treturn 0\n\t\tfi\n\telse\n\t\techo \"※ U-08 결과 : N/A\" >> $resultfile 2>&1\n\t\techo \" /etc/shadow 파일이 없습니다.\" >> $resultfile 2>&1\n\t\treturn 0\n\tfi\n}\n\nU_09() {\n\techo \"\"  >> $resultfile 2>&1\n\techo \"▶ U-09(상) | 2. 파일 및 디렉토리 관리 > 2.5 /etc/hosts 파일 소유자 및 권한 설정 ◀\"  >> $resultfile 2>&1\n\techo \" 양호 판단 기준 : /etc/hosts 파일의 소유자가 root이고, 권한이 600인 이하인 경우\"  >> $resultfile 2>&1\n\tif [ -f /etc/hosts ]; then\n\t\tetc_hosts_owner_name=`ls -l /etc/hosts | awk '{print $3}'`\n\t\tif [[ $etc_hosts_owner_name =~ root ]]; then\n\t\t\tetc_hosts_permission=`stat /etc/hosts | grep -i 'Uid' | awk '{print $2}' | awk -F / '{print substr($1,3,3)}'`\n\t\t\tif [ $etc_hosts_permission -le 600 ]; then\n\t\t\t\tetc_hosts_owner_permission=`stat /etc/hosts | grep -i 'Uid' | awk '{print $2}' | awk -F / '{print substr($1,3,1)}'`\n\t\t\t\tif [ $etc_hosts_owner_permission -eq 0 ] || [ $etc_hosts_owner_permission -eq 2 ] || [ $etc_hosts_owner_permission -eq 4 ] || [ $etc_hosts_owner_permission -eq 6 ]; then\n\t\t\t\t\tetc_hosts_group_permission=`stat /etc/hosts | grep -i 'Uid' | awk '{print $2}' | awk -F / '{print substr($1,4,1)}'`\n\t\t\t\t\tif [ $etc_hosts_group_permission -eq 0 ]; then\n\t\t\t\t\t\tetc_hosts_other_permission=`stat /etc/hosts | grep -i 'Uid' | awk '{print $2}' | awk -F / '{print substr($1,5,1)}'`\n\t\t\t\t\t\tif [ $etc_hosts_other_permission -eq 0 ]; then\n\t\t\t\t\t\t\techo \"※ U-09 결과 : 양호(Good)\" >> $resultfile 2>&1\n\t\t\t\t\t\t\treturn 0\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\techo \"※ U-09 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\t\techo \" /etc/hosts 파일의 다른 사용자(other)에 대한 권한이 취약합니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\t\treturn 0\n\t\t\t\t\t\tfi\n\t\t\t\t\telse\n\t\t\t\t\t\techo \"※ U-09 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\techo \" /etc/hosts 파일의 그룹 사용자(group)에 대한 권한이 취약합니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\treturn 0\n\t\t\t\t\tfi\n\t\t\t\telse\n\t\t\t\t\techo \"※ U-09 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\techo \" /etc/hosts 파일의 사용자(owner)에 대한 권한이 취약합니다.\" >> $resultfile 2>&1\n\t\t\t\t\treturn 0\n\t\t\t\tfi\n\t\t\telse\n\t\t\t\techo \"※ U-09 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\techo \" /etc/hosts 파일의 권한이 600보다 큽니다.\" >> $resultfile 2>&1\n\t\t\t\treturn 0\n\t\t\tfi\n\t\telse\n\t\t\techo \"※ U-09 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\techo \" /etc/hosts 파일의 소유자(owner)가 root가 아닙니다.\" >> $resultfile 2>&1\n\t\t\treturn 0\n\t\tfi\n\telse\n\t\techo \"※ U-09 결과 : N/A\" >> $resultfile 2>&1\n\t\techo \" /etc/hosts 파일이 없습니다.\" >> $resultfile 2>&1\n\t\treturn 0\n\tfi\n}\n\nU_10() {\n\techo \"\"  >> $resultfile 2>&1\n\techo \"▶ U-10(상) | 2. 파일 및 디렉토리 관리 > 2.6 /etc/(x)inetd.conf 파일 소유자 및 권한 설정 ◀\"  >> $resultfile 2>&1\n\techo \" 양호 판단 기준 : /etc/inetd.conf 파일의 소유자가 root이고, 권한이 600인 경우\"  >> $resultfile 2>&1\n\tfile_exists_count=0\n\tif [ -f /etc/xinetd.conf ]; then\n\t\t((file_exists_count++))\n\t\tetc_xinetdconf_owner_name=`ls -l /etc/xinetd.conf | awk '{print $3}'`\n\t\tif [[ $etc_xinetdconf_owner_name =~ root ]]; then\n\t\t\tetc_xinetdconf_permission=`stat /etc/xinetd.conf | grep -i 'Uid' | awk '{print $2}' | awk -F / '{print substr($1,3,3)}'`\n\t\t\tif [ $etc_xinetdconf_permission -ne 600 ]; then\n\t\t\t\techo \"※ U-10 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\techo \" /etc/xinetd.conf 파일의 권한이 600이 아닙니다.\" >> $resultfile 2>&1\n\t\t\t\treturn 0\n\t\t\tfi\n\t\telse\n\t\t\techo \"※ U-10 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\techo \" /etc/xinetd.conf 파일의 소유자(owner)가 root가 아닙니다.\" >> $resultfile 2>&1\n\t\t\treturn 0\n\t\tfi\n\tfi\n\tif [ -d /etc/xinetd.d ]; then\n\t\tetc_xinetdd_file_count=`find /etc/xinetd.d -type f 2>/dev/null | wc -l`\n\t\tif [ $etc_xinetdd_file_count -gt 0 ]; then\n\t\t\txinetdd_files=(`find /etc/xinetd.d -type f 2>/dev/null`)\n\t\t\tfor ((i=0; i<${#xinetdd_files[@]}; i++))\n\t\t\tdo\n\t\t\t\txinetdd_file_owner_name=`ls -l ${xinetdd_files[$i]} | awk '{print $3}'`\n\t\t\t\tif [[ $xinetdd_file_owner_name =~ root ]]; then\n\t\t\t\t\txinetdd_file_permission=`stat ${xinetdd_files[$i]} | grep -i 'Uid' | awk '{print $2}' | awk -F / '{print substr($1,3,3)}'`\n\t\t\t\t\tif [ $xinetdd_file_permission -ne 600 ]; then\n\t\t\t\t\t\techo \"※ U-10 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\techo \" /etc/xinetd.d 디렉터리 내 파일의 권한이 600이 아닙니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\treturn 0\n\t\t\t\t\tfi\n\t\t\t\telse\n\t\t\t\t\techo \"※ U-10 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\techo \" /etc/xinetd.d 디렉터리 내 파일의 소유자(owner)가 root가 아닙니다.\" >> $resultfile 2>&1\n\t\t\t\t\treturn 0\n\t\t\t\tfi\n\t\t\tdone\n\t\tfi\n\tfi\n\tif [ -f /etc/inetd.conf ]; then\n\t\t((file_exists_count++))\n\t\tetc_inetdconf_owner_name=`ls -l /etc/inetd.conf | awk '{print $3}'`\n\t\tif [[ $etc_inetdconf_owner_name =~ root ]]; then\n\t\t\tetc_inetdconf_permission=`stat /etc/inetd.conf | grep -i 'Uid' | awk '{print $2}' | awk -F / '{print substr($1,3,3)}'`\n\t\t\tif [ $etc_inetdconf_permission -ne 600 ]; then\n\t\t\t\techo \"※ U-10 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\techo \" /etc/inetd.conf 파일의 권한이 600이 아닙니다.\" >> $resultfile 2>&1\n\t\t\t\treturn 0\n\t\t\tfi\n\t\telse\n\t\t\techo \"※ U-10 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\techo \" /etc/inetd.conf 파일의 소유자(owner)가 root가 아닙니다.\" >> $resultfile 2>&1\n\t\t\treturn 0\n\t\tfi\n\tfi\n\tif [ $file_exists_count -eq 0 ]; then\n\t\techo \"※ U-10 결과 : N/A\" >> $resultfile 2>&1\n\t\techo \" /etc/(x)inetd.conf 파일이 없습니다.\" >> $resultfile 2>&1\n\telse\n\t\techo \"※ U-10 결과 : 양호(Good)\" >> $resultfile 2>&1\n\tfi\n}\n\nU_11() {\n\techo \"\"  >> $resultfile 2>&1\n\techo \"▶ U-11(상) | 2. 파일 및 디렉토리 관리 > 2.7 /etc/syslog.conf 파일 소유자 및 권한 설정 ◀\"  >> $resultfile 2>&1\n\techo \" 양호 판단 기준 : /etc/syslog.conf 파일의 소유자가 root(또는 bin, sys)이고, 권한이 640 이하인 경우\"  >> $resultfile 2>&1\n\tsyslogconf_files=(\"/etc/rsyslog.conf\" \"/etc/syslog.conf\" \"/etc/syslog-ng.conf\")\n\tfile_exists_count=0\n\tfor ((i=0; i<${#syslogconf_files[@]}; i++))\n\tdo\n\t\tif [ -f ${syslogconf_files[$i]} ]; then\n\t\t\t((file_exists_count++))\n\t\t\tsyslogconf_file_owner_name=`ls -l ${syslogconf_files[$i]} | awk '{print $3}'`\n\t\t\tif [[ $syslogconf_file_owner_name =~ root ]] || [[ $syslogconf_file_owner_name =~ bin ]] || [[ $syslogconf_file_owner_name =~ sys ]]; then\n\t\t\t\tsyslogconf_file_permission=`stat ${syslogconf_files[$i]} | grep -i 'Uid' | awk '{print $2}' | awk -F / '{print substr($1,3,3)}'`\n\t\t\t\tif [ $syslogconf_file_permission -le 640 ]; then\n\t\t\t\t\tsyslogconf_file_owner_permission=`stat ${syslogconf_files[$i]} | grep -i 'Uid' | awk '{print $2}' | awk -F / '{print substr($1,3,1)}'`\n\t\t\t\t\tif [ $syslogconf_file_owner_permission -eq 6 ] || [ $syslogconf_file_owner_permission -eq 4 ] || [ $syslogconf_file_owner_permission -eq 2 ] || [ $syslogconf_file_owner_permission -eq 0 ]; then\n\t\t\t\t\t\tsyslogconf_file_group_permission=`stat ${syslogconf_files[$i]} | grep -i 'Uid' | awk '{print $2}' | awk -F / '{print substr($1,4,1)}'`\n\t\t\t\t\t\tif [ $syslogconf_file_group_permission -eq 4 ] || [ $syslogconf_file_group_permission -eq 2 ] || [ $syslogconf_file_group_permission -eq 0 ]; then\n\t\t\t\t\t\t\tsyslogconf_file_other_permission=`stat ${syslogconf_files[$i]} | grep -i 'Uid' | awk '{print $2}' | awk -F / '{print substr($1,5,1)}'`\n\t\t\t\t\t\t\tif [ $syslogconf_file_other_permission -ne 0 ]; then\n\t\t\t\t\t\t\t\techo \"※ U-11 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\t\t\techo \" ${syslogconf_files[$i]} 파일의 다른 사용자(other)에 대한 권한이 취약합니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\t\t\treturn 0\n\t\t\t\t\t\t\tfi\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\techo \"※ U-11 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\t\techo \" ${syslogconf_files[$i]} 파일의 그룹 사용자(group)에 대한 권한이 취약합니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\t\treturn 0\n\t\t\t\t\t\tfi\n\t\t\t\t\telse\n\t\t\t\t\t\techo \"※ U-11 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\techo \" ${syslogconf_files[$i]} 파일의 사용자(owner)에 대한 권한이 취약합니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\treturn 0\n\t\t\t\t\tfi\n\t\t\t\telse\n\t\t\t\t\techo \"※ U-11 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\techo \" ${syslogconf_files[$i]} 파일의 권한이 640보다 큽니다.\" >> $resultfile 2>&1\n\t\t\t\t\treturn 0\n\t\t\t\tfi\n\t\t\telse\n\t\t\t\techo \"※ U-11 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\techo \" ${syslogconf_files[$i]} 파일의 소유자(owner)가 root(또는 bin, sys)가 아닙니다.\" >> $resultfile 2>&1\n\t\t\t\treturn 0\n\t\t\tfi\n\t\tfi\n\tdone\n\tif [ $file_exists_count -eq 0 ]; then\n\t\techo \"※ U-11 결과 : N/A\" >> $resultfile 2>&1\n\t\techo \" /etc/syslog.conf 파일이 없습니다.\" >> $resultfile 2>&1\n\t\treturn 0\n\telse\n\t\techo \"※ U-11 결과 : 양호(Good)\" >> $resultfile 2>&1\n\t\treturn 0\n\tfi\n}\n\nU_12() {\n\techo \"\"  >> $resultfile 2>&1\n\techo \"▶ U-12(상) | 2. 파일 및 디렉토리 관리 > 2.8 /etc/services 파일 소유자 및 권한 설정 ◀\"  >> $resultfile 2>&1\n\techo \" 양호 판단 기준 : /etc/services 파일의 소유자가 root(또는 bin, sys)이고, 권한이 644 이하인 경우\"  >> $resultfile 2>&1\n\tif [ -f /etc/services ]; then\n\t\tetc_services_owner_name=`ls -l /etc/services | awk '{print $3}'`\n\t\tif [[ $etc_services_owner_name =~ root ]] || [[ $etc_services_owner_name =~ bin ]] || [[ $etc_services_owner_name =~ sys ]]; then\n\t\t\tetc_services_permission=`stat /etc/services | grep -i 'Uid' | awk '{print $2}' | awk -F / '{print substr($1,3,3)}'`\n\t\t\tif [ $etc_services_permission -le 644 ]; then\n\t\t\t\tetc_services_owner_permission=`stat /etc/services | grep -i 'Uid' | awk '{print $2}' | awk -F / '{print substr($1,3,1)}'`\n\t\t\t\tif [ $etc_services_owner_permission -eq 6 ] || [ $etc_services_owner_permission -eq 4 ] || [ $etc_services_owner_permission -eq 2 ] || [ $etc_services_owner_permission -eq 0 ]; then\n\t\t\t\t\tetc_services_group_permission=`stat /etc/services | grep -i 'Uid' | awk '{print $2}' | awk -F / '{print substr($1,4,1)}'`\n\t\t\t\t\tif [ $etc_services_group_permission -eq 4 ] || [ $etc_services_group_permission -eq 0 ]; then\n\t\t\t\t\t\tetc_services_other_permission=`stat /etc/services | grep -i 'Uid' | awk '{print $2}' | awk -F / '{print substr($1,5,1)}'`\n\t\t\t\t\t\tif [ $etc_services_other_permission -eq 4 ] || [ $etc_services_other_permission -eq 0 ]; then\n\t\t\t\t\t\t\techo \"※ U-12 결과 : 양호(Good)\" >> $resultfile 2>&1\n\t\t\t\t\t\t\treturn 0\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\techo \"※ U-12 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\t\techo \" /etc/services 파일의 다른 사용자(other)에 대한 권한이 취약합니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\t\treturn 0\n\t\t\t\t\t\tfi\n\t\t\t\t\telse\n\t\t\t\t\t\techo \"※ U-12 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\techo \" /etc/services 파일의 그룹 사용자(group)에 대한 권한이 취약합니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\treturn 0\n\t\t\t\t\tfi\n\t\t\t\telse\n\t\t\t\t\techo \"※ U-12 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\techo \" /etc/services 파일의 사용자(owner)에 대한 권한이 취약합니다.\" >> $resultfile 2>&1\n\t\t\t\t\treturn 0\n\t\t\t\tfi\n\t\t\telse\n\t\t\t\techo \"※ U-12 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\techo \" /etc/services 파일의 권한이 644보다 큽니다.\" >> $resultfile 2>&1\n\t\t\t\treturn 0\n\t\t\tfi\n\t\telse\n\t\t\techo \"※ U-12 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\techo \" /etc/services 파일의 파일의 소유자(owner)가 root(또는 bin, sys)가 아닙니다.\" >> $resultfile 2>&1\n\t\t\treturn 0\n\t\tfi\n\telse\n\t\techo \"※ U-12 결과 : N/A\" >> $resultfile 2>&1\n\t\techo \" /etc/services 파일이 없습니다.\" >> $resultfile 2>&1\n\t\treturn 0\n\tfi\n}\n\nU_13() {\n\techo \"\"  >> $resultfile 2>&1\n\techo \"▶ U-13(상) | 2. 파일 및 디렉토리 관리 > 2.9 SUID, SGID, 설정 파일점검 ◀\"  >> $resultfile 2>&1\n\techo \" 양호 판단 기준 : 주요 실행파일의 권한에 SUID와 SGID에 대한 설정이 부여되어 있지 않은 경우\"  >> $resultfile 2>&1\n\texecutables=(\"/sbin/dump\" \"/sbin/restore\" \"/sbin/unix_chkpwd\" \"/usr/bin/at\" \"/usr/bin/lpq\" \"/usr/bin/lpq-lpd\" \"/usr/bin/lpr\" \"/usr/bin/lpr-lpd\" \"/usr/bin/lprm\" \"/usr/bin/lprm-lpd\" \"/usr/bin/newgrp\" \"/usr/sbin/lpc\" \"/usr/sbin/lpc-lpd\" \"/usr/sbin/traceroute\")\n\tfor ((i=0; i<${#executables[@]}; i++))\n\tdo\n\t\tif [ -f ${executables[$i]} ]; then\n\t\t\tif [ `ls -l ${executables[$i]} | awk '{print substr($1,2,9)}' | grep -i 's' | wc -l` -gt 0 ]; then\n\t\t\t\techo \"※ U-13 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\techo \" 주요 실행 파일의 권한에 SUID나 SGID에 대한 설정이 부여되어 있습니다.\" >> $resultfile 2>&1\n\t\t\t\treturn 0\n\t\t\tfi\n\t\tfi\n\tdone\n\techo \"※ U-13 결과 : 양호(Good)\" >> $resultfile 2>&1\n\treturn 0\n}\n\nU_14() {\n\techo \"\"  >> $resultfile 2>&1\n\techo \"▶ U-14(상) | 2. 파일 및 디렉토리 관리 > 2.10 사용자, 시스템 시작파일 및 환경파일 소유자 및 권한 설정 ◀\"  >> $resultfile 2>&1\n\techo \" 양호 판단 기준 : 홈 디렉터리 환경변수 파일 소유자가 root 또는, 해당 계정으로 지정되어 있고, 홈 디렉터리 환경변수 파일에 root와 소유자만 쓰기 권한이 부여된 경우\"  >> $resultfile 2>&1\n\tuser_homedirectory_path=(`awk -F : '$7!=\"/bin/false\" && $7!=\"/sbin/nologin\" && $6!=null {print $6}' /etc/passwd`) # /etc/passwd 파일에 설정된 홈 디렉터리 배열 생성\n\tuser_homedirectory_path2=(/home/*) # /home 디렉터래 내 위치한 홈 디렉터리 배열 생성\n\tfor ((i=0; i<${#user_homedirectory_path2[@]}; i++))\n\tdo\n\t\tuser_homedirectory_path[${#user_homedirectory_path[@]}]=${user_homedirectory_path2[$i]} # 두 개의 배열 합침\n\tdone\n\tuser_homedirectory_owner_name=(`awk -F : '$7!=\"/bin/false\" && $7!=\"/sbin/nologin\" && $6!=null {print $1}' /etc/passwd`) # /etc/passwd 파일에 설정된 사용자명 배열 생성\n\tuser_homedirectory_owner_name2=() # user_homedirectory_path2 배열에서 사용자명만 따로 출력하여 저장할 빈 배열 생성\n\tfor ((i=0; i<${#user_homedirectory_path2[@]}; i++))\n\tdo\n\t\tuser_homedirectory_owner_name2[${#user_homedirectory_owner_name2[@]}]=`echo ${user_homedirectory_path2[$i]} | awk -F / '{print $3}'` # user_homedirectory_path2 배열에서 사용자명만 따로 출력하여 배열에 저장함\n\tdone\n\tfor ((i=0; i<${#user_homedirectory_owner_name2[@]}; i++))\n\tdo\n\t\tuser_homedirectory_owner_name[${#user_homedirectory_owner_name[@]}]=${user_homedirectory_owner_name2[$i]} # 두 개의 배열 합침\n\tdone\n\tstart_files=(\".profile\" \".cshrc\" \".login\" \".kshrc\" \".bash_profile\" \".bashrc\" \".bash_login\")\n\tfor ((i=0; i<${#user_homedirectory_path[@]}; i++))\n\tdo\n\t\tfor ((j=0; j<${#start_files[@]}; j++))\n\t\tdo\n\t\t\tif [ -f ${user_homedirectory_path[$i]}/${start_files[$j]} ]; then\n\t\t\t\tuser_homedirectory_owner_name2=`ls -l ${user_homedirectory_path[$i]}/${start_files[$j]} | awk '{print $3}'`\n\t\t\t\tif [[ $user_homedirectory_owner_name2 =~ root ]] || [[ $user_homedirectory_owner_name2 =~ ${user_homedirectory_owner_name[$i]} ]]; then\n\t\t\t\t\tuser_homedirectory_other_execute_permission=`ls -l ${user_homedirectory_path[$i]}/${start_files[$j]} | awk '{print substr($1,9,1)}'`\n\t\t\t\t\tif [[ $user_homedirectory_other_execute_permission =~ w ]]; then\n\t\t\t\t\t\techo \"※ U-14 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\techo \" ${user_homedirectory_path[$i]} 홈 디렉터리 내 ${start_files[$j]} 환경 변수 파일에 다른 사용자(other)의 쓰기(w) 권한이 부여 되어 있습니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\treturn 0\n\t\t\t\t\tfi\n\t\t\t\telse\n\t\t\t\t\techo \"※ U-14 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\techo \" ${user_homedirectory_path[$i]} 홈 디렉터리 내 ${start_files[$j]} 환경 변수 파일의 소유자(owner)가 root 또는 해당 계정이 아닙니다.\" >> $resultfile 2>&1\n\t\t\t\t\treturn 0\n\t\t\t\tfi\n\t\t\tfi\n\t\tdone\n\tdone\n\techo \"※ U-14 결과 : 양호(Good)\" >> $resultfile 2>&1\n\treturn 0\n}\n\nU_15() {\n\techo \"\"  >> $resultfile 2>&1\n\techo \"▶ U-15(상) | 2. 파일 및 디렉토리 관리 > 2.11 world writable 파일 점검 ◀\"  >> $resultfile 2>&1\n\techo \" 양호 판단 기준 : 시스템 중요 파일에 world writable 파일이 존재하지 않거나, 존재 시 설정 이유를 확인하고 있는 경우\"  >> $resultfile 2>&1\n\tif [ `find / -type f -perm -2 2>/dev/null | wc -l` -gt 0 ]; then\n\t\techo \"※ U-15 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\techo \" world writable 설정이 되어있는 파일이 있습니다.\" >> $resultfile 2>&1\n\t\treturn 0\n\telse\n\t\techo \"※ U-15 결과 : 양호(Good)\" >> $resultfile 2>&1\n\t\treturn 0\n\tfi\n}\n\nU_16() {\n\techo \"\"  >> $resultfile 2>&1\n\techo \"▶ U-16(상) | 2. 파일 및 디렉토리 관리 > 2.12 /dev에 존재하지 않는 device 파일 점검 ◀\"  >> $resultfile 2>&1\n\techo \" 양호 판단 기준 : /dev에 대한 파일 점검 후 존재하지 않은 device 파일을 제거한 경우\" >> $resultfile 2>&1\n\tif [ `find /dev -type f 2>/dev/null | wc -l` -gt 0 ]; then\n\t\techo \"※ U-16 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\techo \" /dev 디렉터리에 존재하지 않는 device 파일이 존재합니다.\" >> $resultfile 2>&1\n\t\treturn 0\n\telse\n\t\techo \"※ U-16 결과 : 양호(Good)\" >> $resultfile 2>&1\n\t\treturn 0\n\tfi\n}\n\nU_17() {\n\techo \"\"  >> $resultfile 2>&1\n\techo \"▶ U-17(상) | 2. 파일 및 디렉토리 관리 > 2.13 $HOME/.rhosts, hosts.equiv 사용 금지 ◀\"  >> $resultfile 2>&1\n\techo \" 양호 판단 기준 : login, shell, exec 서비스를 사용하지 않거나, 사용 시 아래와 같은 설정이 적용된 경우\" >> $resultfile 2>&1\n\techo \" 1. /etc/hosts.equiv 및 $HOME/.rhosts 파일 소유자가 root 또는, 해당 계정인 경우\" >> $resultfile 2>&1\n\techo \" 2. /etc/hosts.equiv 및 $HOME/.rhosts 파일 권한이 600 이하인 경우\" >> $resultfile 2>&1\n\techo \" 3. /etc/hosts.equiv 및 $HOME/.rhosts 파일 설정에 ‘+’ 설정이 없는 경우\" >> $resultfile 2>&1\n\tuser_homedirectory_path=(`awk -F : '$7!=\"/bin/false\" && $7!=\"/sbin/nologin\" && $6!=null {print $6}' /etc/passwd`) # /etc/passwd 파일에 설정된 홈 디렉터리 배열 생성\n\tuser_homedirectory_path2=(/home/*) # /home 디렉터래 내 위치한 홈 디렉터리 배열 생성\n\tfor ((i=0; i<${#user_homedirectory_path2[@]}; i++))\n\tdo\n\t\tuser_homedirectory_path[${#user_homedirectory_path[@]}]=${user_homedirectory_path2[$i]} # 두 개의 배열 합침\n\tdone\n\tuser_homedirectory_owner_name=(`awk -F : '$7!=\"/bin/false\" && $7!=\"/sbin/nologin\" && $6!=null {print $1}' /etc/passwd`) # /etc/passwd 파일에 설정된 사용자명 배열 생성\n\tuser_homedirectory_owner_name2=() # user_homedirectory_path2 배열에서 사용자명만 따로 출력하여 저장할 빈 배열 생성\n\tfor ((i=0; i<${#user_homedirectory_path2[@]}; i++))\n\tdo\n\t\tuser_homedirectory_owner_name2[${#user_homedirectory_owner_name2[@]}]=`echo ${user_homedirectory_path2[$i]} | awk -F / '{print $3}'` # user_homedirectory_path2 배열에서 사용자명만 따로 출력하여 배열에 저장함\n\tdone\n\tfor ((i=0; i<${#user_homedirectory_owner_name2[@]}; i++))\n\tdo\n\t\tuser_homedirectory_owner_name[${#user_homedirectory_owner_name[@]}]=${user_homedirectory_owner_name2[$i]} # 두 개의 배열 합침\n\tdone\n\tr_command=(\"rsh\" \"rlogin\" \"rexec\" \"shell\" \"login\" \"exec\")\n\t# /etc/xinetd.d 디렉터리 내 r command 파일 확인함\n\tif [ -d /etc/xinetd.d ]; then\n\t\tfor ((i=0; i<${#r_command[@]}; i++))\n\t\tdo\n\t\t\tif [ -f /etc/xinetd.d/${r_command[$i]} ]; then\n\t\t\t\tetc_xinetdd_rcommand_disable_count=`grep -vE '^#|^\\s#' /etc/xinetd.d/${r_command[$i]} | grep -i 'disable' | grep -i 'yes' | wc -l`\n\t\t\t\tif [ $etc_xinetdd_rcommand_disable_count -eq 0 ]; then\n\t\t\t\t\tif [ -f /etc/hosts.equiv ]; then\n\t\t\t\t\t\tetc_hostsequiv_owner_name=`ls -l /etc/hosts.equiv | awk '{print $3}'`\n\t\t\t\t\t\tif [[ $etc_hostsequiv_owner_name =~ root ]]; then\n\t\t\t\t\t\t\tetc_hostsequiv_permission=`stat /etc/hosts.equiv | grep -i 'Uid' | awk '{print $2}' | awk -F / '{print substr($1,3,3)}'`\n\t\t\t\t\t\t\tif [ $etc_hostsequiv_permission -le 600 ]; then\n\t\t\t\t\t\t\t\tetc_hostsequiv_owner_permission=`stat /etc/hosts.equiv | grep -i 'Uid' | awk '{print $2}' | awk -F / '{print substr($1,3,1)}'`\n\t\t\t\t\t\t\t\tif [ $etc_hostsequiv_owner_permission -eq 6 ] || [ $etc_hostsequiv_owner_permission -eq 4 ] || [ $etc_hostsequiv_owner_permission -eq 2 ] || [ $etc_hostsequiv_owner_permission -eq 0 ]; then\n\t\t\t\t\t\t\t\t\tetc_hostsequiv_group_permission=`stat /etc/hosts.equiv | grep -i 'Uid' | awk '{print $2}' | awk -F / '{print substr($1,4,1)}'`\n\t\t\t\t\t\t\t\t\tif [ $etc_hostsequiv_group_permission -eq 0 ]; then\n\t\t\t\t\t\t\t\t\t\tetc_hostsequiv_other_permission=`stat /etc/hosts.equiv | grep -i 'Uid' | awk '{print $2}' | awk -F / '{print substr($1,5,1)}'`\n\t\t\t\t\t\t\t\t\t\tif [ $etc_hostsequiv_other_permission -eq 0 ]; then\n\t\t\t\t\t\t\t\t\t\t\tetc_hostsequiv_plus_count=`grep -vE '^#|^\\s#' /etc/hosts.equiv | grep '+' | wc -l`\n\t\t\t\t\t\t\t\t\t\t\tif [ $etc_hostsequiv_plus_count -gt 0 ]; then\n\t\t\t\t\t\t\t\t\t\t\t\techo \"※ U-17 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\t\t\t\t\t\t\techo \" r 계열 서비스를 사용하고, /etc/hosts.equiv 파일에 '+' 설정이 있습니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\t\t\t\t\t\t\treturn 0\n\t\t\t\t\t\t\t\t\t\t\tfi\n\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t\techo \"※ U-17 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\t\t\t\t\t\techo \" r 계열 서비스를 사용하고, /etc/hosts.equiv 파일의 다른 사용자(other)에 대한 권한이 취약합니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\t\t\t\t\t\treturn 0\n\t\t\t\t\t\t\t\t\t\tfi\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\techo \"※ U-17 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\t\t\t\t\techo \" r 계열 서비스를 사용하고, /etc/hosts.equiv 파일의 그룹 사용자(group)에 대한 권한이 취약합니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\t\t\t\t\treturn 0\n\t\t\t\t\t\t\t\t\tfi\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\techo \"※ U-17 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\t\t\t\techo \" r 계열 서비스를 사용하고, /etc/hosts.equiv 파일의 사용자(owner)에 대한 권한이 취약합니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\t\t\t\treturn 0\n\t\t\t\t\t\t\t\tfi\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\techo \"※ U-17 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\t\t\techo \" r 계열 서비스를 사용하고, /etc/hosts.equiv 파일의 권한이 600보다 큽니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\t\t\treturn 0\n\t\t\t\t\t\t\tfi\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\techo \"※ U-17 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\t\techo \" r 계열 서비스를 사용하고, /etc/hosts.equiv 파일의 소유자(owner)가 root가 아닙니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\t\treturn 0\n\t\t\t\t\t\tfi\n\t\t\t\t\tfi\n\t\t\t\t\t# 사용자 홈 디렉터리 내 .rhosts 파일 확인함\n\t\t\t\t\tfor ((j=0; j<${#user_homedirectory_path[@]}; j++))\n\t\t\t\t\tdo\n\t\t\t\t\t\tif [ -f ${user_homedirectory_path[$j]}/.rhosts ]; then\n\t\t\t\t\t\t\tuser_homedirectory_rhosts_owner_name=`ls -l ${user_homedirectory_path[$j]}/.rhosts | awk '{print $3}'`\n\t\t\t\t\t\t\tif [[ $user_homedirectory_rhosts_owner_name =~ root ]] || [[ $user_homedirectory_rhosts_owner_name =~ ${user_homedirectory_owner_name[$j]} ]]; then\n\t\t\t\t\t\t\t\tuser_homedirectory_rhosts_permission=`stat ${user_homedirectory_path[$j]}/.rhosts | grep -i 'Uid' | awk '{print $2}' | awk -F / '{print substr($1,3,3)}'`\n\t\t\t\t\t\t\t\tif [ $user_homedirectory_rhosts_permission -le 600 ]; then\n\t\t\t\t\t\t\t\t\tuser_homedirectory_rhosts_owner_permission=`stat ${user_homedirectory_path[$j]}/.rhosts | grep -i 'Uid' | awk '{print $2}' | awk -F / '{print substr($1,3,1)}'`\n\t\t\t\t\t\t\t\t\tif [ $user_homedirectory_rhosts_owner_permission -eq 6 ] || [ $user_homedirectory_rhosts_owner_permission -eq 4 ] || [ $user_homedirectory_rhosts_owner_permission -eq 2 ] || [ $user_homedirectory_rhosts_owner_permission -eq 0 ]; then\n\t\t\t\t\t\t\t\t\t\tuser_homedirectory_rhosts_group_permission=`stat ${user_homedirectory_path[$j]}/.rhosts | grep -i 'Uid' | awk '{print $2}' | awk -F / '{print substr($1,4,1)}'`\n\t\t\t\t\t\t\t\t\t\tif [ $user_homedirectory_rhosts_group_permission -eq 0 ]; then\n\t\t\t\t\t\t\t\t\t\t\tuser_homedirectory_rhosts_other_permission=`stat ${user_homedirectory_path[$j]}/.rhosts | grep -i 'Uid' | awk '{print $2}' | awk -F / '{print substr($1,5,1)}'`\n\t\t\t\t\t\t\t\t\t\t\tif [ $user_homedirectory_rhosts_other_permission -eq 0 ]; then\n\t\t\t\t\t\t\t\t\t\t\t\tuser_homedirectory_rhosts_plus_count=`grep -vE '^#|^\\s#' ${user_homedirectory_path[$j]}/.rhosts | grep '+' | wc -l`\n\t\t\t\t\t\t\t\t\t\t\t\tif [ $user_homedirectory_rhosts_plus_count -gt 0 ]; then\n\t\t\t\t\t\t\t\t\t\t\t\t\techo \"※ U-17 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\t\t\t\t\t\t\t\techo \" r 계열 서비스를 사용하고, 사용자 홈 디렉터리 내 .rhosts 파일에 '+' 설정이 있습니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\t\t\t\t\t\t\t\treturn 0\n\t\t\t\t\t\t\t\t\t\t\t\tfi\n\t\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t\t\techo \"※ U-17 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\t\t\t\t\t\t\techo \" r 계열 서비스를 사용하고, 사용자 홈 디렉터리 내 .rhosts 파일의 다른 사용자(other)에 대한 권한이 취약합니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\t\t\t\t\t\t\treturn 0\n\t\t\t\t\t\t\t\t\t\t\tfi\n\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t\techo \"※ U-17 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\t\t\t\t\t\techo \" r 계열 서비스를 사용하고, 사용자 홈 디렉터리 내 .rhosts 파일의 그룹 사용자(group)에 대한 권한이 취약합니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\t\t\t\t\t\treturn 0\n\t\t\t\t\t\t\t\t\t\tfi\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\techo \"※ U-17 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\t\t\t\t\techo \" r 계열 서비스를 사용하고, 사용자 홈 디렉터리 내 .rhosts 파일의 사용자(owner)에 대한 권한이 취약합니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\t\t\t\t\treturn 0\n\t\t\t\t\t\t\t\t\tfi\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\techo \"※ U-17 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\t\t\t\techo \" r 계열 서비스를 사용하고, 사용자 홈 디렉터리 내 .rhosts 파일의 권한이 600보다 큽니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\t\t\t\treturn 0\n\t\t\t\t\t\t\t\tfi\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\techo \"※ U-17 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\t\t\techo \" r 계열 서비스를 사용하고, 사용자 홈 디렉터리 내 .rhosts 파일의 소유자(owner)가 root 또는 해당 계정이 아닙니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\t\t\treturn 0\n\t\t\t\t\t\t\tfi\n\t\t\t\t\t\tfi\n\t\t\t\t\tdone\n\t\t\t\tfi\n\t\t\tfi\n\t\tdone\n\tfi\n\t# /etc/inetd.conf 파일 내 r command 서비스 확인함\n\tif [ -f /etc/inetd.conf ]; then\n\t\tfor ((i=0; i<${#r_command[@]}; i++))\n\t\tdo\n\t\t\tif [ `grep -vE '^#|^\\s#' /etc/inetd.conf | grep  ${r_command[$i]} | wc -l` -gt 0 ]; then\n\t\t\t\tif [ -f /etc/hosts.equiv ]; then\n\t\t\t\t\tetc_hostsequiv_owner_name=`ls -l /etc/hosts.equiv | awk '{print $3}'`\n\t\t\t\t\tif [[ $etc_hostsequiv_owner_name =~ root ]]; then\n\t\t\t\t\t\tetc_hostsequiv_permission=`stat /etc/hosts.equiv | grep -i 'Uid' | awk '{print $2}' | awk -F / '{print substr($1,3,3)}'`\n\t\t\t\t\t\tif [ $etc_hostsequiv_permission -le 600 ]; then\n\t\t\t\t\t\t\tetc_hostsequiv_owner_permission=`stat /etc/hosts.equiv | grep -i 'Uid' | awk '{print $2}' | awk -F / '{print substr($1,3,1)}'`\n\t\t\t\t\t\t\tif [ $etc_hostsequiv_owner_permission -eq 6 ] || [ $etc_hostsequiv_owner_permission -eq 4 ] || [ $etc_hostsequiv_owner_permission -eq 2 ] || [ $etc_hostsequiv_owner_permission -eq 0 ]; then\n\t\t\t\t\t\t\t\tetc_hostsequiv_group_permission=`stat /etc/hosts.equiv | grep -i 'Uid' | awk '{print $2}' | awk -F / '{print substr($1,4,1)}'`\n\t\t\t\t\t\t\t\tif [ $etc_hostsequiv_group_permission -eq 0 ]; then\n\t\t\t\t\t\t\t\t\tetc_hostsequiv_other_permission=`stat /etc/hosts.equiv | grep -i 'Uid' | awk '{print $2}' | awk -F / '{print substr($1,5,1)}'`\n\t\t\t\t\t\t\t\t\tif [ $etc_hostsequiv_other_permission -eq 0 ]; then\n\t\t\t\t\t\t\t\t\t\tetc_hostsequiv_plus_count=`grep -vE '^#|^\\s#' /etc/hosts.equiv | grep '+' | wc -l`\n\t\t\t\t\t\t\t\t\t\tif [ $etc_hostsequiv_plus_count -gt 0 ]; then\n\t\t\t\t\t\t\t\t\t\t\techo \"※ U-17 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\t\t\t\t\t\techo \" r 계열 서비스를 사용하고, /etc/hosts.equiv 파일에 '+' 설정이 있습니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\t\t\t\t\t\treturn 0\n\t\t\t\t\t\t\t\t\t\tfi\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\techo \"※ U-17 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\t\t\t\t\techo \" r 계열 서비스를 사용하고, /etc/hosts.equiv 파일의 다른 사용자(other)에 대한 권한이 취약합니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\t\t\t\t\treturn 0\n\t\t\t\t\t\t\t\t\tfi\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\techo \"※ U-17 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\t\t\t\techo \" r 계열 서비스를 사용하고, /etc/hosts.equiv 파일의 그룹 사용자(group)에 대한 권한이 취약합니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\t\t\t\treturn 0\n\t\t\t\t\t\t\t\tfi\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\techo \"※ U-17 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\t\t\techo \" r 계열 서비스를 사용하고, /etc/hosts.equiv 파일의 사용자(owner)에 대한 권한이 취약합니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\t\t\treturn 0\n\t\t\t\t\t\t\tfi\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\techo \"※ U-17 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\t\techo \" r 계열 서비스를 사용하고, /etc/hosts.equiv 파일의 권한이 600보다 큽니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\t\treturn 0\n\t\t\t\t\t\tfi\n\t\t\t\t\telse\n\t\t\t\t\t\techo \"※ U-17 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\techo \" r 계열 서비스를 사용하고, /etc/hosts.equiv 파일의 소유자(owner)가 root가 아닙니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\treturn 0\n\t\t\t\t\tfi\n\t\t\t\tfi\n\t\t\t\t# 사용자 홈 디렉터리 내 .rhosts 파일 확인함\n\t\t\t\tfor ((j=0; j<${#user_homedirectory_path[@]}; j++))\n\t\t\t\tdo\n\t\t\t\t\tif [ -f ${user_homedirectory_path[$j]}/.rhosts ]; then\n\t\t\t\t\t\tuser_homedirectory_rhosts_owner_name=`ls -l ${user_homedirectory_path[$j]}/.rhosts | awk '{print $3}'`\n\t\t\t\t\t\tif [[ $user_homedirectory_rhosts_owner_name =~ root ]] || [[ $user_homedirectory_rhosts_owner_name =~ ${user_homedirectory_owner_name[$j]} ]]; then\n\t\t\t\t\t\t\tuser_homedirectory_rhosts_permission=`stat ${user_homedirectory_path[$j]}/.rhosts | grep -i 'Uid' | awk '{print $2}' | awk -F / '{print substr($1,3,3)}'`\n\t\t\t\t\t\t\tif [ $user_homedirectory_rhosts_permission -le 600 ]; then\n\t\t\t\t\t\t\t\tuser_homedirectory_rhosts_owner_permission=`stat ${user_homedirectory_path[$j]}/.rhosts | grep -i 'Uid' | awk '{print $2}' | awk -F / '{print substr($1,3,1)}'`\n\t\t\t\t\t\t\t\tif [ $user_homedirectory_rhosts_owner_permission -eq 6 ] || [ $user_homedirectory_rhosts_owner_permission -eq 4 ] || [ $user_homedirectory_rhosts_owner_permission -eq 2 ] || [ $user_homedirectory_rhosts_owner_permission -eq 0 ]; then\n\t\t\t\t\t\t\t\t\tuser_homedirectory_rhosts_group_permission=`stat ${user_homedirectory_path[$j]}/.rhosts | grep -i 'Uid' | awk '{print $2}' | awk -F / '{print substr($1,4,1)}'`\n\t\t\t\t\t\t\t\t\tif [ $user_homedirectory_rhosts_group_permission -eq 0 ]; then\n\t\t\t\t\t\t\t\t\t\tuser_homedirectory_rhosts_other_permission=`stat ${user_homedirectory_path[$j]}/.rhosts | grep -i 'Uid' | awk '{print $2}' | awk -F / '{print substr($1,5,1)}'`\n\t\t\t\t\t\t\t\t\t\tif [ $user_homedirectory_rhosts_other_permission -eq 0 ]; then\n\t\t\t\t\t\t\t\t\t\t\tuser_homedirectory_rhosts_plus_count=`grep -vE '^#|^\\s#' ${user_homedirectory_path[$j]}/.rhosts | grep '+' | wc -l`\n\t\t\t\t\t\t\t\t\t\t\tif [ $user_homedirectory_rhosts_plus_count -gt 0 ]; then\n\t\t\t\t\t\t\t\t\t\t\t\techo \"※ U-17 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\t\t\t\t\t\t\techo \" r 계열 서비스를 사용하고, 사용자 홈 디렉터리 내 .rhosts 파일에 '+' 설정이 있습니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\t\t\t\t\t\t\treturn 0\n\t\t\t\t\t\t\t\t\t\t\tfi\n\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t\techo \"※ U-17 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\t\t\t\t\t\techo \" r 계열 서비스를 사용하고, 사용자 홈 디렉터리 내 .rhosts 파일의 다른 사용자(other)에 대한 권한이 취약합니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\t\t\t\t\t\treturn 0\n\t\t\t\t\t\t\t\t\t\tfi\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\techo \"※ U-17 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\t\t\t\t\techo \" r 계열 서비스를 사용하고, 사용자 홈 디렉터리 내 .rhosts 파일의 그룹 사용자(group)에 대한 권한이 취약합니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\t\t\t\t\treturn 0\n\t\t\t\t\t\t\t\t\tfi\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\techo \"※ U-17 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\t\t\t\techo \" r 계열 서비스를 사용하고, 사용자 홈 디렉터리 내 .rhosts 파일의 사용자(owner)에 대한 권한이 취약합니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\t\t\t\treturn 0\n\t\t\t\t\t\t\t\tfi\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\techo \"※ U-17 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\t\t\techo \" r 계열 서비스를 사용하고, 사용자 홈 디렉터리 내 .rhosts 파일의 권한이 600보다 큽니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\t\t\treturn 0\n\t\t\t\t\t\t\tfi\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\techo \"※ U-17 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\t\techo \" r 계열 서비스를 사용하고, 사용자 홈 디렉터리 내 .rhosts 파일의 소유자(owner)가 root 또는 해당 계정이 아닙니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\t\treturn 0\n\t\t\t\t\t\tfi\n\t\t\t\t\tfi\n\t\t\t\tdone\n\t\t\tfi\n\t\tdone\n\tfi\n\techo \"※ U-17 결과 : 양호(Good)\" >> $resultfile 2>&1\n\treturn 0\n}\n\nU_18() {\n\techo \"\"  >> $resultfile 2>&1\n\techo \"▶ U-18(상) | 2. 파일 및 디렉토리 관리 > 2.14 접속 IP 및 포트 제한 ◀\"  >> $resultfile 2>&1\n\techo \" 양호 판단 기준 : 접속을 허용할 특정 호스트에 대한 IP 주소 및 포트 제한을 설정한 경우\" >> $resultfile 2>&1\n\techo \" ### /etc/hosts.deny 파일에 ALL:ALL 설정이 없거나 /etc/hosts.allow 파일에 ALL:ALL 설정이 있을 경우 취약으로 판단\" >> $resultfile 2>&1\n\techo \" ### iptables 사용 시 수동 점검을 추가로 진행하세요.\" >> $resultfile 2>&1\n\tif [ -f /etc/hosts.deny ]; then\n\t\tetc_hostsdeny_allall_count=`grep -vE '^#|^\\s#' /etc/hosts.deny | awk '{gsub(\" \", \"\", $0); print}' | grep -i 'all:all' | wc -l`\n\t\tif [ $etc_hostsdeny_allall_count -gt 0 ]; then\n\t\t\tif [ -f /etc/hosts.allow ]; then\n\t\t\t\tetc_hostsallow_allall_count=`grep -vE '^#|^\\s#' /etc/hosts.allow | awk '{gsub(\" \", \"\", $0); print}' | grep -i 'all:all' | wc -l`\n\t\t\t\tif [ $etc_hostsallow_allall_count -gt 0 ]; then\n\t\t\t\t\techo \"※ U-18 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\techo \" /etc/hosts.allow 파일에 'ALL : ALL' 설정이 있습니다.\" >> $resultfile 2>&1\n\t\t\t\t\treturn 0\n\t\t\t\telse\n\t\t\t\t\techo \"※ U-18 결과 : 양호(Good)\" >> $resultfile 2>&1\n\t\t\t\t\treturn 0\n\t\t\t\tfi\n\t\t\telse\n\t\t\t\techo \"※ U-18 결과 : 양호(Good)\" >> $resultfile 2>&1\n\t\t\t\treturn 0\n\t\t\tfi\n\t\telse\n\t\t\techo \"※ U-18 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\techo \" /etc/hosts.deny 파일에 'ALL : ALL' 설정이 없습니다.\" >> $resultfile 2>&1\n\t\t\treturn 0\n\t\tfi\n\telse\n\t\techo \"※ U-18 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\techo \" /etc/hosts.deny 파일이 없습니다.\" >> $resultfile 2>&1\n\t\treturn 0\n\tfi\n}\n\nU_19() {\n\techo \"\"  >> $resultfile 2>&1\n\techo \"▶ U-19(상) | 3. 서비스 관리 > 3.1 Finger 서비스 비활성화 ◀\"  >> $resultfile 2>&1\n\techo \" 양호 판단 기준 : Finger 서비스가 비활성화 되어 있는 경우\" >> $resultfile 2>&1\n\tif [ -f /etc/services ]; then\n\t\tfinger_port_count=`grep -vE '^#|^\\s#' /etc/services | awk 'tolower($1)==\"finger\" {print $2}' | awk -F / 'tolower($2)==\"tcp\" {print $1}' | wc -l`\n\t\tif [ $finger_port_count -gt 0 ]; then\n\t\t\tfinger_port=(`grep -vE '^#|^\\s#' /etc/services | awk 'tolower($1)==\"finger\" {print $2}' | awk -F / 'tolower($2)==\"tcp\" {print $1}'`)\n\t\t\tfor ((i=0; i<${#finger_port[@]}; i++))\n\t\t\tdo\n\t\t\t\tnetstat_finger_count=`netstat -nat 2>/dev/null | grep -w 'tcp' | grep -Ei 'listen|established|syn_sent|syn_received' | grep \":${finger_port[$i]} \" | wc -l`\n\t\t\t\tif [ $netstat_finger_count -gt 0 ]; then\n\t\t\t\t\techo \"※ U-19 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\techo \" finger 서비스가 실행 중입니다.\" >> $resultfile 2>&1\n\t\t\t\t\treturn 0\n\t\t\t\tfi\n\t\t\tdone\n\t\tfi\n\tfi\n\tps_finger_count=`ps -ef | grep -i 'finger' | grep -v 'grep' | wc -l`\n\tif [ $ps_finger_count -gt 0 ]; then\n\t\techo \"※ U-19 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\techo \" finger 서비스가 실행 중입니다.\" >> $resultfile 2>&1\n\t\treturn 0\n\telse\n\t\techo \"※ U-19 결과 : 양호(Good)\" >> $resultfile 2>&1\n\t\treturn 0\n\tfi\n}\n\nU_20() {\n\techo \"\"  >> $resultfile 2>&1\n\techo \"▶ U-20(상) | 3. 서비스 관리 > 3.2 Anonymous FTP 비활성화 ◀\"  >> $resultfile 2>&1\n\techo \" 양호 판단 기준 : Anonymous FTP (익명 ftp) 접속을 차단한 경우\" >> $resultfile 2>&1\n\tif [ -f /etc/passwd ]; then\n\t\tif [ `awk -F : '$1==\"ftp\" || $1==\"anonymous\"' /etc/passwd | wc -l` -gt 0 ]; then\n\t\t\tfile_exists_count=0\n\t\t\tif [ `find / -name 'proftpd.conf' -type f 2>/dev/null | wc -l` -gt 0 ]; then\n\t\t\t\tproftpdconf_settings_files=(`find / -name 'proftpd.conf' -type f 2>/dev/null`)\n\t\t\t\tfor ((i=0; i<${#proftpdconf_settings_files[@]}; i++))\n\t\t\t\tdo\n\t\t\t\t\t((file_exists_count++))\n\t\t\t\t\tproftpdconf_anonymous_start_line_count=`grep -vE '^#|^\\s#' ${proftpdconf_settings_files[$i]} | grep '<Anonymous' | wc -l`\n\t\t\t\t\tproftpdconf_anonymous_end_line_count=`grep -vE '^#|^\\s#' ${proftpdconf_settings_files[$i]} | grep '</Anonymous>' | wc -l`\n\t\t\t\t\tif [ $proftpdconf_anonymous_start_line_count -gt 0 ] && [ $proftpdconf_anonymous_end_line_count -gt 0 ]; then\n\t\t\t\t\t\tproftpdconf_anonymous_start_line=`grep -vE '^#|^\\s#' ${proftpdconf_settings_files[$i]} | grep -n '<Anonymous' | awk -F : '{print $1}'`\n\t\t\t\t\t\tproftpdconf_anonymous_end_line=`grep -vE '^#|^\\s#' ${proftpdconf_settings_files[$i]} | grep -n '</Anonymous>' | awk -F : '{print $1}'`\n\t\t\t\t\t\tproftpdconf_anonymous_contents_range=$((proftpdconf_anonymous_end_line-proftpdconf_anonymous_start_line))\n\t\t\t\t\t\tproftpdconf_anonymous_enable_count=`grep -vE '^#|^\\s#' ${proftpdconf_settings_files[$i]} | grep -A $proftpdconf_anonymous_contents_range '<Anonymous' | grep -wE 'User|UserAlias' | wc -l`\n\t\t\t\t\t\tif [ $proftpdconf_anonymous_enable_count -gt 0 ]; then\n\t\t\t\t\t\t\techo \"※ U-20 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\t\techo \" ${proftpdconf_settings_files[$i]} 파일에서 'User' 또는 'UserAlias' 옵션이 삭제 또는 주석 처리되어 있지 않습니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\t\treturn 0\n\t\t\t\t\t\tfi\n\t\t\t\t\tfi\n\t\t\t\tdone\n\t\t\tfi\n\t\t\tif [ `find / -name 'vsftpd.conf' -type f 2>/dev/null | wc -l` -gt 0 ]; then\n\t\t\t\t((file_exists_count++))\n\t\t\t\tvsftpdconf_settings_files=(`find / -name 'vsftpd.conf' -type f 2>/dev/null`)\n\t\t\t\tsettings_in_vsftpdconf=0\n\t\t\t\tfor ((i=0; i<${#vsftpdconf_settings_files[@]}; i++))\n\t\t\t\tdo\n\t\t\t\t\tvsftpdconf_anonymous_enable_count=`grep -vE '^#|^\\s#' ${vsftpdconf_settings_files[$i]} | grep -i 'anonymous_enable' | wc -l`\n\t\t\t\t\tif [ $vsftpdconf_anonymous_enable_count -gt 0 ]; then\n\t\t\t\t\t\t((settings_in_vsftpdconf++))\n\t\t\t\t\t\tvsftpdconf_anonymous_enable_value=`grep -vE '^#|^\\s#' ${vsftpdconf_settings_files[$i]} | grep -i 'anonymous_enable' | awk '{gsub(\" \", \"\", $0); print tolower($0)}' | awk -F 'anonymous_enable=' '{print $2}'`\n\t\t\t\t\t\tif [[ $vsftpdconf_anonymous_enable_value =~ yes ]]; then\n\t\t\t\t\t\t\techo \"※ U-20 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\t\techo \" ${vsftpdconf_settings_files[$i]} 파일에서 익명 ftp 접속을 허용하고 있습니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\t\treturn 0\n\t\t\t\t\t\tfi\n\t\t\t\t\tfi\n\t\t\t\tdone\n\t\t\t\tif [ $settings_in_vsftpdconf -eq 0 ]; then\n\t\t\t\t\techo \"※ U-20 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\techo \" vsftpd.conf 파일에 익명 ftp 접속을 설정하는 옵션이 없습니다.\" >> $resultfile 2>&1\n\t\t\t\t\treturn 0\n\t\t\t\tfi\n\t\t\tfi\n\t\t\tif [ $file_exists_count -eq 0 ]; then\n\t\t\t\techo \"※ U-20 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\techo \" 익명 ftp 접속을 설정하는 파일이 없습니다.\" >> $resultfile 2>&1\n\t\t\t\treturn 0\n\t\t\tfi\n\t\tfi\n\tfi\n\techo \"※ U-20 결과 : 양호(Good)\" >> $resultfile 2>&1\n\treturn 0\n}\n\nU_21() {\n\techo \"\"  >> $resultfile 2>&1\n\techo \"▶ U-21(상) | 3. 서비스 관리 > 3.3 r 계열 서비스 비활성화 ◀\"  >> $resultfile 2>&1\n\techo \" 양호 판단 기준 : 불필요한 r 계열 서비스가 비활성화 되어 있는 경우\" >> $resultfile 2>&1\n\tr_command=(\"rsh\" \"rlogin\" \"rexec\" \"shell\" \"login\" \"exec\")\n\tif [ -d /etc/xinetd.d ]; then\n\t\tfor ((i=0; i<${#r_command[@]}; i++))\n\t\tdo\n\t\t\tif [ -f /etc/xinetd.d/${r_command[$i]} ]; then\n\t\t\t\tetc_xinetdd_rcommand_disable_count=`grep -vE '^#|^\\s#' /etc/xinetd.d/${r_command[$i]} | grep -i 'disable' | grep -i 'yes' | wc -l`\n\t\t\t\tif [ $etc_xinetdd_rcommand_disable_count -eq 0 ]; then\n\t\t\t\t\techo \"※ U-21 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\techo \" 불필요한 ${r_command[$i]} 서비스가 실행 중입니다.\" >> $resultfile 2>&1\n\t\t\t\t\treturn 0\n\t\t\t\tfi\n\t\t\tfi\n\t\tdone\n\tfi\n\tif [ -f /etc/inetd.conf ]; then\n\t\tfor ((i=0; i<${#r_command[@]}; i++))\n\t\tdo\n\t\t\tetc_inetdconf_rcommand_enable_count=`grep -vE '^#|^\\s#' /etc/inetd.conf | grep ${r_command[$i]} | wc -l`\n\t\t\tif [ $etc_inetdconf_rcommand_enable_count -gt 0 ]; then\n\t\t\t\techo \"※ U-21 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\techo \" 불필요한 ${r_command[$i]} 서비스가 실행 중입니다.\" >> $resultfile 2>&1\n\t\t\t\treturn 0\n\t\t\tfi\n\t\tdone\n\tfi\n\techo \"※ U-21 결과 : 양호(Good)\" >> $resultfile 2>&1\n\treturn 0\n}\n\nU_22() {\n\techo \"\"  >> $resultfile 2>&1\n\techo \"▶ U-22(상) | 3. 서비스 관리 > 3.4 crond 파일 소유자 및 권한 설정 ◀\"  >> $resultfile 2>&1\n\techo \" 양호 판단 기준 : crontab 명령어 일반사용자 금지 및 cron 관련 파일 640 이하인 경우\" >> $resultfile 2>&1\n\tcrontab_path=(\"/usr/bin/crontab\" \"/usr/sbin/crontab\" \"/bin/crontab\")\n\tif [ `which crontab 2>/dev/null | wc -l` -gt 0 ]; then\n\t\tcrontab_path[${#crontab_path[@]}]=`which crontab 2>/dev/null`\n\tfi\n\tfor ((i=0; i<${#crontab_path[@]}; i++))\n\tdo\n\t\tif [ -f ${crontab_path[$i]} ]; then\n\t\t\tcrontab_permission=`stat ${crontab_path[$i]} | grep -i 'Uid' | awk '{print $2}' | awk -F / '{print substr($1,4,2)}'` # group, owner 권한만 추출함\n\t\t\tif [ $crontab_permission -le 50 ]; then\n\t\t\t\tcrontab_group_permission=`stat ${crontab_path[$i]} | grep -i 'Uid' | awk '{print $2}' | awk -F / '{print substr($1,4,1)}'`\n\t\t\t\tif [ $crontab_group_permission -eq 5 ] || [ $crontab_group_permission -eq 4 ] || [ $crontab_group_permission -eq 1 ] || [ $crontab_group_permission -eq 0 ]; then\n\t\t\t\t\tcrontab_other_permission=`stat ${crontab_path[$i]} | grep -i 'Uid' | awk '{print $2}' | awk -F / '{print substr($1,5,1)}'`\n\t\t\t\t\tif [ $crontab_other_permission -ne 0 ]; then\n\t\t\t\t\t\techo \"※ U-22 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\techo \" ${crontab_path[$i]} 명령어의 다른 사용자(other)에 대한 권한이 취약합니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\treturn 0\n\t\t\t\t\tfi\n\t\t\t\telse\n\t\t\t\t\techo \"※ U-22 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\techo \" ${crontab_path[$i]} 명령어의 그룹 사용자(group)에 대한 권한이 취약합니다.\" >> $resultfile 2>&1\n\t\t\t\t\treturn 0\n\t\t\t\tfi\n\t\t\telse\n\t\t\t\techo \"※ U-22 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\techo \" ${crontab_path[$i]} 명령어의 권한이 750보다 큽니다.\" >> $resultfile 2>&1\n\t\t\t\treturn 0\n\t\t\tfi\n\t\tfi\n\tdone\n\tcron_directory=(\"/etc/cron.hourly\" \"/etc/cron.daily\" \"/etc/cron.weekly\" \"/etc/cron.monthly\" \"/var/spool/cron\" \"/var/spool/cron/crontabs\")\n\tcron_file=(\"/etc/crontab\" \"/etc/cron.allow\" \"/etc/cron.deny\")\n\tfor ((i=0; i<${#cron_directory[@]}; i++))\n\tdo\n\t\tcron_file_count=`find ${cron_directory[$i]} -type f 2>/dev/null | wc -l`\n\t\tif [ $cron_file_count -gt 0 ]; then\n\t\t\tcron_file2=(`find ${cron_directory[$i]} -type f 2>/dev/null`)\n\t\t\tfor ((j=0; j<${#cron_file2[@]}; j++))\n\t\t\tdo\n\t\t\t\tcron_file[${#cron_file[@]}]=${cron_file2[$j]}\n\t\t\tdone\n\t\tfi\n\tdone\n\tfor ((i=0; i<${#cron_file[@]}; i++))\n\tdo\n\t\tif [ -f ${cron_file[$i]} ]; then\n\t\t\tcron_file_owner_name=`ls -l ${cron_file[$i]} | awk '{print $3}'`\n\t\t\tif [[ $cron_file_owner_name =~ root ]]; then\n\t\t\t\tcron_file_permission=`stat ${cron_file[$i]}| grep -i 'Uid' | awk '{print $2}' | awk -F / '{print substr($1,3,3)}'`\n\t\t\t\tif [ $cron_file_permission -le 640 ]; then\n\t\t\t\t\tcron_file_owner_permission=`stat ${cron_file[$i]} | grep -i 'Uid' | awk '{print $2}' | awk -F / '{print substr($1,3,1)}'`\n\t\t\t\t\tif [ $cron_file_owner_permission -eq 6 ] || [ $cron_file_owner_permission -eq 4 ] || [ $cron_file_owner_permission -eq 2 ] || [ $cron_file_owner_permission -eq 0 ]; then\n\t\t\t\t\t\tcron_file_group_permission=`stat ${cron_file[$i]} | grep -i 'Uid' | awk '{print $2}' | awk -F / '{print substr($1,4,1)}'`\n\t\t\t\t\t\tif [ $cron_file_group_permission -eq 4 ] || [ $cron_file_group_permission -eq 0 ]; then\n\t\t\t\t\t\t\tcron_file_other_permission=`stat ${cron_file[$i]} | grep -i 'Uid' | awk '{print $2}' | awk -F / '{print substr($1,5,1)}'`\n\t\t\t\t\t\t\tif [ $cron_file_other_permission -ne 0 ]; then\n\t\t\t\t\t\t\t\techo \"※ U-22 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\t\t\techo \" ${cron_file[$i]} 파일의 다른 사용자(other)에 대한 권한이 취약합니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\t\t\treturn 0\n\t\t\t\t\t\t\tfi\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\techo \"※ U-22 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\t\techo \" ${cron_file[$i]} 파일의 그룹 사용자(group)에 대한 권한이 취약합니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\t\treturn 0\n\t\t\t\t\t\tfi\n\t\t\t\t\telse\n\t\t\t\t\t\techo \"※ U-22 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\techo \" ${cron_file[$i]} 파일의 사용자(owner)에 대한 권한이 취약합니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\treturn 0\n\t\t\t\t\tfi\n\t\t\t\telse\n\t\t\t\t\techo \"※ U-22 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\techo \" ${cron_file[$i]} 파일의 권한이 640보다 큽니다.\" >> $resultfile 2>&1\n\t\t\t\t\treturn 0\n\t\t\t\tfi\n\t\t\telse\n\t\t\t\techo \"※ U-22 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\techo \" ${cron_file[$i]} 파일의 소유자(owner)가 root가 아닙니다.\" >> $resultfile 2>&1\n\t\t\t\treturn 0\n\t\t\tfi\n\t\tfi\n\tdone\n\techo \"※ U-22 결과 : 양호(Good)\" >> $resultfile 2>&1\n\treturn 0\n}\n\nU_23() {\n\techo \"\"  >> $resultfile 2>&1\n\techo \"▶ U-23(상) | 3. 서비스 관리 > 3.5 DoS 공격에 취약한 서비스 비활성화 ◀\"  >> $resultfile 2>&1\n\techo \" 양호 판단 기준 : 사용하지 않는 DoS 공격에 취약한 서비스가 비활성화된 경우\" >> $resultfile 2>&1\n\tservices=(\"echo\" \"discard\" \"daytime\" \"chargen\")\n\tif [ -d /etc/xinetd.d ]; then\n\t\tfor ((i=0; i<${#services[@]}; i++))\n\t\tdo\n\t\t\tif [ -f /etc/xinetd.d/${services[$i]} ]; then\n\t\t\t\tetc_xinetdd_service_disable_count=`grep -vE '^#|^\\s#' /etc/xinetd.d/${services[$i]} | grep -i 'disable' | grep -i 'yes' | wc -l`\n\t\t\t\tif [ $etc_xinetdd_service_disable_count -eq 0 ]; then\n\t\t\t\t\techo \"※ U-23 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\techo \" ${services[$i]} 서비스가 /etc/xinetd.d 디렉터리 내 서비스 파일에서 실행 중입니다.\" >> $resultfile 2>&1\n\t\t\t\t\treturn 0\n\t\t\t\tfi\n\t\t\tfi\n\t\tdone\n\tfi\n\tif [ -f /etc/inetd.conf ]; then\n\t\tfor ((i=0; i<${#services[@]}; i++))\n\t\tdo\n\t\t\tetc_inetdconf_service_enable_count=`grep -vE '^#|^\\s#' /etc/inetd.conf | grep  ${services[$i]} | wc -l`\n\t\t\tif [ $etc_inetdconf_service_enable_count -gt 0 ]; then\n\t\t\t\techo \"※ U-23 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\techo \" ${services[$i]} 서비스가 /etc/inetd.conf 파일에서 실행 중입니다.\" >> $resultfile 2>&1\n\t\t\t\treturn 0\n\t\t\tfi\n\t\tdone\n\tfi\n\techo \"※ U-23 결과 : 양호(Good)\" >> $resultfile 2>&1\n\treturn 0\n}\n\nU_24() {\n\techo \"\"  >> $resultfile 2>&1\n\techo \"▶ U-24(상) | 3. 서비스 관리 > 3.6 NFS 서비스 비활성화 ◀\"  >> $resultfile 2>&1\n\techo \" 양호 판단 기준 : 불필요한 NFS 서비스 관련 데몬이 비활성화 되어 있는 경우\" >> $resultfile 2>&1\n\tif [ `ps -ef | grep -iE 'nfs|rpc.statd|statd|rpc.lockd|lockd' | grep -ivE 'grep|kblockd|rstatd|' | wc -l` -gt 0 ]; then\n\t\techo \"※ U-24 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\techo \" 불필요한 NFS 서비스 관련 데몬이 실행 중입니다.\" >> $resultfile 2>&1\n\t\treturn 0\n\telse\n\t\techo \"※ U-24 결과 : 양호(Good)\" >> $resultfile 2>&1\n\t\treturn 0\n\tfi\n}\n\nU_25() {\n\techo \"\"  >> $resultfile 2>&1\n\techo \"▶ U-25(상) | 3. 서비스 관리 > 3.7 NFS 접근 통제 ◀\"  >> $resultfile 2>&1\n\techo \" 양호 판단 기준 : 불필요한 NFS 서비스를 사용하지 않거나, 불가피하게 사용 시 everyone 공유를 제한한 경우\" >> $resultfile 2>&1\n\tif [ `ps -ef | grep -iE 'nfs|rpc.statd|statd|rpc.lockd|lockd' | grep -ivE 'grep|kblockd|rstatd|' | wc -l` -gt 0 ]; then\n\t\tif [ -f /etc/exports ]; then\n\t\t\tetc_exports_all_count=`grep -vE '^#|^\\s#' /etc/exports | grep '/' | grep '*' | wc -l`\n\t\t\tetc_exports_insecure_count=`grep -vE '^#|^\\s#' /etc/exports | grep '/' | grep -i 'insecure' | wc -l`\n\t\t\tetc_exports_directory_count=`grep -vE '^#|^\\s#' /etc/exports | grep '/' | wc -l`\n\t\t\tetc_exports_squash_count=`grep -vE '^#|^\\s#' /etc/exports | grep '/' | grep -iE 'root_squash|all_squash' | wc -l`\n\t\t\tif [ $etc_exports_all_count -gt 0 ]; then\n\t\t\t\techo \"※ U-25 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\techo \" /etc/exports 파일에 '*' 설정이 있습니다.\" >> $resultfile 2>&1\n\t\t\t\techo \" ### '*' 설정 = 모든 클라이언트에 대해 전체 네트워크 공유 허용\" >> $resultfile 2>&1\n\t\t\t\treturn 0\n\t\t\telif [ $etc_exports_insecure_count -gt 0 ]; then\n\t\t\t\techo \"※ U-25 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\techo \" /etc/exports 파일에 'insecure' 옵션이 설정되어 있습니다.\" >> $resultfile 2>&1\n\t\t\t\treturn 0\n\t\t\telse\n\t\t\t\tif [ $etc_exports_directory_count -ne $etc_exports_squash_count ]; then\n\t\t\t\t\techo \"※ U-25 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\techo \" /etc/exports 파일에 'root_squash' 또는 'all_squash' 옵션이 설정되어 있지 않습니다.\" >> $resultfile 2>&1\n\t\t\t\t\treturn 0\n\t\t\t\tfi\n\t\t\tfi\n\t\tfi\n\telse\n\t\techo \"※ U-25 결과 : 양호(Good)\" >> $resultfile 2>&1\n\t\treturn 0\n\tfi\n}\n\nU_26() {\n\techo \"\"  >> $resultfile 2>&1\n\techo \"▶ U-26(상) | 3. 서비스 관리 > 3.8 automountd 제거 ◀\"  >> $resultfile 2>&1\n\techo \" 양호 판단 기준 : automountd 서비스가 비활성화 되어 있는 경우\" >> $resultfile 2>&1\n\tif [ `ps -ef | grep -iE 'automount|autofs' | grep -v 'grep' | wc -l` -gt 0 ]; then\n\t\techo \"※ U-26 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\techo \" automountd 서비스가 실행 중입니다.\" >> $resultfile 2>&1\n\t\treturn 0\n\telse\n\t\techo \"※ U-26 결과 : 양호(Good)\" >> $resultfile 2>&1\n\t\treturn 0\n\tfi\n}\n\nU_27() {\n\techo \"\"  >> $resultfile 2>&1\n\techo \"▶ U-27(상) | 3. 서비스 관리 > 3.9 RPC 서비스 확인 ◀\"  >> $resultfile 2>&1\n\techo \" 양호 판단 기준 : 불필요한 RPC 서비스가 비활성화 되어 있는 경우\" >> $resultfile 2>&1\n\trpc_services=(\"rpc.cmsd\" \"rpc.ttdbserverd\" \"sadmind\" \"rusersd\" \"walld\" \"sprayd\" \"rstatd\" \"rpc.nisd\" \"rexd\" \"rpc.pcnfsd\" \"rpc.statd\" \"rpc.ypupdated\" \"rpc.rquotad\" \"kcms_server\" \"cachefsd\")\n\tif [ -d /etc/xinetd.d ]; then\n\t\tfor ((i=0; i<${#rpc_services[@]}; i++))\n\t\tdo\n\t\t\tif [ -f /etc/xinetd.d/${rpc_services[$i]} ]; then\n\t\t\t\tetc_xinetdd_rpcservice_disable_count=`grep -vE '^#|^\\s#' /etc/xinetd.d/${rpc_services[$i]} | grep -i 'disable' | grep -i 'yes' | wc -l`\n\t\t\t\tif [ $etc_xinetdd_rpcservice_disable_count -eq 0 ]; then\n\t\t\t\t\techo \"※ U-27 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\techo \" 불필요한 RPC 서비스가 /etc/xinetd.d 디렉터리 내 서비스 파일에서 실행 중입니다.\" >> $resultfile 2>&1\n\t\t\t\t\treturn 0\n\t\t\t\tfi\n\t\t\tfi\n\t\tdone\n\tfi\n\tif [ -f /etc/inetd.conf ]; then\n\t\tfor ((i=0; i<${#rpc_services[@]}; i++))\n\t\tdo\n\t\t\tetc_inetdconf_rpcservice_enable_count=`grep -vE '^#|^\\s#' /etc/inetd.conf | grep -w ${rpc_services[$i]} | wc -l`\n\t\t\tif [ $etc_inetdconf_rpcservice_enable_count -gt 0 ]; then\n\t\t\t\techo \"※ U-27 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\techo \" 불필요한 RPC 서비스가 /etc/inetd.conf 파일에서 실행 중입니다.\" >> $resultfile 2>&1\n\t\t\t\treturn 0\n\t\t\tfi\n\t\tdone\n\tfi\n\techo \"※ U-27 결과 : 양호(Good)\" >> $resultfile 2>&1\n\treturn 0\n}\n\nU_28() {\n\techo \"\"  >> $resultfile 2>&1\n\techo \"▶ U-28(상) | 3. 서비스 관리 > 3.10 NIS, NIS+ 점검 ◀\"  >> $resultfile 2>&1\n\techo \" 양호 판단 기준 : NIS 서비스가 비활성화 되어 있거나, 필요 시 NIS+를 사용하는 경우\" >> $resultfile 2>&1\n\tif [ `ps -ef | grep -iE 'ypserv|ypbind|ypxfrd|rpc.yppasswdd|rpc.ypupdated' | grep -v 'grep' | wc -l` -gt 0 ]; then\n\t\techo \"※ U-28 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\techo \" NIS 서비스가 실행 중입니다.\" >> $resultfile 2>&1\n\t\treturn 0\n\telse\n\t\techo \"※ U-28 결과 : 양호(Good)\" >> $resultfile 2>&1\n\t\treturn 0\n\tfi\n}\n\nU_29() {\n\techo \"\"  >> $resultfile 2>&1\n\techo \"▶ U-29(상) | 3. 서비스 관리 > 3.11 tftp, talk 서비스 비활성화 ◀\"  >> $resultfile 2>&1\n\techo \" 양호 판단 기준 : tftp, talk, ntalk 서비스가 비활성화 되어 있는 경우\" >> $resultfile 2>&1\n\tservices=(\"tftp\" \"talk\" \"ntalk\")\n\tif [ -d /etc/xinetd.d ]; then\n\t\tfor ((i=0; i<${#services[@]}; i++))\n\t\tdo\n\t\t\tif [ -f /etc/xinetd.d/${services[$i]} ]; then\n\t\t\t\tetc_xinetdd_service_disable_count=`grep -vE '^#|^\\s#' /etc/xinetd.d/${services[$i]} | grep -i 'disable' | grep -i 'yes' | wc -l`\n\t\t\t\tif [ $etc_xinetdd_service_disable_count -eq 0 ]; then\n\t\t\t\t\techo \"※ U-29 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\techo \" ${services[$i]} 서비스가 /etc/xinetd.d 디렉터리 내 서비스 파일에서 실행 중입니다.\" >> $resultfile 2>&1\n\t\t\t\t\treturn 0\n\t\t\t\tfi\n\t\t\tfi\n\t\tdone\n\tfi\n\tif [ -f /etc/inetd.conf ]; then\n\t\tfor ((i=0; i<${#services[@]}; i++))\n\t\tdo\n\t\t\tetc_inetdconf_service_enable_count=`grep -vE '^#|^\\s#' /etc/inetd.conf | grep ${services[$i]} | wc -l`\n\t\t\tif [ $etc_inetdconf_service_enable_count -gt 0 ]; then\n\t\t\t\techo \"※ U-29 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\techo \" ${services[$i]} 서비스가 /etc/inetd.conf 파일에서 실행 중입니다.\" >> $resultfile 2>&1\n\t\t\t\treturn 0\n\t\t\tfi\n\t\tdone\n\tfi\n\techo \"※ U-29 결과 : 양호(Good)\" >> $resultfile 2>&1\n\treturn 0\n}\n\nU_30() {\n\techo \"\"  >> $resultfile 2>&1\n\techo \"▶ U-30(상) | 3. 서비스 관리 > 3.12 Sendmail 버전 점검 ◀\"  >> $resultfile 2>&1\n\techo \" 양호 판단 기준 : Sendmail 버전이 최신버전인 경우\" >> $resultfile 2>&1\n\tif [ -f /etc/services ]; then\n\t\tsmtp_port_count=`grep -vE '^#|^\\s#' /etc/services | awk 'tolower($1)==\"smtp\" {print $2}' | awk -F / 'tolower($2)==\"tcp\" {print $1}' | wc -l`\n\t\tif [ $smtp_port_count -gt 0 ]; then\n\t\t\tsmtp_port=(`grep -vE '^#|^\\s#' /etc/services | awk 'tolower($1)==\"smtp\" {print $2}' | awk -F / 'tolower($2)==\"tcp\" {print $1}'`)\n\t\t\tfor ((i=0; i<${#smtp_port[@]}; i++))\n\t\t\tdo\n\t\t\t\tnetstat_smtp_count=`netstat -nat 2>/dev/null | grep -w 'tcp' | grep -Ei 'listen|established|syn_sent|syn_received' | grep \":${smtp_port[$i]} \" | wc -l`\n\t\t\t\tif [ $netstat_smtp_count -gt 0 ]; then\n\t\t\t\t\tdpkg_sendmail_version=`dpkg -s sendmail 2>/dev/null | grep -i 'version' | awk '{print $2}' | cut -d : -f 2`\n\t\t\t\t\tif [[ $dpkg_sendmail_version != 8.17.1* ]]; then\n\t\t\t\t\t\techo \"※ U-30 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\techo \" sendmail 버전이 최신 버전(8.17.1)이 아닙니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\treturn 0\n\t\t\t\t\tfi\n\t\t\t\tfi\n\t\t\tdone\n\t\tfi\n\tfi\n\tps_smtp_count=`ps -ef | grep -iE 'smtp|sendmail' | grep -v 'grep' | wc -l`\n\tif [ $ps_smtp_count -gt 0 ]; then\n\t\tdpkg_sendmail_version=`dpkg -s sendmail 2>/dev/null | grep -i 'version' | awk '{print $2}' | cut -d : -f 2`\n\t\tif [[ $dpkg_sendmail_version != 8.17.1* ]]; then\n\t\t\techo \"※ U-30 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\techo \" sendmail 버전이 최신 버전(8.17.1)이 아닙니다.\" >> $resultfile 2>&1\n\t\t\treturn 0\n\t\tfi\n\tfi\n\techo \"※ U-30 결과 : 양호(Good)\" >> $resultfile 2>&1\n\treturn 0\n}\n\nU_31() {\n\techo \"\"  >> $resultfile 2>&1\n\techo \"▶ U-31(상) | 3. 서비스 관리 > 3.13 스팸 메일 릴레이 제한 ◀\"  >> $resultfile 2>&1\n\techo \" 양호 판단 기준 : SMTP 서비스를 사용하지 않거나 릴레이 제한이 설정되어 있는 경우\" >> $resultfile 2>&1\n\tif [ -f /etc/services ]; then\n\t\tsmtp_port_count=`grep -vE '^#|^\\s#' /etc/services | awk 'tolower($1)==\"smtp\" {print $2}' | awk -F / 'tolower($2)==\"tcp\" {print $1}' | wc -l`\n\t\tif [ $smtp_port_count -gt 0 ]; then\n\t\t\tsmtp_port=(`grep -vE '^#|^\\s#' /etc/services | awk 'tolower($1)==\"smtp\" {print $2}' | awk -F / 'tolower($2)==\"tcp\" {print $1}'`)\n\t\t\tfor ((i=0; i<${#smtp_port[@]}; i++))\n\t\t\tdo\n\t\t\t\tnetstat_smtp_count=`netstat -nat 2>/dev/null | grep -w 'tcp' | grep -Ei 'listen|established|syn_sent|syn_received' | grep \":${smtp_port[$i]} \" | wc -l`\n\t\t\t\tif [ $netstat_smtp_count -gt 0 ]; then\n\t\t\t\t\tsendmailcf_exists_count=`find / -name 'sendmail.cf' -type f 2>/dev/null | wc -l`\n\t\t\t\t\tif [ $sendmailcf_exists_count -gt 0 ]; then\n\t\t\t\t\t\tsendmailcf_files=(`find / -name 'sendmail.cf' -type f 2>/dev/null`)\n\t\t\t\t\t\tif [ ${#sendmailcf_files[@]} -gt 0 ]; then\n\t\t\t\t\t\t\tfor ((j=0; j<${#sendmailcf_files[@]}; j++))\n\t\t\t\t\t\t\tdo\n\t\t\t\t\t\t\t\tsendmailcf_relaying_denied_count=`grep -vE '^#|^\\s#' ${sendmailcf_files[$j]} | grep -i 'R$\\*' | grep -i 'Relaying denied' | wc -l`\n\t\t\t\t\t\t\t\tif [ $sendmailcf_relaying_denied_count -eq 0 ]; then\n\t\t\t\t\t\t\t\t\techo \"※ U-31 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\t\t\t\techo \" ${sendmailcf_files[$j]} 파일에 릴레이 제한이 설정되어 있지 않습니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\t\t\t\treturn 0\n\t\t\t\t\t\t\t\tfi\n\t\t\t\t\t\t\tdone\n\t\t\t\t\t\tfi\n\t\t\t\t\tfi\n\t\t\t\tfi\n\t\t\tdone\n\t\tfi\n\tfi\n\tps_smtp_count=`ps -ef | grep -iE 'smtp|sendmail' | grep -v 'grep' | wc -l`\n\tif [ $ps_smtp_count -gt 0 ]; then\n\t\tsendmailcf_exists_count=`find / -name 'sendmail.cf' -type f 2>/dev/null | wc -l`\n\t\tif [ $sendmailcf_exists_count -gt 0 ]; then\n\t\t\tsendmailcf_files=(`find / -name 'sendmail.cf' -type f 2>/dev/null`)\n\t\t\tif [ ${#sendmailcf_files[@]} -gt 0 ]; then\n\t\t\t\tfor ((i=0; i<${#sendmailcf_files[@]}; i++))\n\t\t\t\tdo\n\t\t\t\t\tsendmailcf_relaying_denied_count=`grep -vE '^#|^\\s#' ${sendmailcf_files[$i]} | grep -i 'R$\\*' | grep -i 'Relaying denied' | wc -l`\n\t\t\t\t\tif [ $sendmailcf_relaying_denied_count -eq 0 ]; then\n\t\t\t\t\t\techo \"※ U-31 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\techo \" ${sendmailcf_files[$i]} 파일에 릴레이 제한이 설정되어 있지 않습니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\treturn 0\n\t\t\t\t\tfi\n\t\t\t\tdone\n\t\t\tfi\n\t\tfi\n\tfi\n\techo \"※ U-31 결과 : 양호(Good)\" >> $resultfile 2>&1\n\treturn 0\n}\n\nU_32() {\n\techo \"\"  >> $resultfile 2>&1\n\techo \"▶ U-32(상) | 3. 서비스 관리 > 3.14 일반사용자의 Sendmail 실행 방지 ◀\"  >> $resultfile 2>&1\n\techo \" 양호 판단 기준 : SMTP 서비스 미사용 또는, 일반 사용자의 Sendmail 실행 방지가 설정된 경우\" >> $resultfile 2>&1\n\tif [ -f /etc/services ]; then\n\t\tsmtp_port_count=`grep -vE '^#|^\\s#' /etc/services | awk 'tolower($1)==\"smtp\" {print $2}' | awk -F / 'tolower($2)==\"tcp\" {print $1}' | wc -l`\n\t\tif [ $smtp_port_count -gt 0 ]; then\n\t\t\tsmtp_port=(`grep -vE '^#|^\\s#' /etc/services | awk 'tolower($1)==\"smtp\" {print $2}' | awk -F / 'tolower($2)==\"tcp\" {print $1}'`)\n\t\t\tfor ((i=0; i<${#smtp_port[@]}; i++))\n\t\t\tdo\n\t\t\t\tnetstat_smtp_count=`netstat -nat 2>/dev/null | grep -w 'tcp' | grep -Ei 'listen|established|syn_sent|syn_received' | grep \":${smtp_port[$i]} \" | wc -l`\n\t\t\t\tif [ $netstat_smtp_count -gt 0 ]; then\n\t\t\t\t\tsendmailcf_exists_count=`find / -name 'sendmail.cf' -type f 2>/dev/null | wc -l`\n\t\t\t\t\tif [ $sendmailcf_exists_count -gt 0 ]; then\n\t\t\t\t\t\tsendmailcf_files=(`find / -name 'sendmail.cf' -type f 2>/dev/null`)\n\t\t\t\t\t\tfor ((j=0; j<${#sendmailcf_files[@]}; j++))\n\t\t\t\t\t\tdo\n\t\t\t\t\t\t\tsendmailcf_file_restrictqrun_count=`grep -vE '^#|^\\s#' ${sendmailcf_files[$j]} | awk '{gsub(\" \", \"\", $0); print tolower($0)}' | awk -F 'privacyoptions=' '{print $2}' | grep 'restrictqrun' | wc -l`\n\t\t\t\t\t\t\tif [ $sendmailcf_file_restrictqrun_count -eq 0 ]; then\n\t\t\t\t\t\t\t\techo \"※ U-32 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\t\t\techo \" ${sendmailcf_files[$j]} 파일에 restrictqrun 옵션이 설정되어 있지 않습니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\t\t\treturn 0\n\t\t\t\t\t\t\tfi\n\t\t\t\t\t\tdone\n\t\t\t\t\telse\n\t\t\t\t\t\techo \"※ U-32 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\techo \" sendmail.cf 파일이 없습니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\treturn 0\n\t\t\t\t\tfi\n\t\t\t\tfi\n\t\t\tdone\n\t\tfi\n\tfi\n\tps_smtp_count=`ps -ef | grep -iE 'smtp|sendmail' | grep -v 'grep' | wc -l`\n\tif [ $ps_smtp_count -gt 0 ]; then\n\t\tsendmailcf_exists_count=`find / -name 'sendmail.cf' -type f 2>/dev/null | wc -l`\n\t\tif [ $sendmailcf_exists_count -gt 0 ]; then\n\t\t\tsendmailcf_files=(`find / -name 'sendmail.cf' -type f 2>/dev/null`)\n\t\t\tfor ((i=0; i<${#sendmailcf_files[@]}; i++))\n\t\t\tdo\n\t\t\t\tsendmailcf_file_restrictqrun_count=`grep -vE '^#|^\\s#' ${sendmailcf_files[$i]} | awk '{gsub(\" \", \"\", $0); print tolower($0)}' | awk -F 'privacyoptions=' '{print $2}' | grep 'restrictqrun' | wc -l`\n\t\t\t\tif [ $sendmailcf_file_restrictqrun_count -eq 0 ]; then\n\t\t\t\t\techo \"※ U-32 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\techo \" ${sendmailcf_files[$i]} 파일에 restrictqrun 옵션이 설정되어 있지 않습니다.\" >> $resultfile 2>&1\n\t\t\t\t\treturn 0\n\t\t\t\tfi\n\t\t\tdone\n\t\telse\n\t\t\techo \"※ U-32 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\techo \" sendmail.cf 파일이 없습니다.\" >> $resultfile 2>&1\n\t\t\treturn 0\n\t\tfi\n\tfi\n\techo \"※ U-32 결과 : 양호(Good)\" >> $resultfile 2>&1\n\treturn 0\n}\n\nU_33() {\n\techo \"\"  >> $resultfile 2>&1\n\techo \"▶ U-33(상) | 3. 서비스 관리 > 3.15 DNS 보안 버전 패치 ◀\"  >> $resultfile 2>&1\n\techo \" 양호 판단 기준 : DNS 서비스를 사용하지 않거나 주기적으로 패치를 관리하고 있는 경우\" >> $resultfile 2>&1\n\tps_dns_count=`ps -ef | grep -i 'named' | grep -v 'grep' | wc -l`\n\tif [ $ps_dns_count -gt 0 ]; then\n\t\tdpkg_bind9_major_minor_version=`dpkg -s bind9 2>/dev/null | grep -i 'version' | awk '{print $2}' | cut -d : -f 2`\n\t\tif [[ $dpkg_bind9_major_minor_version != 9.18.* ]]; then\n\t\t\techo \"※ U-33 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\techo \" BIND 버전이 최신 버전(9.18.7 이상)이 아닙니다.\" >> $resultfile 2>&1\n\t\t\treturn 0\n\t\telse\n\t\t\tdpkg_bind9_patch_version=`dpkg -s bind9 2>/dev/null | grep -i 'version' | awk '{print $2}' | cut -d : -f 2 | awk -F . '{print $3}'`\n\t\t\tif [[ $dpkg_bind9_patch_version != [7-9]* ]] || [[ $dpkg_bind9_patch_version != 1[0-6]* ]]; then\n\t\t\t\techo \"※ U-33 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\techo \" BIND 버전이 최신 버전(9.18.7 이상)이 아닙니다.\" >> $resultfile 2>&1\n\t\t\t\treturn 0\n\t\t\tfi\n\t\tfi\n\t\t\n\tfi\n\techo \"※ U-33 결과 : 양호(Good)\" >> $resultfile 2>&1\n\treturn 0\n}\n\nU_34() {\n\techo \"\"  >> $resultfile 2>&1\n\techo \"▶ U-34(상) | 3. 서비스 관리 > 3.16 DNS Zone Transfer 설정 ◀\"  >> $resultfile 2>&1\n\techo \" 양호 판단 기준 : DNS 서비스 미사용 또는, Zone Transfer를 허가된 사용자에게만 허용한 경우\" >> $resultfile 2>&1\n\tps_dns_count=`ps -ef | grep -i 'named' | grep -v 'grep' | wc -l`\n\tif [ $ps_dns_count -gt 0 ]; then\n\t\tif [ -f /etc/named.conf ]; then\n\t\t\tetc_namedconf_allowtransfer_count=`grep -vE '^#|^\\s#' /etc/named.conf | grep -i 'allow-transfer' | grep -i 'any' | wc -l`\n\t\t\tif [ $etc_namedconf_allowtransfer_count -gt 0 ]; then\n\t\t\t\techo \"※ U-34 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\techo \" /etc/named.conf 파일에 allow-transfer { any; } 설정이 있습니다.\" >> $resultfile 2>&1\n\t\t\t\treturn 0\n\t\t\tfi\n\t\tfi\n\tfi\n\techo \"※ U-34 결과 : 양호(Good)\" >> $resultfile 2>&1\n\treturn 0\n}\n\nU_35() {\n\techo \"\"  >> $resultfile 2>&1\n\techo \"▶ U-35(상) | 3. 서비스 관리 > 3.17 웹서비스 디렉토리 리스팅 제거 ◀\"  >> $resultfile 2>&1\n\techo \" 양호 판단 기준 : 디렉터리 검색 기능을 사용하지 않는 경우\" >> $resultfile 2>&1\n\twebconf_files=(\".htaccess\" \"httpd.conf\" \"apache2.conf\" \"userdir.conf\")\n\tfor ((i=0; i<${#webconf_files[@]}; i++))\n\tdo\n\t\tfind_webconf_file_count=`find / -name ${webconf_files[$i]} -type f 2>/dev/null | wc -l`\n\t\tif [ $find_webconf_file_count -gt 0 ]; then\n\t\t\tfind_webconf_files=(`find / -name ${webconf_files[$i]} -type f 2>/dev/null`)\n\t\t\tfor ((j=0; j<${#find_webconf_files[@]}; j++))\n\t\t\tdo\n\t\t\t\tif [[ ${find_webconf_files[$j]} =~ userdir.conf ]]; then\n\t\t\t\t\tuserdirconf_disabled_count=`grep -vE '^#|^\\s#'  ${find_webconf_files[$j]} | grep -i 'userdir' | grep -i 'disabled' | wc -l`\n\t\t\t\t\tif [ $userdirconf_disabled_count -eq 0 ]; then\n\t\t\t\t\t\tuserdirconf_indexes_count=`grep -vE '^#|^\\s#'  ${find_webconf_files[$j]} | grep -i 'Options' | grep -iv '\\-indexes' | grep -i 'indexes' | wc -l`\n\t\t\t\t\t\tif [ $userdirconf_indexes_count -gt 0 ]; then\n\t\t\t\t\t\t\techo \"※ U-35 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\t\techo \" Apache 설정 파일에 디렉터리 검색 기능을 사용하도록 설정되어 있습니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\t\treturn 0\n\t\t\t\t\t\tfi\n\t\t\t\t\tfi\n\t\t\t\telse\n\t\t\t\t\twebconf_file_indexes_count=`grep -vE '^#|^\\s#' ${find_webconf_files[$j]} | grep -i 'Options' | grep -iv '\\-indexes' | grep -i 'indexes' | wc -l`\n\t\t\t\t\tif [ $webconf_file_indexes_count -gt 0 ]; then\n\t\t\t\t\t\techo \"※ U-35 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\techo \" Apache 설정 파일에 디렉터리 검색 기능을 사용하도록 설정되어 있습니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\treturn 0\n\t\t\t\t\tfi\n\t\t\t\tfi\n\t\t\tdone\n\t\tfi\n\tdone\n\techo \"※ U-35 결과 : 양호(Good)\" >> $resultfile 2>&1\n\treturn 0\n}\n\nU_36() {\n\techo \"\"  >> $resultfile 2>&1\n\techo \"▶ U-36(상) | 3. 서비스 관리 > 3.18 웹서비스 웹 프로세스 권한 제한 ◀\"  >> $resultfile 2>&1\n\techo \" 양호 판단 기준 : Apache 데몬이 root 권한으로 구동되지 않는 경우\" >> $resultfile 2>&1\n\twebconf_files=(\".htaccess\" \"httpd.conf\" \"apache2.conf\")\n\tfor ((i=0; i<${#webconf_files[@]}; i++))\n\tdo\n\t\tfind_webconf_file_count=`find / -name ${webconf_files[$i]} -type f 2>/dev/null | wc -l`\n\t\tif [ $find_webconf_file_count -gt 0 ]; then\n\t\t\tfind_webconf_files=(`find / -name ${webconf_files[$i]} -type f 2>/dev/null`)\n\t\t\tfor ((j=0; j<${#find_webconf_files[@]}; j++))\n\t\t\tdo\n\t\t\t\twebconf_file_group_root_count=`grep -vE '^#|^\\s#' ${find_webconf_files[$j]} | grep -B 1 '^\\s*Group' | grep 'root' | wc -l`\n\t\t\t\tif [ $webconf_file_group_root_count -gt 0 ]; then\n\t\t\t\t\techo \"※ U-36 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\techo \" Apache 데몬이 root 권한으로 구동되도록 설정되어 있습니다.\" >> $resultfile 2>&1\n\t\t\t\t\treturn 0\n\t\t\t\telse\n\t\t\t\t\twebconf_file_group_count=`grep -vE '^#|^\\s#' ${find_webconf_files[$j]} | grep '^\\s*Group' | awk '{print $2}' | sed 's/{//' | sed 's/}//' | wc -l`\n\t\t\t\t\tif [ $webconf_file_group_count -gt 0 ]; then\n\t\t\t\t\t\twebconf_file_group=`grep -vE '^#|^\\s#' ${find_webconf_files[$j]} | grep '^\\s*Group' | awk '{print $2}' | sed 's/{//' | sed 's/}//'`\n\t\t\t\t\t\twebconf_file_group_root_count=`eval echo $webconf_file_group | grep 'root' | wc -l`\n\t\t\t\t\t\tif [ $webconf_file_group_root_count -gt 0 ]; then\n\t\t\t\t\t\t\techo \"※ U-36 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\t\techo \" Apache 데몬이 root 권한으로 구동되도록 설정되어 있습니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\t\treturn 0\n\t\t\t\t\t\tfi\n\t\t\t\t\tfi\n\t\t\t\tfi\n\t\t\tdone\n\t\tfi\n\tdone\n\techo \"※ U-36 결과 : 양호(Good)\" >> $resultfile 2>&1\n\treturn 0\n}\n\nU_37() {\n\techo \"\"  >> $resultfile 2>&1\n\techo \"▶ U-37(상) | 3. 서비스 관리 > 3.19 웹서비스 상위 디렉토리 접근 금지 ◀\"  >> $resultfile 2>&1\n\techo \" 양호 판단 기준 : 상위 디렉터리에 이동제한을 설정한 경우\" >> $resultfile 2>&1\n\twebconf_files=(\".htaccess\" \"httpd.conf\" \"apache2.conf\" \"userdir.conf\")\n\tfile_exists_count=0\n\tfor ((i=0; i<${#webconf_files[@]}; i++))\n\tdo\n\t\tfind_webconf_file_count=`find / -name ${webconf_files[$i]} -type f 2>/dev/null | wc -l`\n\t\tif [ $find_webconf_file_count -gt 0 ]; then\n\t\t\t((file_exists_count++))\n\t\t\tfind_webconf_files=(`find / -name ${webconf_files[$i]} -type f 2>/dev/null`)\n\t\t\tfor ((j=0; j<${#find_webconf_files[@]}; j++))\n\t\t\tdo\n\t\t\t\tif [[ ${find_webconf_files[$j]} =~ userdir.conf ]]; then\n\t\t\t\t\tuserdirconf_disabled_count=`grep -vE '^#|^\\s#' ${find_webconf_files[$j]} | grep -i 'userdir' | grep -i 'disabled' | wc -l`\n\t\t\t\t\tif [ $userdirconf_disabled_count -eq 0 ]; then\n\t\t\t\t\t\tuserdirconf_allowoverride_count=`grep -vE '^#|^\\s#' ${find_webconf_files[$j]} | grep -i 'AllowOverride' | wc -l`\n\t\t\t\t\t\tif [ $userdirconf_allowoverride_count -gt 0 ]; then\n\t\t\t\t\t\t\tuserdirconf_allowoverride_none_count=`grep -vE '^#|^\\s#' ${find_webconf_files[$j]} | grep -i 'AllowOverride' | grep -i 'None' | wc -l`\n\t\t\t\t\t\t\tif [ $userdirconf_allowoverride_none_count -gt 0 ]; then\n\t\t\t\t\t\t\t\techo \"※ U-37 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\t\t\techo \" 웹 서비스 상위 디렉터리에 이동 제한을 설정하지 않았습니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\t\t\treturn 0\n\t\t\t\t\t\t\tfi\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\techo \"※ U-37 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\t\techo \" 웹 서비스 상위 디렉터리에 이동 제한을 설정하지 않았습니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\t\treturn 0\n\t\t\t\t\t\tfi\n\t\t\t\t\tfi\n\t\t\t\telse\n\t\t\t\t\twebconf_file_allowoverride_count=`grep -vE '^#|^\\s#' ${find_webconf_files[$j]} | grep -i 'AllowOverride' | wc -l`\n\t\t\t\t\tif [ $webconf_file_allowoverride_count -gt 0 ]; then\n\t\t\t\t\t\twebconf_file_allowoverride_none_count=`grep -vE '^#|^\\s#' ${find_webconf_files[$j]} | grep -i 'AllowOverride' | grep -i 'None' | wc -l`\n\t\t\t\t\t\tif [ $webconf_file_allowoverride_none_count -gt 0 ]; then\n\t\t\t\t\t\t\techo \"※ U-37 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\t\techo \" 웹 서비스 상위 디렉터리에 이동 제한을 설정하지 않았습니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\t\treturn 0\n\t\t\t\t\t\tfi\n\t\t\t\t\telse\n\t\t\t\t\t\techo \"※ U-37 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\techo \" 웹 서비스 상위 디렉터리에 이동 제한을 설정하지 않았습니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\treturn 0\n\t\t\t\t\tfi\n\t\t\t\tfi\n\t\t\tdone\n\t\tfi\n\tdone\n\tps_apache_count=`ps -ef | grep -iE 'httpd|apache2' | grep -v 'grep' | wc -l`\n\tif [ $ps_apache_count -gt 0 ] && [ $file_exists_count -eq 0 ]; then\n\t\techo \"※ U-37 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\techo \" Apache 서비스를 사용하고, 웹 서비스 상위 디렉터리에 이동 제한을 설정하는 파일이 없습니다.\" >> $resultfile 2>&1\n\t\treturn 0\n\telse\n\t\techo \"※ U-37 결과 : 양호(Good)\" >> $resultfile 2>&1\n\t\treturn 0\n\tfi\n}\n\nU_38() {\n\techo \"\"  >> $resultfile 2>&1\n\techo \"▶ U-38(상) | 3. 서비스 관리 > 3.20 웹서비스 불필요한 파일 제거 ◀\"  >> $resultfile 2>&1\n\techo \" 양호 판단 기준 : 기본으로 생성되는 불필요한 파일 및 디렉터리가 제거되어 있는 경우\" >> $resultfile 2>&1\n\tserverroot_directory=()\n\twebconf_files=(\".htaccess\" \"httpd.conf\" \"apache2.conf\")\n\tfor ((i=0; i<${#webconf_files[@]}; i++))\n\tdo\n\t\tfind_webconf_file_count=`find / -name ${webconf_files[$i]} -type f 2>/dev/null | wc -l`\n\t\tif [ $find_webconf_file_count -gt 0 ]; then\n\t\t\tfind_webconf_files=(`find / -name ${webconf_files[$i]} -type f 2>/dev/null`)\n\t\t\tfor ((j=0; j<${#find_webconf_files[@]}; j++))\n\t\t\tdo\n\t\t\t\twebconf_serverroot_count=`grep -vE '^#|^\\s#' ${find_webconf_files[$j]} | grep 'ServerRoot' | grep '/' | wc -l`\n\t\t\t\tif [ $webconf_serverroot_count -gt 0 ]; then\n\t\t\t\t\tserverroot_directory[${#serverroot_directory[@]}]=`grep -vE '^#|^\\s#' ${find_webconf_files[$j]} | grep 'ServerRoot' | grep '/' | awk '{gsub(/\"/, \"\", $0); print $2}'`\n\t\t\t\tfi\n\t\t\tdone\n\t\tfi\n\tdone\n\tapache2_serverroot_count=`apache2 -V 2>/dev/ull | grep -i 'root' | awk -F '\"' '{gsub(\" \", \"\", $0); print $2}' | wc -l`\n\tif [ $apache2_serverroot_count -gt 0 ];then\n\t\tserverroot_directory[${#serverroot_directory[@]}]=`apache2 -V 2>/dev/ull | grep -i 'root' | awk -F '\"' '{gsub(\" \", \"\", $0); print $2}'`\n\tfi\n\thttpd_serverroot_count=`httpd -V 2>/dev/ull | grep -i 'root' | awk -F '\"' '{gsub(\" \", \"\", $0); print $2}' | wc -l`\n\tif [ $httpd_serverroot_count -gt 0 ]; then\n\t\tserverroot_directory[${#serverroot_directory[@]}]=`httpd -V 2>/dev/ull | grep -i 'root' | awk -F '\"' '{gsub(\" \", \"\", $0); print $2}'`\n\tfi\n\tfor ((i=0; i<${#serverroot_directory[@]}; i++))\n\tdo\n\t\tmanual_file_exists_count=`find ${serverroot_directory[$i]} -name 'manual' -type f 2>/dev/null | wc -l`\n\t\tif [ $manual_file_exists_count -gt 0 ]; then\n\t\t\techo \"※ U-38 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\techo \" Apache 홈 디렉터리 내 기본으로 생성되는 불필요한 파일 및 디렉터리가 제거되어 있지 않습니다.\" >> $resultfile 2>&1\n\t\t\treturn 0\n\t\tfi\n\tdone\n\techo \"※ U-38 결과 : 양호(Good)\" >> $resultfile 2>&1\n\treturn 0\n}\n\nU_39() {\n\techo \"\"  >> $resultfile 2>&1\n\techo \"▶ U-39(상) | 3. 서비스 관리 > 3.21 웹서비스 링크 사용금지 ◀\"  >> $resultfile 2>&1\n\techo \" 양호 판단 기준 : 심볼릭 링크, aliases 사용을 제한한 경우\" >> $resultfile 2>&1\n\twebconf_files=(\".htaccess\" \"httpd.conf\" \"apache2.conf\" \"userdir.conf\")\n\tfor ((i=0; i<${#webconf_files[@]}; i++))\n\tdo\n\t\tfind_webconf_file_count=`find / -name ${webconf_files[$i]} -type f 2>/dev/null | wc -l`\n\t\tif [ $find_webconf_file_count -gt 0 ]; then\n\t\t\tfind_webconf_files=(`find / -name ${webconf_files[$i]} -type f 2>/dev/null`)\n\t\t\tfor ((j=0; j<${#find_webconf_files[@]}; j++))\n\t\t\tdo\n\t\t\t\tif [[ ${find_webconf_files[$j]} =~ userdir.conf ]]; then\n\t\t\t\t\tuserdirconf_disabled_count=`grep -vE '^#|^\\s#' ${find_webconf_files[$j]} | grep -i 'userdir' | grep -i 'disabled' | wc -l`\n\t\t\t\t\tif [ $userdirconf_disabled_count -eq 0 ]; then\n\t\t\t\t\t\tuserdirconf_followsymlinks_count=`grep -vE '^#|^\\s#' ${find_webconf_files[$j]} | grep -i 'Options' | grep -iv '\\-FollowSymLinks' | grep -i 'FollowSymLinks' | wc -l`\n\t\t\t\t\t\tif [ $userdirconf_followsymlinks_count -gt 0 ]; then\n\t\t\t\t\t\t\techo \"※ U-39 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\t\techo \" Apache 설정 파일에 심볼릭 링크 사용을 제한하도록 설정하지 않습니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\t\treturn 0\n\t\t\t\t\t\tfi\n\t\t\t\t\tfi\n\t\t\t\telse\n\t\t\t\t\twebconf_file_followSymlinks_count=`grep -vE '^#|^\\s#' ${find_webconf_files[$j]} | grep -i 'Options' | grep -iv '\\-FollowSymLinks' | grep -i 'FollowSymLinks' | wc -l`\n\t\t\t\t\tif [ $webconf_file_followSymlinks_count -gt 0 ]; then\n\t\t\t\t\t\techo \"※ U-39 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\techo \" Apache 설정 파일에 심볼릭 링크 사용을 제한하도록 설정하지 않습니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\treturn 0\n\t\t\t\t\tfi\n\t\t\t\tfi\n\t\t\tdone\n\t\tfi\n\tdone\n\techo \"※ U-39 결과 : 양호(Good)\" >> $resultfile 2>&1\n\treturn 0\n}\n\nU_40() {\n\techo \"\"  >> $resultfile 2>&1\n\techo \"▶ U-40(상) | 3. 서비스 관리 > 3.22 웹서비스 파일 업로드 및 다운로드 제한 ◀\"  >> $resultfile 2>&1\n\techo \" 양호 판단 기준 : 파일 업로드 및 다운로드를 제한한 경우\" >> $resultfile 2>&1\n\twebconf_files=(\".htaccess\" \"httpd.conf\" \"apache2.conf\" \"userdir.conf\")\n\tfor ((i=0; i<${#webconf_files[@]}; i++))\n\tdo\n\t\tfind_webconf_file_count=`find / -name ${webconf_files[$i]} -type f 2>/dev/null | wc -l`\n\t\tif [ $find_webconf_file_count -gt 0 ]; then\n\t\t\tfind_webconf_files=(`find / -name ${webconf_files[$i]} -type f 2>/dev/null`)\n\t\t\tfor ((j=0; j<${#find_webconf_files[@]}; j++))\n\t\t\tdo\n\t\t\t\tif [[ ${find_webconf_files[$j]} =~ userdir.conf ]]; then\n\t\t\t\t\tuserdirconf_disabled_count=`grep -vE '^#|^\\s#' ${find_webconf_files[$j]} | grep -i 'userdir' | grep -i 'disabled' | wc -l`\n\t\t\t\t\tif [ $userdirconf_disabled_count -eq 0 ]; then\n\t\t\t\t\t\tuserdirconf_limitrequestbody_count=`grep -vE '^#|^\\s#' ${find_webconf_files[$j]} | grep -i 'LimitRequestBody' | wc -l`\n\t\t\t\t\t\tif [ $userdirconf_limitrequestbody_count -eq 0 ]; then\n\t\t\t\t\t\t\techo \"※ U-40 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\t\techo \" Apache 설정 파일에 파일 업로드 및 다운로드를 제한하도록 설정하지 않았습니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\t\treturn 0\n\t\t\t\t\t\tfi\n\t\t\t\t\tfi\n\t\t\t\telse\n\t\t\t\t\twebconf_limitrequestbody_count=`grep -vE '^#|^\\s#' ${find_webconf_files[$j]} | grep -i 'LimitRequestBody' | wc -l`\n\t\t\t\t\tif [ $webconf_limitrequestbody_count -eq 0 ]; then\n\t\t\t\t\t\techo \"※ U-40 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\techo \" Apache 설정 파일에 파일 업로드 및 다운로드를 제한하도록 설정하지 않았습니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\treturn 0\n\t\t\t\t\tfi\n\t\t\t\tfi\n\t\t\tdone\n\t\tfi\n\tdone\n\techo \"※ U-40 결과 : 양호(Good)\" >> $resultfile 2>&1\n\treturn 0\n}\n\nU_41() {\n\techo \"\"  >> $resultfile 2>&1\n\techo \"▶ U-41(상) | 3. 서비스 관리 > 3.23 웹서비스 영역의 분리 ◀\"  >> $resultfile 2>&1\n\techo \" 양호 판단 기준 : DocumentRoot를 별도의 디렉터리로 지정한 경우\" >> $resultfile 2>&1\n\twebconf_files=(\".htaccess\" \"httpd.conf\" \"apache2.conf\")\n\tfile_exists_count=0\n\tfor ((i=0; i<${#webconf_files[@]}; i++))\n\tdo\n\t\tfind_webconf_file_count=`find / -name ${webconf_files[$i]} -type f 2>/dev/null | wc -l`\n\t\tif [ $find_webconf_file_count -gt 0 ]; then\n\t\t\t((file_exists_count++))\n\t\t\tfind_webconf_files=(`find / -name ${webconf_files[$i]} -type f 2>/dev/null`)\n\t\t\tfor ((j=0; j<${#find_webconf_files[@]}; j++))\n\t\t\tdo\n\t\t\t\twebconf_file_documentroot_count=`grep -vE '^#|^\\s#' ${find_webconf_files[$j]} | grep -i 'DocumentRoot' | grep '/' | wc -l`\n\t\t\t\tif [ $webconf_file_documentroot_count -gt 0 ]; then\n\t\t\t\t\twebconf_file_documentroot_basic_count=`grep -vE '^#|^\\s#' ${find_webconf_files[$j]} | grep -i 'DocumentRoot' | grep '/' | awk '{gsub(/\"/, \"\", $0); print $2}' | grep -E '/usr/local/apache/htdocs|/usr/local/apache2/htdocs|/var/www/html' | wc -l`\n\t\t\t\t\tif [ $webconf_file_documentroot_basic_count -gt 0 ]; then \n\t\t\t\t\t\techo \"※ U-41 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\techo \" Apache DocumentRoot를 기본 디렉터리로 설정했습니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\treturn 0\n\t\t\t\t\tfi\n\t\t\t\telse\n\t\t\t\t\techo \"※ U-41 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\techo \" Apache DocumentRoot를 설정하지 않았습니다.\" >> $resultfile 2>&1\n\t\t\t\t\treturn 0\n\t\t\t\tfi\n\t\t\tdone\n\t\tfi\n\tdone\n\tps_apache_count=`ps -ef | grep -iE 'httpd|apache2' | grep -v 'grep' | wc -l`\n\tif [ $ps_apache_count -gt 0 ] && [ $file_exists_count -eq 0 ]; then\n\t\techo \"※ U-41 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\techo \" Apache 서비스를 사용하고, DocumentRoot를 설정하는 파일이 없습니다.\" >> $resultfile 2>&1\n\t\treturn 0\n\telse\n\t\techo \"※ U-41 결과 : 양호(Good)\" >> $resultfile 2>&1\n\t\treturn 0\n\tfi\n}\n\nU_42() {\n\techo \"\"  >> $resultfile 2>&1\n\techo \"▶ U-42(상) | 4 패치 관리 > 4.1 최신 보안패치 및 벤더 권고사항 적용 ◀\"  >> $resultfile 2>&1\n\techo \" 양호 판단 기준 : 패치 적용 정책을 수립하여 주기적으로 패치관리를 하고 있으며, 패치 \n관련 내용을 확인하고 적용했을 경우\" >> $resultfile 2>&1\n\techo \"※ U-42 결과 : N/A\" >> $resultfile 2>&1\n\techo \" 수동으로 점검하세요.\" >> $resultfile 2>&1\n}\n\nU_43() {\n\techo \"\"  >> $resultfile 2>&1\n\techo \"▶ U-43(상) | 5. 로그 관리 > 5.1 로그의 정기적 검토 및 보고 ◀\"  >> $resultfile 2>&1\n\techo \" 양호 판단 기준 : 접속기록 등의 보안 로그, 응용 프로그램 및 시스템 로그 기록에 대해 정기적으로 검토, 분석, 리포트 작성 및 보고 등의 조치가 이루어지는 경우\" >> $resultfile 2>&1\n\techo \"※ U-43 결과 : N/A\" >> $resultfile 2>&1\n\techo \" 수동으로 점검하세요.\" >> $resultfile 2>&1\n}\n\nU_44() {\n\techo \"\"  >> $resultfile 2>&1\n\techo \"▶ U-44(중) | 1. 계정관리 > 1.5 root 이외의 UID가 '0' 금지 ◀\"  >> $resultfile 2>&1\n\techo \" 양호 판단 기준 : root 계정과 동일한 UID를 갖는 계정이 존재하지 않는 경우\" >> $resultfile 2>&1\n\tif [ -f /etc/passwd ]; then\n\t\tif [ `awk -F : '$3==0 {print $1}' /etc/passwd | grep -vx 'root' | wc -l` -gt 0 ]; then\n\t\t\techo \"※ U-44 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\techo \" root 계정과 동일한 UID(0)를 갖는 계정이 존재합니다.\" >> $resultfile 2>&1\n\t\t\treturn 0\n\t\telse\n\t\t\techo \"※ U-44 결과 : 양호(Good)\" >> $resultfile 2>&1\n\t\t\treturn 0\n\t\tfi\n\tfi\n}\n\nU_45() {\n\techo \"\"  >> $resultfile 2>&1\n\techo \"▶ U-45(하) | 1. 계정관리 > 1.6 root 계정 su 제한 ◀\"  >> $resultfile 2>&1\n\techo \" 양호 판단 기준 : su 명령어를 특정 그룹에 속한 사용자만 사용하도록 제한되어 있는 경우\" >> $resultfile 2>&1\n\techo \" ### pam_rootok.so 모듈을 사용하지 않는 경우 U_45 함수 수정 필요\" >> $resultfile 2>&1\n\techo \" ### pam_rootok.so 모듈 사용과 함께 trust 문구를 추가한 경우 U_45 함수 수정 필요\" >> $resultfile 2>&1\n\tdpkg_libpam_count=`dpkg -l 2>/dev/null | grep 'libpam' | wc -l`\n\tif [ $dpkg_libpam_count -gt 0 ]; then\n\t\t# !!! pam_rootok.so 설정을 하지 않은 경우 하단의 첫 번째 if 문을 삭제하세요.\n\t\tetc_pamd_su_rootokso_count=`grep -vE '^#|^\\s#' /etc/pam.d/su | grep 'pam_rootok.so' | wc -l`\n\t\tif [ $etc_pamd_su_rootokso_count -gt 0 ]; then\n\t\t\t# !!! pam_wheel.so 설정에 trust 문구를 추가한 경우 하단의 if 문 조건절에 'grep 'trust'를 추가하세요.\n\t\t\tetc_pamd_su_wheelso_count=`grep -vE '^#|^\\s#' /etc/pam.d/su | grep 'pam_wheel.so' | wc -l`\n\t\t\tif [ $etc_pamd_su_wheelso_count -gt 0 ]; then\n\t\t\t\techo \"※ U-45 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\techo \" /etc/pam.d/su 파일에 pam_wheel.so 모듈이 없습니다.\" >> $resultfile 2>&1\n\t\t\t\treturn 0\n\t\t\tfi\n\t\telse\n\t\t\techo \"※ U-45 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\techo \" /etc/pam.d/su 파일에서 pam_rootok.so 모듈이 없습니다.\" >> $resultfile 2>&1\n\t\t\treturn 0\n\t\tfi\n\telse\n\t\tsu_executables=(\"/bin/su\" \"/usr/bin/su\")\n\t\tif [ `which su 2>/dev/null | wc -l` -gt 0 ]; then\n\t\t\tsu_executables[${#su_executables[@]}]=`which su 2>/dev/null`\n\t\tfi\n\t\tfor ((i=0; i<${#su_executables[@]}; i++))\n\t\tdo\n\t\t\tif [ -f ${su_executables[$i]} ]; then\n\t\t\t\tsu_group_permission=`stat ${su_executables[$i]} | grep -i 'Uid' | awk '{print $2}' | awk -F / '{print substr($1,4,1)}'`\n\t\t\t\tif [ $su_group_permission -eq 5 ] || [ $su_group_permission -eq 4 ] || [ $su_group_permission -eq 1 ] || [ $su_group_permission -eq 0 ]; then\n\t\t\t\t\tsu_other_permission=`stat ${su_executables[$i]} | grep -i 'Uid' | awk '{print $2}' | awk -F / '{print substr($1,5,1)}'`\n\t\t\t\t\tif [ $su_other_permission -ne 0 ]; then\n\t\t\t\t\t\techo \"※ U-45 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\techo \" ${su_executables[$i]} 실행 파일의 다른 사용자(other)에 대한 권한 취약합니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\treturn 0\n\t\t\t\t\tfi\n\t\t\t\telse\n\t\t\t\t\techo \"※ U-45 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\techo \" ${su_executables[$i]} 실행 파일의 그룹 사용자(group)에 대한 권한 취약합니다.\" >> $resultfile 2>&1\n\t\t\t\t\treturn 0\n\t\t\t\tfi\n\t\t\tfi\n\t\tdone\n\tfi\n\techo \"※ U-45 결과 : 양호(Good)\" >> $resultfile 2>&1\n\treturn 0\n}\n\nU_46() {\n\techo \"\"  >> $resultfile 2>&1\n\techo \"▶ U-46(중) | 1. 계정관리 > 1.7 패스워드 최소 길이 설정 ◀\"  >> $resultfile 2>&1\n\techo \" 양호 판단 기준 : 패스워드 최소 길이가 8자 이상으로 설정되어 있는 경우\" >> $resultfile 2>&1\n\tfile_exists_count=0 # 패스워드 설정 파일 존재 시 카운트할 변수\n\tminlen_file_exists_count=0 # 패스워드 최소 길이 설정 파일 존재 시 카운트할 변수\n\tno_settings_in_minlen_file=0 # 설정 파일 존재하는데, 최소 길이에 대한 설정이 없을 때 카운트할 변수 -> 추후 file_exists_count 변수와 값을 비교하여 동일하면 모든 파일에 패스워드 최소 길이 설정이 없는 것이므로 취약으로 판단함\n\tinput_modules=(\"pam_pwquality.so\" \"pam_cracklib.so\" \"pam_unix.so\")\n\t# /etc/login.defs 파일 내 패스워드 최소 길이 설정 확인함\n\tif [ -f /etc/login.defs ]; then\n\t\t((file_exists_count++))\n\t\t((minlen_file_exists_count++))\n\t\tetc_logindefs_minlen_count=`grep -vE '^#|^\\s#' /etc/login.defs | grep -i 'PASS_MIN_LEN' | awk '{print $2}' | wc -l`\n\t\tif [ $etc_logindefs_minlen_count -gt 0 ]; then\n\t\t\tetc_logindefs_minlen_value=`grep -vE '^#|^\\s#' /etc/login.defs | grep -i 'PASS_MIN_LEN' | awk '{print $2}'`\n\t\t\tif [ $etc_logindefs_minlen_value -lt 8 ]; then\n\t\t\t\techo \"※ U-46 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\techo \" /etc/login.defs 파일에서 패스워드 최소 길이가 8 미만으로 설정되어 있습니다.\" >> $resultfile 2>&1\n\t\t\t\treturn 0\n\t\t\tfi\n\t\telse\n\t\t\t((no_settings_in_minlen_file++))\n\t\tfi\n\tfi\n\t# /etc/security/pwquality 파일 내 패스워드 최소 길이 확인함\n\tif [ -f /etc/security/pwquality.conf ]; then\n\t\t((file_exists_count++))\n\t\t((minlen_file_exists_count++))\n\t\tetc_security_pwqualityconf_minlen_count=`grep -vE '^#|^\\s#' /etc/security/pwquality.conf | grep -i 'minlen' | wc -l`\n\t\tif [ $etc_security_pwqualityconf_minlen_count -gt 0 ]; then\n\t\t\tetc_security_pwqualityconf_minlen_value=`grep -vE '^#|^\\s#' /etc/security/pwquality.conf | grep -i 'minlen' | awk -F 'minlen' '{gsub(\" \", \"\", $0); print substr($2,2,1)}'`\n\t\t\tif [ $etc_security_pwqualityconf_minlen_value -lt 8 ]; then\n\t\t\t\tetc_security_pwqualityconf_minlen_second_value=`grep -vE '^#|^\\s#' /etc/security/pwquality.conf  | grep -i 'minlen' | awk -F 'minlen' '{gsub(\" \", \"\", $0); print substr($2,3,1)}'`\n\t\t\t\tif [[ $etc_security_pwqualityconf_minlen_second_value != [0-9] ]]; then\n\t\t\t\t\techo \"※ U-46 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\techo \" /etc/security/pwquality.defs 파일에서 패스워드 최소 길이가 8 미만으로 설정되어 있습니다.\" >> $resultfile 2>&1\n\t\t\t\t\treturn 0\n\t\t\t\tfi\n\t\t\telse\n\t\t\t\tif [ -f /etc/pam.d/common-password ]; then\n\t\t\t\t\tetc_pamd_commonpassword_module_count=`grep -vE '^#|^\\s#' /etc/pam.d/common-password | grep -i 'pam_pwquality.so' | wc -l`\n\t\t\t\t\tif [ $etc_pamd_commonpassword_module_count -eq 0 ]; then\n\t\t\t\t\t\techo \"※ U-46 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\techo \" /etc/security/pwquality.conf 파일에 최소 길이(minlen)를 8 이상으로 설정하고, /etc/pam.d/common-password 파일에 pam_pwquality.so 모듈을 추가하지 않았습니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\treturn 0\n\t\t\t\t\tfi\n\t\t\t\telse\n\t\t\t\t\techo \"※ U-46 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\techo \" /etc/security/pwquality.conf 파일에 최소 길이(minlen)를 8 이상으로 설정하고, /etc/pam.d/common-password 파일에 pam_pwquality.so 모듈을 추가하지 않았습니다.\" >> $resultfile 2>&1\n\t\t\t\t\treturn 0\n\t\t\t\tfi\n\t\t\tfi\n\t\telse\n\t\t\t((no_settings_in_minlen_file++))\n\t\tfi\n\tfi\n\t# /etc/pam.d/common-password 파일 내 패스워드 최소 길이 확인함\n\tif [ -f /etc/pam.d/common-password ]; then\n\t\t((file_exists_count++))\n\t\tfor ((i=0; i<${#input_modules[@]}; i++))\n\t\tdo\n\t\t\t((minlen_file_exists_count++))\n\t\t\tetc_pamd_commonpassword_minlen_count=`grep -vE '^#|^\\s#' /etc/pam.d/common-password | grep -i 'minlen' | grep -i ${input_modules[$i]} | wc -l`\n\t\t\tif [ $etc_pamd_commonpassword_minlen_count -gt 0 ]; then\n\t\t\t\tetc_pamd_commonpassword_minlen_value=`grep -vE '^#|^\\s#' /etc/pam.d/common-password | grep -i 'minlen' | grep -i ${input_modules[$i]} | awk '{gsub(\" \", \"\", $0); print}'`\n\t\t\t\tif [ `echo $etc_pamd_commonpassword_minlen_value | awk -F 'minlen' '{print substr($2,2,1)}'` -lt 8 ]; then\n\t\t\t\t\tetc_pamd_commonpassword_minlen_second_value=`grep -vE '^#|^\\s#' /etc/pam.d/common-password | grep -i 'minlen' | grep -i ${input_modules[$i]} | awk '{gsub(\" \", \"\", $0); print}' | awk -F 'minlen' '{print substr($2,3,1)}'`\n\t\t\t\t\tif [[ $etc_pamd_commonpassword_minlen_second_value != [0-9] ]]; then\n\t\t\t\t\t\techo \"※ U-46 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\techo \" /etc/pam.d/common-password 파일에서 패스워드 최소 길이가 8 미만으로 설정되어 있습니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\treturn 0\n\t\t\t\t\tfi\n\t\t\t\tfi\n\t\t\telse\n\t\t\t\t((no_settings_in_minlen_file++))\n\t\t\tfi\n\t\tdone\n\tfi\n\tif [ $file_exists_count -eq 0 ]; then\n\t\techo \"※ U-46 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\techo \" 패스워드 최소 길이를 설정하는 파일이 없습니다.\" >> $resultfile 2>&1\n\t\treturn 0\n\telif [ $minlen_file_exists_count -eq $no_settings_in_minlen_file ]; then\n\t\techo \"※ U-46 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\techo \" 패스워드 최소 길이를 설정한 파일이 없습니다.\" >> $resultfile 2>&1\n\t\treturn 0\n\telse\n\t\techo \"※ U-46 결과 : 양호(Good)\" >> $resultfile 2>&1\n\t\treturn 0\n\tfi\n}\n\nU_47() {\n\techo \"\"  >> $resultfile 2>&1\n\techo \"▶ U-47(중) | 1. 계정관리 > 1.8 패스워드 최대 사용기간 설정 ◀\"  >> $resultfile 2>&1\n\techo \" 양호 판단 기준 : 패스워드 최대 사용기간이 90일(12주) 이하로 설정되어 있는 경우\" >> $resultfile 2>&1\n\tif [ -f /etc/login.defs ]; then\n\t\tetc_logindefs_maxdays_count=`grep -vE '^#|^\\s#' /etc/login.defs | grep -i 'PASS_MAX_DAYS' | awk '{print $2}' | wc -l`\n\t\tif [ $etc_logindefs_maxdays_count -gt 0 ]; then\n\t\t\tetc_logindefs_maxdays_value=`grep -vE '^#|^\\s#' /etc/login.defs | grep -i 'PASS_MAX_DAYS' | awk '{print $2}'`\n\t\t\tif [ $etc_logindefs_maxdays_value -gt 90 ]; then\n\t\t\t\techo \"※ U-47 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\techo \" /etc/login.defs 파일에 패스워드 최대 사용 기간이 91일 이상으로 설정되어 있습니다.\" >> $resultfile 2>&1\n\t\t\t\treturn 0\n\t\t\telse\n\t\t\t\techo \"※ U-47 결과 : 양호(Good)\" >> $resultfile 2>&1\n\t\t\t\treturn 0\n\t\t\tfi\n\t\telse\n\t\t\techo \"※ U-47 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\techo \" /etc/login.defs 파일에 패스워드 최대 사용 기간이 설정되어 있지 않습니다.\" >> $resultfile 2>&1\n\t\t\treturn 0\n\t\tfi\n\telse\n\t\techo \"※ U-47 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\techo \" /etc/login.defs 파일이 없습니다.\" >> $resultfile 2>&1\n\t\treturn 0\n\tfi\n}\n\nU_48() {\n\techo \"\"  >> $resultfile 2>&1\n\techo \"▶ U-48(중) | 1. 계정관리 > 1.9 패스워드 최소 사용기간 설정 ◀\"  >> $resultfile 2>&1\n\techo \" 양호 판단 기준 : 패스워드 최소 사용기간이 1일 이상 설정되어 있는 경우\" >> $resultfile 2>&1\n\tif [ -f /etc/login.defs ]; then\n\t\tetc_logindefs_mindays_count=`grep -vE '^#|^\\s#' /etc/login.defs | grep -i 'PASS_MIN_DAYS' | awk '{print $2}' | wc -l`\n\t\tif [ $etc_logindefs_mindays_count -gt 0 ]; then\n\t\t\tetc_logindefs_mindays_value=`grep -vE '^#|^\\s#' /etc/login.defs | grep -i 'PASS_MIN_DAYS' | awk '{print $2}'`\n\t\t\tif [ $etc_logindefs_mindays_value -lt 1 ]; then\n\t\t\t\techo \"※ U-48 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\techo \" /etc/login.defs 파일에 패스워드 최소 사용 기간이 1일 미만으로 설정되어 있습니다.\" >> $resultfile 2>&1\n\t\t\t\treturn 0\n\t\t\telse\n\t\t\t\techo \"※ U-48 결과 : 양호(Good)\" >> $resultfile 2>&1\n\t\t\t\treturn 0\n\t\t\tfi\n\t\telse\n\t\t\techo \"※ U-48 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\techo \" /etc/login.defs 파일에 패스워드 최소 사용 기간이 설정되어 있지 않습니다.\" >> $resultfile 2>&1\n\t\t\treturn 0\n\t\tfi\n\telse\n\t\techo \"※ U-48 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\techo \" /etc/login.defs 파일이 없습니다.\" >> $resultfile 2>&1\n\t\treturn 0\n\tfi\n}\n\nU_49() {\n\techo \"\"  >> $resultfile 2>&1\n\techo \"▶ U-49(하) | 1. 계정관리 > 1.10 불필요한 계정 제거 ◀\"  >> $resultfile 2>&1\n\techo \" 양호 판단 기준 : 불필요한 계정이 존재하지 않는 경우\" >> $resultfile 2>&1\n\techo \" ### 로그를 통한 확인은 수동으로 점검하세요.\" >> $resultfile 2>&1\n\techo \" ### 불필요한 계정에 대한 변경 필요 시 U_49 함수 수정 필요\" >> $resultfile 2>&1\n\techo \" ### 불필요한 계정 = daemon, bin, sys, adm, listen, nobody, nobody4, noaccess, diag, operator, gopher, games, ftp, apache, httpd, www-data, mysql, mariadb, postgres, mail, postfix, news, lp, uucp, nuucp\" >> $resultfile 2>&1\n\tif [ -f /etc/passwd ]; then\n\t\t# !!! 불필요한 계정을 변경할 경우 하단의 grep 명령어를 수정하세요.\n\t\tif [ `awk -F : '{print $1}' /etc/passwd | grep -wE 'daemon|bin|sys|adm|listen|nobody|nobody4|noaccess|diag|operator|gopher|games|ftp|apache|httpd|www-data|mysql|mariadb|postgres|mail|postfix|news|lp|uucp|nuucp' | wc -l` -gt 0 ]; then\n\t\t\techo \"※ U-49 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\techo \" 불필요한 계정이 존재합니다.\" >> $resultfile 2>&1\n\t\t\treturn 0\n\t\tfi\n\tfi\n\techo \"※ U-49 결과 : 양호(Good)\" >> $resultfile 2>&1\n\treturn 0\n}\n\nU_50() {\n\techo \"\"  >> $resultfile 2>&1\n\techo \"▶ U-50(하) | 1. 계정관리 > 1.11 관리자 그룹에 최소한의 계정 포함 ◀\"  >> $resultfile 2>&1\n\techo \" 양호 판단 기준 : 관리자 그룹에 불필요한 계정이 등록되어 있지 않은 경우\" >> $resultfile 2>&1\n\techo \" ### 불필요한 계정에 대한 변경 필요 시 U_50 함수 수정 필요\" >> $resultfile 2>&1\n\techo \" ### 불필요한 계정 = daemon, bin, sys, adm, listen, nobody, nobody4, noaccess, diag, operator, gopher, games, ftp, apache, httpd, www-data, mysql, mariadb, postgres, mail, postfix, news, lp, uucp, nuucp\" >> $resultfile 2>&1\n\tif [ -f /etc/group ]; then\n\t\t# !!! 불필요한 계정에 대한 변경은 하단의 grep 명령어를 수정하세요.\n\t\tif [ `awk -F : '$1==\"root\" {gsub(\" \", \"\", $0); print $4}' /etc/group | awk '{gsub(\",\",\"\\n\",$0); print}' | grep -wE 'daemon|bin|sys|adm|listen|nobody|nobody4|noaccess|diag|operator|gopher|games|ftp|apache|httpd|www-data|mysql|mariadb|postgres|mail|postfix|news|lp|uucp|nuucp' | wc -l` -gt 0 ]; then\n\t\t\techo \"※ U-50 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\techo \" 관리자 그룹(root)에 불필요한 계정이 등록되어 있습니다.\" >> $resultfile 2>&1\n\t\t\treturn 0\n\t\tfi\n\tfi\n\techo \"※ U-50 결과 : 양호(Good)\" >> $resultfile 2>&1\n\treturn 0\n}\n\nU_51() {\n\techo \"\"  >> $resultfile 2>&1\n\techo \"▶ U-51(하) | 1. 계정관리 > 1.12 계정이 존재하지 않는 GID 금지 ◀\"  >> $resultfile 2>&1\n\techo \" 양호 판단 기준 : 시스템 관리나 운용에 불필요한 그룹이 삭제 되어있는 경우\" >> $resultfile 2>&1\n\techo \" ### 불필요한 그룹 = 그룹에 계정이 존재하지 않는 그룹\" >> $resultfile 2>&1\n\tunnecessary_groups=(`grep -vE '^#|^\\s#' /etc/group | awk -F : '$3>=500 && $4==null {print $3}' | uniq`)\n\tfor ((i=0; i<${#unnecessary_groups[@]}; i++))\n\tdo\n\t\tif [ `awk -F : '{print $4}' /etc/passwd | uniq | grep ${unnecessary_groups[$i]} | wc -l` -eq 0 ]; then\n\t\t\techo \"※ U-51 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\techo \" 불필요한 그룹이 존재합니다.\" >> $resultfile 2>&1\n\t\t\treturn 0\n\t\tfi\n\tdone\n\techo \"※ U-51 결과 : 양호(Good)\" >> $resultfile 2>&1\n\treturn 0\n}\n\nU_52() {\n\techo \"\"  >> $resultfile 2>&1\n\techo \"▶ U-52(중) | 1. 계정관리 > 1.13 동일한 UID 금지 ◀\"  >> $resultfile 2>&1\n\techo \" 양호 판단 기준 : 동일한 UID로 설정된 사용자 계정이 존재하지 않는 경우\" >> $resultfile 2>&1\n\tif [ -f /etc/passwd ]; then\n\t\tif [ `awk -F : '{print $3}' /etc/passwd | sort | uniq -d | wc -l` -gt 0 ]; then\n\t\t\techo \"※ U-52 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\techo \" 동일한 UID로 설정된 사용자 계정이 존재합니다.\" >> $resultfile 2>&1\n\t\t\treturn 0\n\t\tfi\n\tfi\n\techo \"※ U-52 결과 : 양호(Good)\" >> $resultfile 2>&1\n\treturn 0\n}\n\nU_53() {\n\techo \"\"  >> $resultfile 2>&1\n\techo \"▶ U-53(하) | 1. 계정관리 > 1.14 사용자 shell 점검 ◀\"  >> $resultfile 2>&1\n\techo \" 양호 판단 기준 : 로그인이 필요하지 않은 계정에 /bin/false(/sbin/nologin) 쉘이 부여되어 있는 경우\" >> $resultfile 2>&1\n\techo \" ### 불필요한 계정에 대한 변경 필요 시 U_53 함수 수정 필요\" >> $resultfile 2>&1\n\techo \" ### 불필요한 계정 = daemon, bin, sys, adm, listen, nobody, nobody4, noaccess, diag, operator, gopher, games, ftp, apache, httpd, www-data, mysql, mariadb, postgres, mail, postfix, news, lp, uucp, nuucp\" >> $resultfile 2>&1\n\tif [ -f /etc/passwd ]; then\n\t\t# !!! 불필요한 계정에 대한 변경은 하단의 grep 명령어를 수정하세요.\n\t\tif [ `grep -E '^(daemon|bin|sys|adm|listen|nobody|nobody4|noaccess|diag|operator|gopher|games|ftp|apache|httpd|www-data|mysql|mariadb|postgres|mail|postfix|news|lp|uucp|nuucp):' /etc/passwd | awk -F : '$7!=\"/bin/false\" && $7!=\"/sbin/nologin\" {print}' | wc -l` -gt 0 ]; then\n\t\t\techo \"※ U-53 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\techo \" 로그인이 필요하지 않은 불필요한 계정에 /bin/false 또는 /sbin/nologin 쉘이 부여되지 않았습니다.\" >> $resultfile 2>&1\n\t\t\treturn 0\n\t\tfi\n\tfi\n\techo \"※ U-53 결과 : 양호(Good)\" >> $resultfile 2>&1\n\treturn 0\n}\n\nU_54() {\n\techo \"\"  >> $resultfile 2>&1\n\techo \"▶ U-54(하) | 1. 계정관리 > 1.15 Session Timeout 설정 ◀\"  >> $resultfile 2>&1\n\techo \" 양호 판단 기준 : Session Timeout이 600초(10분) 이하로 설정되어 있는 경우\" >> $resultfile 2>&1\n\tfile_exists_count=0 # 세션 타임아웃 설정 파일 존재 시 카운트할 변수\n\tno_tmout_setting_file=0 # 설정 파일 존재하는데, 세션 타임아웃 설정이 없을 때 카운트할 변수 -> 추후 file_exists_count 변수와 값을 비교하여 동일하면 모든 파일에 세션 타임아웃 설정이 없는 것이므로 취약으로 판단함\n\t# /etc/profile 파일 내 세션 타임아웃 설정 확인함\n\tif [ -f /etc/profile ]; then\n\t\t((file_exists_count++))\n\t\tetc_profile_tmout_count=`grep -vE '^#|^\\s#' /etc/profile | grep -i 'TMOUT' | awk -F = '{gsub(\" \", \"\", $0); print $2}' | wc -l`\n\t\tif [ $etc_profile_tmout_count -gt 0 ]; then\n\t\t\tetc_profile_tmout_value=`grep -vE '^#|^\\s#' /etc/profile | grep -i 'TMOUT' | awk -F = '{gsub(\" \", \"\", $0); print $2}'`\n\t\t\tif [ $etc_profile_tmout_value -gt 600 ]; then\n\t\t\t\techo \"※ U-54 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\techo \" /etc/profile 파일에 세션 타임아웃이 600초 이하로 설정되지 않았습니다.\" >> $resultfile 2>&1\n\t\t\t\treturn 0\n\t\t\tfi\n\t\telse\n\t\t\t((no_tmout_setting_file++))\n\t\tfi\n\tfi\n\t# 사용자 홈 디렉터리 내 .profile 파일에서 세션 타임아웃 설정 확인함\n\tuser_homedirectory_path=(`awk -F : '$7!=\"/bin/false\" && $7!=\"/sbin/nologin\" && $6!=null {print $6}'  /etc/passwd | uniq`) # /etc/passwd 파일에 설정된 홈 디렉터리 배열 생성\n\tuser_homedirectory_path2=(/home/*) # /home 디렉터래 내 위치한 홈 디렉터리 배열 생성\n\tfor ((i=0; i<${#user_homedirectory_path2[@]}; i++))\n\tdo\n\t\tuser_homedirectory_path[${#user_homedirectory_path[@]}]=${user_homedirectory_path2[$i]} # 두 개의 배열 합침\n\tdone\n\tfor ((i=0; i<${#user_homedirectory_path[@]}; i++))\n\tdo\n\t\tif [ -f ${user_homedirectory_path[$i]}/.profile ]; then\n\t\t\t((file_exists_count++))\n\t\t\tuser_homedirectory_profile_tmout_count=`grep -vE '^#|^\\s#' ${user_homedirectory_path[$i]}/.profile | grep -i 'TMOUT' | awk -F = '{gsub(\" \", \"\", $0); print $2}' | wc -l`\n\t\t\tif [ $user_homedirectory_profile_tmout_count -gt 0 ]; then\n\t\t\t\tuser_homedirectory_profile_tmout_value=`grep -vE '^#|^\\s#' ${user_homedirectory_path[$i]}/.profile | grep -i 'TMOUT' | awk -F = '{gsub(\" \", \"\", $0); print $2}'`\n\t\t\t\tif [ $user_homedirectory_profile_tmout_value -gt 600 ]; then\n\t\t\t\t\techo \"※ U-54 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\techo \" ${user_homedirectory_path[$i]}/.profile 파일에 세션 타임아웃이 600초 이하로 설정되지 않았습니다.\" >> $resultfile 2>&1\n\t\t\t\t\treturn 0\n\t\t\t\tfi\n\t\t\telse\n\t\t\t\t((no_tmout_setting_file++))\n\t\t\tfi\n\t\tfi\n\tdone\n\t# /etc/csh.login 파일 내 세션 타임아웃 설정 확인함\n\tif [ -f /etc/csh.login ]; then\n\t\t((file_exists_count++))\n\t\tetc_cshlogin_tmout_count=`grep -vE '^#|^\\s#' /etc/csh.login | grep -i 'set' | grep -i 'autologout' | awk -F = '{gsub(\" \", \"\", $0); print $2}' | wc -l`\n\t\tif [ $etc_cshlogin_tmout_count -gt 0 ]; then\n\t\t\tetc_cshlogin_tmout_value=`grep -vE '^#|^\\s#' /etc/csh.login | grep -i 'set' | grep -i 'autologout' | awk -F = '{gsub(\" \", \"\", $0); print $2}'`\n\t\t\tif [ $etc_cshlogin_tmout_value -gt 10 ]; then\n\t\t\t\techo \"※ U-54 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\techo \" /etc/csh.login 파일에 세션 타임아웃이 10분 이하로 설정되지 않았습니다.\" >> $resultfile 2>&1\n\t\t\t\treturn 0\n\t\t\tfi\n\t\telse\n\t\t\t((no_tmout_setting_file++))\n\t\tfi\n\tfi\n\t# /etc/csh.cshrc 파일 내 세션 타임아웃 설정 확인함\n\tif [ -f /etc/csh.cshrc ]; then\n\t\t((file_exists_count++))\n\t\tetc_cshrc_tmout_count=`grep -vE '^#|^\\s#' /etc/csh.cshrc | grep -i 'set' | grep -i 'autologout' | awk -F = '{gsub(\" \", \"\", $0); print $2}' | wc -l`\n\t\tif [ $etc_cshrc_tmout_count -gt 10 ]; then\n\t\t\tetc_cshrc_tmout_value=`grep -vE '^#|^\\s#' /etc/csh.cshrc | grep -i 'set' | grep -i 'autologout' | awk -F = '{gsub(\" \", \"\", $0); print $2}'`\n\t\t\tif [ $etc_cshrc_tmout_value -gt 10 ]; then\n\t\t\t\techo \"※ U-54 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\techo \" /etc/csh.cshrc 파일에 세션 타임아웃이 10분 이하로 설정되지 않았습니다.\" >> $resultfile 2>&1\n\t\t\t\treturn 0\n\t\t\tfi\n\t\telse\n\t\t\t((no_tmout_setting_file++))\n\t\tfi\n\tfi\n\tif [ $file_exists_count -eq 0 ]; then\n\t\techo \"※ U-54 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\techo \" 세션 타임아웃을 설정하는 파일이 없습니다.\" >> $resultfile 2>&1\n\t\treturn 0\n\telif [ $file_exists_count -eq $no_tmout_setting_file ]; then\n\t\techo \"※ U-54 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\techo \" 세션 타임아웃을 설정한 파일이 없습니다.\" >> $resultfile 2>&1\n\t\treturn 0\n\telse\n\t\techo \"※ U-54 결과 : 양호(Good)\" >> $resultfile 2>&1\n\t\treturn 0\n\tfi\n}\n\nU_55() {\n\techo \"\"  >> $resultfile 2>&1\n\techo \"▶ U-55(하) | 2. 파일 및 디렉토리 관리 > 2.15 hosts.lpd 파일 소유자 및 권한 설정 ◀\"  >> $resultfile 2>&1\n\techo \" 양호 판단 기준 : hosts.lpd 파일이 삭제되어 있거나 불가피하게 hosts.lpd 파일을 사용할 시 파일의 소유자가 root이고 권한이 600인 경우\" >> $resultfile 2>&1\n\tif [ -f /etc/hosts.lpd ]; then\n\t\tetc_hostslpd_owner_name=`ls -l /etc/hosts.lpd | awk '{print $3}'`\n\t\tif [[ $etc_hostslpd_owner_name =~ root ]]; then\n\t\t\tetc_hostslpd_permission=`stat /etc/hosts.lpd | grep -i 'Uid' | awk '{print $2}' | awk -F / '{print substr($1,3,3)}'`\n\t\t\tif [ $etc_hostslpd_permission -eq 600 ]; then\n\t\t\t\techo \"※ U-55 결과 : 양호(Good)\" >> $resultfile 2>&1\n\t\t\t\treturn 0\n\t\t\telse\n\t\t\t\techo \"※ U-55 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\techo \" /etc/hosts.lpd 파일의 권한이 600이 아닙니다.\" >> $resultfile 2>&1\n\t\t\t\treturn 0\n\t\t\tfi\n\t\telse\n\t\t\techo \"※ U-55 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\techo \" /etc/hosts.lpd 파일의 소유자(owner)가 root가 아닙니다.\" >> $resultfile 2>&1\n\t\t\treturn 0\n\t\tfi\n\telse\n\t\techo \"※ U-55 결과 : 양호(Good)\" >> $resultfile 2>&1\n\t\treturn 0\n\tfi\n}\n\nU_56() {\n\techo \"\"  >> $resultfile 2>&1\n\techo \"▶ U-56(중) | 2. 파일 및 디렉토리 관리 > 2.17 UMASK 설정 관리 ◀\"  >> $resultfile 2>&1\n\techo \" 양호 판단 기준 : UMASK 값이 022 이상으로 설정된 경우\" >> $resultfile 2>&1\n\tumaks_value=`umask`\n\tif [ ${umaks_value:2:1} -lt 2 ]; then\n\t\techo \"※ U-56 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\techo \" 그룹 사용자(group)에 대한 umask 값이 2 이상으로 설정되지 않았습니다.\" >> $resultfile 2>&1\n\t\treturn 0\n\telif [ ${umaks_value:3:1} -lt 2 ]; then\n\t\techo \"※ U-56 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\techo \" 다른 사용자(other)에 대한 umask 값이 2 이상으로 설정되지 않았습니다.\" >> $resultfile 2>&1\n\t\treturn 0\n\tfi\n\t# /etc/profile 파일 내 umask 설정 확인함\n\tetc_profile_umask_count=`grep -vE '^#|^\\s#' /etc/profile | grep -i 'umask' | grep -vE 'if|\\`' | grep '=' | wc -l` # 설정 파일에 <umask=값> 형식으로 umask 값이 설정된 경우\n\tetc_profile_umask_count2=`grep -vE '^#|^\\s#' /etc/profile | grep -i 'umask' | grep -vE 'if|\\`' | awk '{print $2}' | wc -l` # 설정 파일에 <umask 값> 형식으로 umask 값이 설정된 경우\n\tif [ -f /etc/profile ]; then\n\t\tif [ $etc_profile_umask_count -gt 0 ]; then\n\t\t\tumaks_value=(`grep -vE '^#|^\\s#' /etc/profile | grep -i 'umask' | grep -vE 'if|\\`' | awk -F = '{gsub(\" \", \"\", $0); print $2}'`)\n\t\t\tfor ((i=0; i<${#umaks_value[@]}; i++))\n\t\t\tdo\n\t\t\t\tif [ ${#umaks_value[$i]} -eq 2 ]; then\n\t\t\t\t\tif [ ${umaks_value[$i]:0:1} -lt 2 ]; then\n\t\t\t\t\t\techo \"※ U-56 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\techo \" /etc/profile 파일에 그룹 사용자(group)에 대한 umask 값이 2 이상으로 설정되지 않았습니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\treturn 0\n\t\t\t\t\telif [ ${umaks_value[$i]:1:1} -lt 2 ]; then\n\t\t\t\t\t\techo \"※ U-56 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\techo \" /etc/profile 파일에 다른 사용자(other)에 대한 umask 값이 2 이상으로 설정되지 않았습니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\treturn 0\n\t\t\t\t\tfi\n\t\t\t\telif [ ${#umaks_value[$i]} -eq 4 ]; then\n\t\t\t\t\tif [ ${umaks_value[$i]:2:1} -lt 2 ]; then\n\t\t\t\t\t\techo \"※ U-56 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\techo \" /etc/profile 파일에 그룹 사용자(group)에 대한 umask 값이 2 이상으로 설정되지 않았습니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\treturn 0\n\t\t\t\t\telif [ ${umaks_value[$i]:3:1} -lt 2 ]; then\n\t\t\t\t\t\techo \"※ U-56 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\techo \" /etc/profile 파일에 다른 사용자(other)에 대한 umask 값이 2 이상으로 설정되지 않았습니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\treturn 0\n\t\t\t\t\tfi\n\t\t\t\telif [ ${#umaks_value[$i]} -eq 3 ]; then\n\t\t\t\t\tif [ ${umaks_value[$i]:1:1} -lt 2 ]; then\n\t\t\t\t\t\techo \"※ U-56 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\techo \" /etc/profile 파일에 그룹 사용자(group)에 대한 umask 값이 2 이상으로 설정되지 않았습니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\treturn 0\n\t\t\t\t\telif [ ${umaks_value[$i]:2:1} -lt 2 ]; then\n\t\t\t\t\t\techo \"※ U-56 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\techo \" /etc/profile 파일에 다른 사용자(other)에 대한 umask 값이 2 이상으로 설정되지 않았습니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\treturn 0\n\t\t\t\t\tfi\n\t\t\t\telif [ ${#umaks_value[$i]} -eq 1 ]; then\n\t\t\t\t\techo \"※ U-56 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\techo \" /etc/profile 파일에 umask 값이 0022 이상으로 설정되지 않았습니다.\" >> $resultfile 2>&1\n\t\t\t\t\treturn 0\n\t\t\t\telse\n\t\t\t\t\techo \"※ U-56 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\techo \" /etc/profile 파일에 설정된 umask 값이 보안 설정에 부합하지 않습니다.\" >> $resultfile 2>&1\n\t\t\t\t\treturn 0\n\t\t\t\tfi\n\t\t\tdone\n\t\telif [ $etc_profile_umask_count2 -gt 0 ]; then\n\t\t\tumaks_value=(`grep -vE '^#|^\\s#' /etc/profile | grep -i 'umask' | grep -vE 'if|\\`' | awk '{print $2}'`)\n\t\t\tfor ((i=0; i<${#umaks_value[@]}; i++))\n\t\t\tdo\n\t\t\t\tif [ ${#umaks_value[$i]} -eq 2 ]; then\n\t\t\t\t\tif [ ${umaks_value[$i]:0:1} -lt 2 ]; then\n\t\t\t\t\t\techo \"※ U-56 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\techo \" /etc/profile 파일에 그룹 사용자(group)에 대한 umask 값이 2 이상으로 설정되지 않았습니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\treturn 0\n\t\t\t\t\telif [ ${umaks_value[$i]:1:1} -lt 2 ]; then\n\t\t\t\t\t\techo \"※ U-56 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\techo \" /etc/profile 파일에 다른 사용자(other)에 대한 umask 값이 2 이상으로 설정되지 않았습니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\treturn 0\n\t\t\t\t\tfi\n\t\t\t\telif [ ${#umaks_value[$i]} -eq 4 ]; then\n\t\t\t\t\tif [ ${umaks_value[$i]:2:1} -lt 2 ]; then\n\t\t\t\t\t\techo \"※ U-56 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\techo \" /etc/profile 파일에 그룹 사용자(group)에 대한 umask 값이 2 이상으로 설정되지 않았습니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\treturn 0\n\t\t\t\t\telif [ ${umaks_value[$i]:3:1} -lt 2 ]; then\n\t\t\t\t\t\techo \"※ U-56 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\techo \" /etc/profile 파일에 다른 사용자(other)에 대한 umask 값이 2 이상으로 설정되지 않았습니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\treturn 0\n\t\t\t\t\tfi\n\t\t\t\telif [ ${#umaks_value[$i]} -eq 3 ]; then\n\t\t\t\t\tif [ ${umaks_value[$i]:1:1} -lt 2 ]; then\n\t\t\t\t\t\techo \"※ U-56 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\techo \" /etc/profile 파일에 그룹 사용자(group)에 대한 umask 값이 2 이상으로 설정되지 않았습니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\treturn 0\n\t\t\t\t\telif [ ${umaks_value[$i]:2:1} -lt 2 ]; then\n\t\t\t\t\t\techo \"※ U-56 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\techo \" /etc/profile 파일에 다른 사용자(other)에 대한 umask 값이 2 이상으로 설정되지 않았습니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\treturn 0\n\t\t\t\t\tfi\n\t\t\t\telif [ ${#umaks_value[$i]} -eq 1 ]; then\n\t\t\t\t\techo \"※ U-56 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\techo \" /etc/profile 파일에 umask 값이 0022 이상으로 설정되지 않았습니다.\" >> $resultfile 2>&1\n\t\t\t\t\treturn 0\n\t\t\t\telse\n\t\t\t\t\techo \"※ U-56 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\techo \" /etc/profile 파일에 설정된 umask 값이 보안 설정에 부합하지 않습니다.\" >> $resultfile 2>&1\n\t\t\t\t\treturn 0\n\t\t\t\tfi\n\t\t\tdone\n\t\tfi\n\tfi\n\t# /etc/bashrc, /etc/csh.login, /etc/csh.cshrc 파일 내 umask 설정 확인함\n\tumask_settings_files=(\"/etc/bashrc\" \"/etc/csh.login\" \"/etc/csh.cshrc\")\n\tfor ((i=0; i<${#umask_settings_files[@]}; i++))\n\tdo\n\t\tif [ -f ${umask_settings_files[$i]} ]; then\n\t\t\tfile_umask_count=`grep -vE '^#|^\\s#' ${umask_settings_files[$i]} | grep -i 'umask' | grep -vE 'if|\\`' | awk '{print $2}' | wc -l`\n\t\t\tif [ $file_umask_count -gt 0 ]; then\n\t\t\t\tumaks_value=(`grep -vE '^#|^\\s#' ${umask_settings_files[$i]} | grep -i 'umask' | grep -vE 'if|\\`' | awk '{print $2}'`)\n\t\t\t\tfor ((j=0; j<${#umaks_value[@]}; j++))\n\t\t\t\tdo\n\t\t\t\t\tif [ ${#umaks_value[$j]} -eq 2 ]; then\n\t\t\t\t\t\tif [ ${umaks_value[$j]:0:1} -lt 2 ]; then\n\t\t\t\t\t\t\techo \"※ U-56 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\t\techo \" ${umask_settings_files[$i]} 파일에 그룹 사용자(group)에 대한 umask 값이 2 이상으로 설정되지 않았습니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\t\treturn 0\n\t\t\t\t\t\telif [ ${umaks_value[$j]:1:1} -lt 2 ]; then\n\t\t\t\t\t\t\techo \"※ U-56 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\t\techo \" ${umask_settings_files[$i]} 파일에 다른 사용자(other)에 대한 umask 값이 2 이상으로 설정되지 않았습니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\t\treturn 0\n\t\t\t\t\t\tfi\n\t\t\t\t\telif [ ${#umaks_value[$j]} -eq 4 ]; then\n\t\t\t\t\t\tif [ ${umaks_value[$j]:2:1} -lt 2 ]; then\n\t\t\t\t\t\t\techo \"※ U-56 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\t\techo \" ${umask_settings_files[$i]} 파일에 그룹 사용자(group)에 대한 umask 값이 2 이상으로 설정되지 않았습니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\t\treturn 0\n\t\t\t\t\t\telif [ ${umaks_value[$j]:3:1} -lt 2 ]; then\n\t\t\t\t\t\t\techo \"※ U-56 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\t\techo \" ${umask_settings_files[$i]} 파일에 다른 사용자(other)에 대한 umask 값이 2 이상으로 설정되지 않았습니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\t\treturn 0\n\t\t\t\t\t\tfi\n\t\t\t\t\telif [ ${#umaks_value[$j]} -eq 3 ]; then\n\t\t\t\t\t\tif [ ${umaks_value[$j]:1:1} -lt 2 ]; then\n\t\t\t\t\t\t\techo \"※ U-56 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\t\techo \" ${umask_settings_files[$i]} 파일에 그룹 사용자(group)에 대한 umask 값이 2 이상으로 설정되지 않았습니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\t\treturn 0\n\t\t\t\t\t\telif [ ${umaks_value[$j]:2:1} -lt 2 ]; then\n\t\t\t\t\t\t\techo \"※ U-56 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\t\techo \" ${umask_settings_files[$i]} 파일에 다른 사용자(other)에 대한 umask 값이 2 이상으로 설정되지 않았습니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\t\treturn 0\n\t\t\t\t\t\tfi\n\t\t\t\t\telif [ ${#umaks_value[$j]} -eq 1 ]; then\n\t\t\t\t\t\techo \"※ U-56 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\techo \" ${umask_settings_files[$i]} 파일에 umask 값이 0022 이상으로 설정되지 않았습니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\treturn 0\n\t\t\t\t\telse\n\t\t\t\t\t\techo \"※ U-56 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\techo \" ${umask_settings_files[$i]} 파일에 설정된 umask 값이 보안 설정에 부합하지 않습니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\treturn 0\n\t\t\t\t\tfi\n\t\t\t\tdone\n\t\t\tfi\n\t\tfi\n\tdone\n\t# 사용자 홈 디렉터리 내 설정 파일에서 umask 설정 확인함\n\tuser_homedirectory_path=(`awk -F : '$7!=\"/bin/false\" && $7!=\"/sbin/nologin\" && $6!=null {print $6}' /etc/passwd | uniq`) # /etc/passwd 파일에 설정된 홈 디렉터리 배열 생성\n\tuser_homedirectory_path2=(/home/*) # /home 디렉터래 내 위치한 홈 디렉터리 배열 생성\n\tfor ((i=0; i<${#user_homedirectory_path2[@]}; i++))\n\tdo\n\t\tuser_homedirectory_path[${#user_homedirectory_path[@]}]=${user_homedirectory_path2[$i]} # 두 개의 배열 합침\n\tdone\n\tumask_settings_files=(\".cshrc\" \".profile\" \".login\" \".bashrc\" \".kshrc\")\n\tfor ((i=0; i<${#user_homedirectory_path[@]}; i++))\n\tdo\n\t\tfor ((j=0; j<${#umask_settings_files[@]}; j++))\n\t\tdo\n\t\t\tif [ -f ${user_homedirectory_path[$i]}/${umask_settings_files[$j]} ]; then\n\t\t\t\tuser_homedirectory_setting_umask_count=`grep -vE '^#|^\\s#' ${user_homedirectory_path[$i]}/${umask_settings_files[$j]} | grep -i 'umask' | grep -vE 'if|\\`' | awk '{print $2}' | wc -l`\n\t\t\t\tif [ $user_homedirectory_setting_umask_count -gt 0 ]; then\n\t\t\t\t\tumaks_value=(`grep -vE '^#|^\\s#' ${user_homedirectory_path[$i]}/${umask_settings_files[$j]} | grep -i 'umask' | grep -vE 'if|\\`' | awk '{print $2}'`)\n\t\t\t\t\tfor ((k=0; k<${#umaks_value[@]}; k++))\n\t\t\t\t\tdo\n\t\t\t\t\t\tif [ ${#umaks_value[$k]} -eq 2 ]; then\n\t\t\t\t\t\t\tif [ ${umaks_value[$k]:0:1} -lt 2 ]; then\n\t\t\t\t\t\t\t\techo \"※ U-56 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\t\t\techo \" ${user_homedirectory_path[$i]}/${umask_settings_files[$j]} 파일에 그룹 사용자(group)에 대한 umask 값이 2 이상으로 설정되지 않았습니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\t\t\treturn 0\n\t\t\t\t\t\t\telif [ ${umaks_value[$k]:1:1} -lt 2 ]; then\n\t\t\t\t\t\t\t\techo \"※ U-56 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\t\t\techo \" ${user_homedirectory_path[$i]}/${umask_settings_files[$j]} 파일에 다른 사용자(other)에 대한 umask 값이 2 이상으로 설정되지 않았습니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\t\t\treturn 0\n\t\t\t\t\t\t\tfi\n\t\t\t\t\t\telif [ ${#umaks_value[$k]} -eq 4 ]; then\n\t\t\t\t\t\t\tif [ ${umaks_value[$k]:2:1} -lt 2 ]; then\n\t\t\t\t\t\t\t\techo \"※ U-56 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\t\t\techo \" ${user_homedirectory_path[$i]}/${umask_settings_files[$j]} 파일에 그룹 사용자(group)에 대한 umask 값이 2 이상으로 설정되지 않았습니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\t\t\treturn 0\n\t\t\t\t\t\t\telif [ ${umaks_value[$k]:3:1} -lt 2 ]; then\n\t\t\t\t\t\t\t\techo \"※ U-56 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\t\t\techo \" ${user_homedirectory_path[$i]}/${umask_settings_files[$j]} 파일에 다른 사용자(other)에 대한 umask 값이 2 이상으로 설정되지 않았습니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\t\t\treturn 0\n\t\t\t\t\t\t\tfi\n\t\t\t\t\t\telif [ ${#umaks_value[$k]} -eq 3 ]; then\n\t\t\t\t\t\t\tif [ ${umaks_value[$k]:1:1} -lt 2 ]; then\n\t\t\t\t\t\t\t\techo \"※ U-56 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\t\t\techo \" ${user_homedirectory_path[$i]}/${umask_settings_files[$j]} 파일에 그룹 사용자(group)에 대한 umask 값이 2 이상으로 설정되지 않았습니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\t\t\treturn 0\n\t\t\t\t\t\t\telif [ ${umaks_value[$k]:2:1} -lt 2 ]; then\n\t\t\t\t\t\t\t\techo \"※ U-56 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\t\t\techo \" ${user_homedirectory_path[$i]}/${umask_settings_files[$j]} 파일에 다른 사용자(other)에 대한 umask 값이 2 이상으로 설정되지 않았습니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\t\t\treturn 0\n\t\t\t\t\t\t\tfi\n\t\t\t\t\t\telif [ ${#umaks_value[$k]} -eq 1 ]; then\n\t\t\t\t\t\t\techo \"※ U-56 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\t\techo \" ${user_homedirectory_path[$i]}/${umask_settings_files[$j]} 파일에 umask 값이 0022 이상으로 설정되지 않았습니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\t\treturn 0\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\techo \"※ U-56 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\t\techo \" ${user_homedirectory_path[$i]}/${umask_settings_files[$j]} 파일에 설정된 umask 값이 보안 설정에 부합하지 않습니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\t\treturn 0\n\t\t\t\t\t\tfi\n\t\t\t\t\tdone\n\t\t\t\tfi\n\t\t\tfi\n\t\tdone\n\tdone\n\techo \"※ U-56 결과 : 양호(Good)\" >> $resultfile 2>&1\n\treturn 0\n}\n\nU_57() {\n\techo \"\"  >> $resultfile 2>&1\n\techo \"▶ U-57(중) | 2. 파일 및 디렉토리 관리 > 2.18 홈디렉토리 소유자 및 권한 설정 ◀\"  >> $resultfile 2>&1\n\techo \" 양호 판단 기준 : 홈 디렉터리 소유자가 해당 계정이고, 타 사용자 쓰기 권한이 제거된 경우\" >> $resultfile 2>&1\n\tuser_homedirectory_path=(`awk -F : '$7!=\"/bin/false\" && $7!=\"/sbin/nologin\" && $6!=null {print $6}' /etc/passwd`) # /etc/passwd 파일에 설정된 홈 디렉터리 배열 생성\n\tuser_homedirectory_path2=(/home/*) # /home 디렉터래 내 위치한 홈 디렉터리 배열 생성\n\tfor ((i=0; i<${#user_homedirectory_path2[@]}; i++))\n\tdo\n\t\tuser_homedirectory_path[${#user_homedirectory_path[@]}]=${user_homedirectory_path2[$i]} # 두 개의 배열 합침\n\tdone\n\tuser_homedirectory_owner_name=(`awk -F : '$7!=\"/bin/false\" && $7!=\"/sbin/nologin\" && $6!=null {print $1}' /etc/passwd`) # /etc/passwd 파일에 설정된 사용자명 배열 생성\n\tfor ((i=0; i<${#user_homedirectory_path2[@]}; i++))\n\tdo\n\t\tuser_homedirectory_owner_name[${#user_homedirectory_owner_name[@]}]=`echo ${user_homedirectory_path2[$i]} | awk -F / '{print $3}'` # user_homedirectory_path2 배열에서 사용자명만 따로 출력하여 배열에 저장함\n\tdone\n\tfor ((i=0; i<${#user_homedirectory_path[@]}; i++))\n\tdo\n\t\tif [ -d ${user_homedirectory_path[$i]} ]; then\n\t\t\thomedirectory_owner_name=`ls -ld ${user_homedirectory_path[$i]} | awk '{print $3}'`\n\t\t\tif [[ $homedirectory_owner_name =~ ${user_homedirectory_owner_name[$i]} ]]; then\n\t\t\t\thomedirectory_other_permission=`stat ${user_homedirectory_path[$i]} | grep -i 'Uid' | awk '{print $2}' | awk -F / '{print substr($1,5,1)}'`\n\t\t\t\tif [ $homedirectory_other_permission -eq 7 ] || [ $homedirectory_other_permission -eq 6 ] || [ $homedirectory_other_permission -eq 3 ] || [ $homedirectory_other_permission -eq 2 ]; then\n\t\t\t\t\techo \"※ U-57 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\techo \" ${user_homedirectory_path[$i]} 홈 디렉터리에 다른 사용자(other)의 쓰기 권한이 부여되어 있습니다.\" >> $resultfile 2>&1\n\t\t\t\t\treturn 0\n\t\t\t\tfi\n\t\t\telse\n\t\t\t\techo \"※ U-57 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\techo \" ${user_homedirectory_path[$i]} 홈 디렉터리의 소유자가 ${user_homedirectory_owner_name[$i]}이(가) 아닙니다.\" >> $resultfile 2>&1\n\t\t\t\treturn 0\n\t\t\tfi\n\t\tfi\n\tdone\n\techo \"※ U-57 결과 : 양호(Good)\" >> $resultfile 2>&1\n\treturn 0\n}\n\nU_58() {\n\techo \"\"  >> $resultfile 2>&1\n\techo \"▶ U-58(중) | 2. 파일 및 디렉토리 관리 > 2.19 홈디렉토리로 지정한 디렉토리의 존재 관리 ◀\"  >> $resultfile 2>&1\n\techo \" 양호 판단 기준 : 홈 디렉터리가 존재하지 않는 계정이 발견되지 않는 경우\" >> $resultfile 2>&1\n\thomedirectory_null_count=`awk -F : '$7!=\"/bin/false\" && $7!=\"/sbin/nologin\" && $6==null' /etc/passwd | wc -l`\n\tif [ $homedirectory_null_count -gt 0 ]; then\n\t\techo \"※ U-58 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\techo \" 홈 디렉터리가 존재하지 않는 계정이 있습니다.\" >> $resultfile 2>&1\n\t\treturn 0\n\telse\n\t\thomedirectory_slash_count=`awk -F : '$7!=\"/bin/false\" && $7!=\"/sbin/nologin\" && $1!=\"root\" && $6==\"/\"' /etc/passwd | wc -l`\n\t\tif [ $homedirectory_slash_count -gt 0 ]; then\n\t\t\techo \"※ U-58 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\techo \" 관리자 계정(root)이 아닌데 홈 디렉터리가 '/'로 설정된 계정이 있습니다.\" >> $resultfile 2>&1\n\t\t\treturn 0\n\t\telse\n\t\t\techo \"※ U-58 결과 : 양호(Good)\" >> $resultfile 2>&1\n\t\t\treturn 0\n\t\tfi\n\tfi\n}\n\nU_59() {\n\techo \"\"  >> $resultfile 2>&1\n\techo \"▶ U-59(하) | 2. 파일 및 디렉토리 관리 > 2.20 숨겨진 파일 및 디렉토리 검색 및 제거 ◀\"  >> $resultfile 2>&1\n\techo \" 양호 판단 기준 : 불필요하거나 의심스러운 숨겨진 파일 및 디렉터리를 삭제한 경우\" >> $resultfile 2>&1\n\tif [ `find / -name '.*' -type f 2>/dev/null | wc -l` -gt 0 ]; then\n\t\techo \"※ U-59 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\techo \" 숨겨진 파일이 있습니다.\" >> $resultfile 2>&1\n\t\treturn 0\n\telif [ `find / -name '.*' -type d 2>/dev/null | wc -l` -gt 0 ]; then\n\t\techo \"※ U-59 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\techo \" 숨겨진 디렉터리가 있습니다.\" >> $resultfile 2>&1\n\t\treturn 0\n\telse\n\t\techo \"※ U-59 결과 : 양호(Good)\" >> $resultfile 2>&1$resultfile 2>&1\n\t\treturn 0\n\tfi\n}\n\nU_60() {\n\techo \"\"  >> $resultfile 2>&1\n\techo \"▶ U-60(중) | 3. 서비스 관리 > 3.24 ssh 원격접속 허용 ◀\"  >> $resultfile 2>&1\n\techo \" 양호 판단 기준 : 원격 접속 시 SSH 프로토콜을 사용하는 경우\" >> $resultfile 2>&1\n\techo \" ### ssh, telnet이 동시에 설치되어 있는 경우 취약한 것으로 평가됨\" >> $resultfile 2>&1\n\tif [ -f /etc/services ]; then\n\t\ttelnet_port_count=`grep -vE '^#|^\\s#' /etc/services | awk 'tolower($1)==\"telnet\" {print $2}' | awk -F / 'tolower($2)==\"tcp\" {print $1}' | wc -l`\n\t\tif [ $telnet_port_count -gt 0 ]; then\n\t\t\ttelnet_port=(`grep -vE '^#|^\\s#' /etc/services | awk 'tolower($1)==\"telnet\" {print $2}' | awk -F / 'tolower($2)==\"tcp\" {print $1}'`)\n\t\t\tfor ((i=0; i<${#telnet_port[@]}; i++))\n\t\t\tdo\n\t\t\t\tnetstat_telnet_count=`netstat -nat 2>/dev/null | grep -w 'tcp' | grep -Ei 'listen|established|syn_sent|syn_received' | grep \":${telnet_port[$i]} \" | wc -l`\n\t\t\t\tif [ $netstat_telnet_count -gt 0 ]; then\n\t\t\t\t\techo \"※ U-60 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\techo \" Telnet 서비스가 실행 중입니다.\" >> $resultfile 2>&1\n\t\t\t\t\treturn 0\n\t\t\t\tfi\n\t\t\tdone\n\t\tfi\n\t\tftp_port_count=`grep -vE '^#|^\\s#' /etc/services | awk 'tolower($1)==\"ftp\" {print $2}' | awk -F / 'tolower($2)==\"tcp\" {print $1}' | wc -l`\n\t\tif [ $ftp_port_count -gt 0 ]; then\n\t\t\tftp_port=(`grep -vE '^#|^\\s#' /etc/services | awk 'tolower($1)==\"ftp\" {print $2}' | awk -F / 'tolower($2)==\"tcp\" {print $1}'`)\n\t\t\tfor ((i=0; i<${#ftp_port[@]}; i++))\n\t\t\tdo\n\t\t\t\tnetstat_ftp_count=`netstat -nat 2>/dev/null | grep -w 'tcp' | grep -Ei 'listen|established|syn_sent|syn_received' | grep \":${ftp_port[$i]} \" | wc -l`\n\t\t\t\tif [ $netstat_ftp_count -gt 0 ]; then\n\t\t\t\t\techo \"※ U-60 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\techo \" ftp 서비스가 실행 중입니다.\" >> $resultfile 2>&1\n\t\t\t\t\treturn 0\n\t\t\t\tfi\n\t\t\tdone\n\t\tfi\n\tfi\n\tfind_vsftpdconf_count=`find / -name 'vsftpd.conf' -type f 2>/dev/null | wc -l`\n\tif [ $find_vsftpdconf_count -gt 0 ]; then\n\t\tvsftpdconf_files=(`find / -name 'vsftpd.conf' -type f 2>/dev/null`)\n\t\tfor ((i=0; i<${#vsftpdconf_files[@]}; i++))\n\t\tdo\n\t\t\tif [ -f ${vsftpdconf_files[$i]} ]; then\n\t\t\t\tvsftpdconf_file_port_count=`grep -vE '^#|^\\s#' ${vsftpdconf_files[$i]} | grep 'listen_port' | awk -F = '{gsub(\" \", \"\", $0); print $2}' | wc -l`\n\t\t\t\tif [ $vsftpdconf_file_port_count -gt 0 ]; then\n\t\t\t\t\ttelnet_port=(`grep -vE '^#|^\\s#' ${vsftpdconf_files[$i]} | grep 'listen_port' | awk -F = '{gsub(\" \", \"\", $0); print $2}'`)\n\t\t\t\t\tfor ((j=0; j<${#telnet_port[@]}; j++))\n\t\t\t\t\tdo\n\t\t\t\t\t\tif [ `netstat -nat 2>/dev/null | grep -w 'tcp' | grep -Ei 'listen|established|syn_sent|syn_received' | grep \":${telnet_port[$j]} \" | wc -l` -gt 0 ]; then\n\t\t\t\t\t\t\techo \"※ U-60 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\t\techo \" ftp 서비스가 실행 중입니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\t\treturn 0\n\t\t\t\t\t\tfi\n\t\t\t\t\tdone\n\t\t\t\tfi\n\t\t\tfi\n\t\tdone\n\tfi\n\tfind_proftpdconf_count=`find / -name 'proftpd.conf' -type f 2>/dev/null | wc -l`\n\tif [ $find_proftpdconf_count -gt 0 ]; then\n\t\tproftpdconf_files=(`find / -name 'proftpd.conf' -type f 2>/dev/null`)\n\t\tfor ((i=0; i<${#proftpdconf_files[@]}; i++))\n\t\tdo\n\t\t\tif [ -f ${proftpdconf_files[$i]} ]; then\n\t\t\t\tif [ `grep -vE '^#|^\\s#' ${proftpdconf_files[$i]} | grep 'Port' | awk '{print $2}' | wc -l` -gt 0 ]; then\n\t\t\t\t\ttelnet_port=(`grep -vE '^#|^\\s#' ${proftpdconf_files[$i]} | grep 'Port' | awk '{print $2}'`)\n\t\t\t\t\tfor ((j=0; j<${#telnet_port[@]}; j++))\n\t\t\t\t\tdo\n\t\t\t\t\t\tif [ `netstat -nat 2>/dev/null | grep -w 'tcp' | grep -Ei 'listen|established|syn_sent|syn_received' | grep \":${telnet_port[$j]} \" | wc -l` -gt 0 ]; then\n\t\t\t\t\t\t\techo \"※ U-60 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\t\techo \" ftp 서비스가 실행 중입니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\t\treturn 0\n\t\t\t\t\t\tfi\n\t\t\t\t\tdone\n\t\t\t\tfi\n\t\t\tfi\n\t\tdone\n\tfi\n\tps_telnet_count=`ps -ef | grep -i 'telnet' | grep -v 'grep' | wc -l`\n\tif [ $ps_telnet_count -gt 0 ]; then\n\t\techo \"※ U-60 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\techo \" Telnet 서비스가 실행 중입니다.\" >> $resultfile 2>&1\n\t\treturn 0\n\tfi\n\tps_ftp_count=`ps -ef | grep -i 'ftp' | grep -v 'grep' | wc -l`\n\tif [ $ps_ftp_count -gt 0 ]; then\n\t\techo \"※ U-60 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\techo \" ftp 서비스가 실행 중입니다.\" >> $resultfile 2>&1\n\t\treturn 0\n\tfi\n\tfind_sshdconfig_count=`find / -name 'sshd_config' -type f 2>/dev/null | wc -l`\n\tif [ $find_sshdconfig_count -gt 0 ]; then\n\t\tsshdconfig_files=(`find / -name 'sshd_config' -type f 2>/dev/null`)\n\t\tfor ((i=0; i<${#sshdconfig_files[@]}; i++))\n\t\tdo\n\t\t\tif [ -f ${sshdconfig_files[$i]} ]; then\n\t\t\t\tif [ `grep -vE '^#|^\\s#' ${sshdconfig_files[$i]} | grep -i 'Port' | awk '{print $2}' | wc -l` -gt 0 ]; then\n\t\t\t\t\tssh_port=(`grep -vE '^#|^\\s#' ${sshdconfig_files[$i]} | grep -i 'Port' | awk '{print $2}'`)\n\t\t\t\t\tfor ((j=0; j<${#ssh_port[@]}; j++))\n\t\t\t\t\tdo\n\t\t\t\t\t\tnetstat_ssh_count=`netstat -nat 2>/dev/null | grep -w 'tcp' | grep -Ei 'listen|established|syn_sent|syn_received' | grep \":${ssh_port[$j]} \" | wc -l`\n\t\t\t\t\t\tif [ $netstat_ssh_count -eq 0 ]; then\n\t\t\t\t\t\t\techo \"※ U-60 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\t\techo \" SSH 서비스가 비활성화 상태입니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\t\treturn 0\n\t\t\t\t\t\tfi\n\t\t\t\t\tdone\n\t\t\t\tfi\n\t\t\tfi\n\t\tdone\n\tfi\n\tps_ssh_count=`ps -ef | grep -i 'sshd' | grep -v 'grep' | wc -l`\n\tif [ $ps_ssh_count -eq 0 ]; then\n\t\techo \"※ U-60 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\techo \" SSH 서비스가 비활성화 상태입니다.\" >> $resultfile 2>&1\n\t\treturn 0\n\tfi\n\tdpkg_ssh_count=`dpkg -l 2>/dev/null | awk '{print $2}' | grep 'openssh' | wc -l`\n\tdpkg_telnet_count=`dpkg -l 2>/dev/null | awk '{print $2}' | grep 'telnet' | wc -l`\n\tif [ $dpkg_ssh_count -gt 0 ] && [ $dpkg_telnet_count -gt 0 ]; then\n\t\techo \"※ U-60 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\techo \" SSH 서비스와 Telnet 서비스가 동시에 설치되어 있습니다.\" >> $resultfile 2>&1\n\t\treturn 0\n\telse\n\t\techo \"※ U-60 결과 : 양호(Good)\" >> $resultfile 2>&1\n\t\treturn 0\n\tfi\n}\n\nU_61() {\n\techo \"\"  >> $resultfile 2>&1\n\techo \"▶ U-61(하) | 3. 서비스 관리 > 3.25 ftp 서비스 확인 ◀\"  >> $resultfile 2>&1\n\techo \" 양호 판단 기준 : FTP 서비스가 비활성화 되어 있는 경우\" >> $resultfile 2>&1\n\tif [ -f /etc/services ]; then\n\t\tftp_port_count=`grep -vE '^#|^\\s#' /etc/services | awk 'tolower($1)==\"ftp\" {print $2}' | awk -F / 'tolower($2)==\"tcp\" {print $1}' | wc -l`\n\t\tif [ $ftp_port_count -gt 0 ]; then\n\t\t\tftp_port=(`grep -vE '^#|^\\s#' /etc/services | awk 'tolower($1)==\"ftp\" {print $2}' | awk -F / 'tolower($2)==\"tcp\" {print $1}'`)\n\t\t\tfor ((i=0; i<${#ftp_port[@]}; i++))\n\t\t\tdo\n\t\t\t\tnetstat_ftp_count=`netstat -nat 2>/dev/null | grep -w 'tcp' | grep -Ei 'listen|established|syn_sent|syn_received' | grep \":${ftp_port[$i]} \" | wc -l`\n\t\t\t\tif [ $netstat_ftp_count -gt 0 ]; then\n\t\t\t\t\techo \"※ U-61 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\techo \" ftp 서비스가 실행 중입니다.\" >> $resultfile 2>&1\n\t\t\t\t\treturn 0\n\t\t\t\tfi\n\t\t\tdone\n\t\tfi\n\tfi\n\tfind_vsftpdconf_count=`find / -name 'vsftpd.conf' -type f 2>/dev/null | wc -l`\n\tif [ $find_vsftpdconf_count -gt 0 ]; then\n\t\tvsftpdconf_files=(`find / -name 'vsftpd.conf' -type f 2>/dev/null`)\n\t\tfor ((i=0; i<${#vsftpdconf_files[@]}; i++))\n\t\tdo\n\t\t\tif [ -f ${vsftpdconf_files[$i]} ]; then\n\t\t\t\tvsftpdconf_file_port_count=`grep -vE '^#|^\\s#' ${vsftpdconf_files[$i]} | grep 'listen_port' | awk -F = '{gsub(\" \", \"\", $0); print $2}' | wc -l`\n\t\t\t\tif [ $vsftpdconf_file_port_count -gt 0 ]; then\n\t\t\t\t\tftp_port=(`grep -vE '^#|^\\s#' ${vsftpdconf_files[$i]} | grep 'listen_port' | awk -F = '{gsub(\" \", \"\", $0); print $2}'`)\n\t\t\t\t\tfor ((j=0; j<${#ftp_port[@]}; j++))\n\t\t\t\t\tdo\n\t\t\t\t\t\tnetstat_ftp_count=`netstat -nat 2>/dev/null | grep -w 'tcp' | grep -Ei 'listen|established|syn_sent|syn_received' | grep \":${ftp_port[$j]} \" | wc -l`\n\t\t\t\t\t\tif [ $netstat_ftp_count -gt 0 ]; then\n\t\t\t\t\t\t\techo \"※ U-61 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\t\techo \" ftp 서비스가 실행 중입니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\t\treturn 0\n\t\t\t\t\t\tfi\n\t\t\t\t\tdone\n\t\t\t\tfi\n\t\t\tfi\n\t\tdone\n\tfi\n\tfind_proftpdconf_count=`find / -name 'proftpd.conf' -type f 2>/dev/null | wc -l`\n\tif [ $find_proftpdconf_count -gt 0 ]; then\n\t\tproftpdconf_files=(`find / -name 'proftpd.conf' -type f 2>/dev/null`)\n\t\tfor ((i=0; i<${#proftpdconf_files[@]}; i++))\n\t\tdo\n\t\t\tif [ -f ${proftpdconf_files[$i]} ]; then\n\t\t\t\tproftpdconf_file_port_count=`grep -vE '^#|^\\s#' ${proftpdconf_files[$i]} | grep 'Port' | awk '{print $2}' | wc -l`\n\t\t\t\tif [ $proftpdconf_file_port_count -gt 0 ]; then\n\t\t\t\t\tftp_port=(`grep -vE '^#|^\\s#' ${proftpdconf_files[$i]} | grep 'Port' | awk '{print $2}'`)\n\t\t\t\t\tfor ((j=0; j<${#ftp_port[@]}; j++))\n\t\t\t\t\tdo\n\t\t\t\t\t\tnetstat_ftp_count=`netstat -nat 2>/dev/null | grep -w 'tcp' | grep -Ei 'listen|established|syn_sent|syn_received' | grep \":${ftp_port[$j]} \" | wc -l`\n\t\t\t\t\t\tif [ $netstat_ftp_count -gt 0 ]; then\n\t\t\t\t\t\t\techo \"※ U-61 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\t\techo \" ftp 서비스가 실행 중입니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\t\treturn 0\n\t\t\t\t\t\tfi\n\t\t\t\t\tdone\n\t\t\t\tfi\n\t\t\tfi\n\t\tdone\n\tfi\n\tps_ftp_count=`ps -ef | grep -iE 'ftp|vsftpd|proftp' | grep -v 'grep' | wc -l`\n\tif [ $ps_ftp_count -gt 0 ]; then\n\t\techo \"※ U-61 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\techo \" ftp 서비스가 실행 중입니다.\" >> $resultfile 2>&1\n\t\treturn 0\n\telse\n\t\techo \"※ U-61 결과 : 양호(Good)\" >> $resultfile 2>&1\n\t\treturn 0\n\tfi\n}\n\nU_62() {\n\techo \"\"  >> $resultfile 2>&1\n\techo \"▶ U-62(중) | 3. 서비스 관리 > 3.26 ftp 계정 shell 제한 ◀\"  >> $resultfile 2>&1\n\techo \" 양호 판단 기준 : ftp 계정에 /bin/false 쉘이 부여되어 있는 경우\" >> $resultfile 2>&1\n\tif [ `awk -F : '$1==\"ftp\" && $7==\"/bin/false\"' /etc/passwd | wc -l` -gt 0 ]; then\n\t\techo \"※ U-62 결과 : 양호(Good)\" >> $resultfile 2>&1\n\t\treturn 0\n\telse\n\t\techo \"※ U-62 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\techo \" ftp 계정에 /bin/false 쉘이 부여되어 있지 않습니다.\" >> $resultfile 2>&1\n\t\treturn 0\n\tfi\n}\n\nU_63() {\n\techo \"\"  >> $resultfile 2>&1\n\techo \"▶ U-63(하) | 3. 서비스 관리 > 3.27 ftpusers 파일 소유자 및 권한 설정 ◀\"  >> $resultfile 2>&1\n\techo \" 양호 판단 기준 : ftpusers 파일의 소유자가 root이고, 권한이 640 이하인 경우\" >> $resultfile 2>&1\n\tfile_exists_count=0\n\tftpusers_files=(\"/etc/ftpusers\" \"/etc/pure-ftpd/ftpusers\" \"/etc/wu-ftpd/ftpusers\" \"/etc/vsftpd/ftpusers\" \"/etc/proftpd/ftpusers\" \"/etc/ftpd/ftpusers\" \"/etc/vsftpd.ftpusers\" \"/etc/vsftpd.user_list\" \"/etc/vsftpd/user_list\")\n\tfor ((i=0; i<${#ftpusers_files[@]}; i++))\n\tdo\n\t\tif [ -f ${ftpusers_files[$i]} ]; then\n\t\t\t((file_exists_count++))\n\t\t\tftpusers_file_owner_name=`ls -l ${ftpusers_files[$i]} | awk '{print $3}'`\n\t\t\tif [[ $ftpusers_file_owner_name =~ root ]]; then\n\t\t\t\tftpusers_file_permission=`stat ${ftpusers_files[$i]} | grep -i 'Uid' | awk '{print $2}' | awk -F / '{print substr($1,3,3)}'`\n\t\t\t\tif [ $ftpusers_file_permission -le 640 ]; then\n\t\t\t\t\tftpusers_file_owner_permission=`stat ${ftpusers_files[$i]} | grep -i 'Uid' | awk '{print $2}' | awk -F / '{print substr($1,3,1)}'`\n\t\t\t\t\tif [ $ftpusers_file_owner_permission -eq 6 ] || [ $ftpusers_file_owner_permission -eq 4 ] || [ $ftpusers_file_owner_permission -eq 2 ] || [ $ftpusers_file_owner_permission -eq 0 ]; then\n\t\t\t\t\t\tftpusers_file_group_permission=`stat ${ftpusers_files[$i]} | grep -i 'Uid' | awk '{print $2}' | awk -F / '{print substr($1,4,1)}'`\n\t\t\t\t\t\tif [ $ftpusers_file_group_permission -eq 4 ] || [ $ftpusers_file_group_permission -eq 0 ]; then\n\t\t\t\t\t\t\tftpusers_file_other_permission=`stat ${ftpusers_files[$i]} | grep -i 'Uid' | awk '{print $2}' | awk -F / '{print substr($1,5,1)}'`\n\t\t\t\t\t\t\tif [ $ftpusers_file_other_permission -ne 0 ]; then\n\t\t\t\t\t\t\t\techo \"※ U-63 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\t\t\techo \" ${ftpusers_files[$i]} 파일의 다른 사용자(other)에 대한 권한이 취약합니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\t\t\treturn 0\n\t\t\t\t\t\t\tfi\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\techo \"※ U-63 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\t\techo \" ${ftpusers_files[$i]} 파일의 그룹 사용자(group)에 대한 권한이 취약합니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\t\treturn 0\n\t\t\t\t\t\tfi\n\t\t\t\t\telse\n\t\t\t\t\t\techo \"※ U-63 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\techo \" ${ftpusers_files[$i]} 파일의 사용자(owner)에 대한 권한이 취약합니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\treturn 0\n\t\t\t\t\tfi\n\t\t\t\telse\n\t\t\t\t\techo \"※ U-63 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\techo \" ${ftpusers_files[$i]} 파일의 권한이 640보다 큽니다.\" >> $resultfile 2>&1\n\t\t\t\t\treturn 0\n\t\t\t\tfi\n\t\t\telse\n\t\t\t\techo \"※ U-63 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\techo \" ${ftpusers_files[$i]} 파일의 소유자(owner)가 root가 아닙니다.\" >> $resultfile 2>&1\n\t\t\t\treturn 0\n\t\t\tfi\n\t\tfi\n\tdone\n\tif [ $file_exists_count -eq 0 ]; then\n\t\techo \"※ U-63 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\techo \" ftp 접근제어 파일이 없습니다.\" >> $resultfile 2>&1\n\t\treturn 0\n\telse\n\t\techo \"※ U-63 결과 : 양호(Good)\" >> $resultfile 2>&1\n\t\treturn 0\n\tfi\n}\n\nU_64() {\n\techo \"\"  >> $resultfile 2>&1\n\techo \"▶ U-64(중) | 3. 서비스 관리 > 3.28 ftpusers 파일 설정(FTP 서비스 root 계정 접근제한) ◀\"  >> $resultfile 2>&1\n\techo \" 양호 판단 기준 : FTP 서비스가 비활성화 되어 있거나, 활성화 시 root 계정 접속을 차단한 경우\" >> $resultfile 2>&1\n\tftpusers_files=(\"/etc/ftpusers\" \"/etc/ftpd/ftpusers\" \"/etc/proftpd.conf\" \"/etc/vsftp/ftpusers\" \"/etc/vsftp/user_list\" \"/etc/vsftpd.ftpusers\" \"/etc/vsftpd.user_list\")\n\tftp_running_count=0 # ftp 서비스 실행 중일 때 카운트\n\tftpusers_file_exists_count=0 # ftpusers 파일 존재 시 카운트\n\tif [ -f /etc/services ]; then\n\t\tftp_port_count=`grep -vE '^#|^\\s#' /etc/services | awk -F \" \" 'tolower($1)==\"ftp\" {print $2}' | awk -F / 'tolower($2)==\"tcp\" {print $1}' | wc -l`\n\t\tif [ $ftp_port_count -gt 0 ]; then\n\t\t\tftp_port=(`grep -vE '^#|^\\s#' /etc/services | awk -F \" \" 'tolower($1)==\"ftp\" {print $2}' | awk -F / 'tolower($2)==\"tcp\" {print $1}'`)\n\t\t\tfor ((i=0; i<${#ftp_port[@]}; i++))\n\t\t\tdo\n\t\t\t\tnetstat_ftp_count=`netstat -nat 2>/dev/null | grep -w 'tcp' | grep -Ei 'listen|established|syn_sent|syn_received' | grep \":${ftp_port[$i]} \" | wc -l`\n\t\t\t\tif [ $netstat_ftp_count -gt 0 ]; then\n\t\t\t\t\t((ftp_running_count++))\n\t\t\t\t\tfor ((j=0; j<${#ftpusers_files[@]}; j++))\n\t\t\t\t\tdo\n\t\t\t\t\t\tif [ -f ${ftpusers_files[$j]} ]; then\n\t\t\t\t\t\t\t((ftpusers_file_exists_count++))\n\t\t\t\t\t\t\tif [[ ${ftpusers_files[$j]} =~ /etc/proftpd.conf ]]; then\n\t\t\t\t\t\t\t\tetc_proftpdconf_rootlogin_on_count=`grep -vE '^#|^\\s#' ${ftpusers_files[$j]} | grep -i 'RootLogin' | grep -i 'on' | wc -l`\n\t\t\t\t\t\t\t\tif [ $etc_proftpdconf_rootlogin_on_count -gt 0 ]; then\n\t\t\t\t\t\t\t\t\techo \"※ U-64 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\t\t\t\techo \" ${ftpusers_files[$j]} 파일에 'RootLogin on' 설정이 있습니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\t\t\t\treturn 0\n\t\t\t\t\t\t\t\tfi\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tftp_root_count=`grep -vE '^#|^\\s#' ${ftpusers_files[$j]} | grep -w 'root' | wc -l`\n\t\t\t\t\t\t\t\tif [ $ftp_root_count -eq 0 ]; then\n\t\t\t\t\t\t\t\t\techo \"※ U-64 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\t\t\t\techo \" ${ftpusers_files[$j]} 파일에 'root' 계정이 없습니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\t\t\t\treturn 0\n\t\t\t\t\t\t\t\tfi\n\t\t\t\t\t\t\tfi\n\t\t\t\t\t\tfi\n\t\t\t\t\tdone\n\t\t\t\tfi\n\t\t\tdone\n\t\tfi\n\tfi\n\tif [ $ftp_running_count -gt 0 ] && [ $ftpusers_file_exists_count -eq 0 ]; then\n\t\techo \"※ U-64 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\techo \" ftp 서비스를 사용하고, 'root' 계정의 접근을 제한할 파일이 없습니다.\" >> $resultfile 2>&1\n\t\treturn 0\n\tfi\n\tftp_running_count=0 # ftp 서비스 실행 중일 때 카운트\n\tftpusers_file_exists_count=0 # ftpusers 파일 존재 시 카운트\n\tps_ftp_count=`ps -ef | grep -iE 'ftp|vsftpd|proftp' | grep -v 'grep' | wc -l`\n\tif [ $ps_ftp_count -gt 0 ]; then\n\t\t((ftp_running_count++))\n\t\tfor ((i=0; i<${#ftpusers_files[@]}; i++))\n\t\tdo\n\t\t\tif [ -f ${ftpusers_files[$i]} ]; then\n\t\t\t\t((ftpusers_file_exists_count++))\n\t\t\t\tif [[ ${ftpusers_files[$i]} =~ /etc/proftpd.conf ]]; then\n\t\t\t\t\tetc_proftpdconf_rootlogin_on_count=`grep -vE '^#|^\\s#' ${ftpusers_files[$i]} | grep -i 'RootLogin' | grep -i 'on' | wc -l`\n\t\t\t\t\tif [ $etc_proftpdconf_rootlogin_on_count -gt 0 ]; then\n\t\t\t\t\t\techo \"※ U-64 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\techo \" ${ftpusers_files[$i]} 파일에 'RootLogin on' 설정이 있습니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\treturn 0\n\t\t\t\t\tfi\n\t\t\t\telse\n\t\t\t\t\tftp_root_count=`grep -vE '^#|^\\s#' ${ftpusers_files[$i]} | grep -w 'root' | wc -l`\n\t\t\t\t\tif [ $ftp_root_count -eq 0 ]; then\n\t\t\t\t\t\techo \"※ U-64 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\techo \" ${ftpusers_files[$i]} 파일에 'root' 계정이 없습니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\treturn 0\n\t\t\t\t\tfi\n\t\t\t\tfi\n\t\t\tfi\n\t\tdone\n\tfi\n\tif [ $ftp_running_count -gt 0 ] && [ $ftpusers_file_exists_count -eq 0 ]; then\n\t\techo \"※ U-64 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\techo \" ftp 서비스를 사용하고, 'root' 계정의 접근을 제한할 파일이 없습니다.\" >> $resultfile 2>&1\n\t\treturn 0\n\tfi\n\techo \"※ U-64 결과 : 양호(Good)\" >> $resultfile 2>&1\n\treturn 0\n}\n\nU_65() {\n\techo \"\"  >> $resultfile 2>&1\n\techo \"▶ U-65(중) | 3. 서비스 관리 > 3.29 at 서비스 권한 설정 ◀\"  >> $resultfile 2>&1\n\techo \" 양호 판단 기준 : at 명령어 일반사용자 금지 및 at 관련 파일 640 이하인 경우\" >> $resultfile 2>&1\n\tuser_homedirectory_path=(`awk -F : '$7!=\"/bin/false\" && $7!=\"/sbin/nologin\" && $6!=null {print $6}' /etc/passwd | uniq`) # /etc/passwd 파일에 설정된 홈 디렉터리 배열 생성\n\tuser_homedirectory_path2=(/home/*) # /home 디렉터래 내 위치한 홈 디렉터리 배열 생성\n\tfor ((i=0; i<${#user_homedirectory_path2[@]}; i++))\n\tdo\n\t\tuser_homedirectory_path[${#user_homedirectory_path[@]}]=${user_homedirectory_path2[$i]} # 두 개의 배열 합침\n\tdone\n\tpath_setting_files=(\".profile\" \".cshrc\" \".login\" \".kshrc\" \".bash_profile\" \".bashrc\" \".bash_login\")\n\tpath=(`echo $PATH | awk -F : '{for (i=1; i<=NF; i++) {print $i}}'`)\n\tfor ((i=0; i<${#user_homedirectory_path[@]}; i++))\n\tdo\n\t\tfor ((j=0; j<${#path_setting_files[@]}; j++))\n\t\tdo\n\t\t\tif [ -f ${user_homedirectory_path[$i]}/${path_setting_files[$j]} ]; then\n\t\t\t\tuser_homedirectory_path_count=`grep -i 'path' ${user_homedirectory_path[$i]}/${path_setting_files[$j]} | wc -l`\n\t\t\t\tif [ $user_homedirectory_path_count -gt 0 ]; then\n\t\t\t\t\tpath_setting_file_in_path=(`grep -i 'PATH' ${user_homedirectory_path[$i]}/${path_setting_files[$j]} | awk -F \\\" '{print $2}' | awk -F : '{for (l=1;l<=NF;l++) {print $l}}'`)\n\t\t\t\t\tfor ((k=0; k<${#path_setting_file_in_path[@]}; k++))\n\t\t\t\t\tdo\n\t\t\t\t\t\tif [[ ${path_setting_file_in_path[$k]} != \\$PATH ]]; then\n\t\t\t\t\t\t\tif [[ ${path_setting_file_in_path[$k]} == \\$HOME* ]]; then\n\t\t\t\t\t\t\t\tpath_setting_file_in_path[$k]=$(echo ${path_setting_file_in_path[$k]} | awk -v u65_awk=${user_homedirectory_path[i]} '{gsub(\"\\\\$HOME\",u65_awk,$0)} 1')\n\t\t\t\t\t\t\tfi\n\t\t\t\t\t\t\tpath[${#path[@]}]=${path_setting_file_in_path[$k]}\n\t\t\t\t\t\tfi\n\t\t\t\t\tdone\n\t\t\t\tfi\n\t\t\tfi\n\t\tdone\n\tdone\n\tfor ((i=0; i<${#path[@]}; i++))\n\tdo\n\t\tif [ -f ${path[$i]}/at ]; then\n\t\t\tat_file_group_permission=`stat ${path[$i]}/at | grep -i 'Uid' | awk '{print $2}' | awk -F / '{print substr($1,4,1)}'`\n\t\t\tif [ $at_file_group_permission -eq 5 ] || [ $at_file_group_permission -eq 4 ] || [ $at_file_group_permission -eq 1 ] || [ $at_file_group_permission -eq 0 ]; then\n\t\t\t\tat_file_other_permission=`stat ${path[$i]}/at | grep -i 'Uid' | awk '{print $2}' | awk -F / '{print substr($1,5,1)}'`\n\t\t\t\tif [ $at_file_other_permission -ne 0 ]; then\n\t\t\t\t\techo \"※ U-65 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\techo \" ${path[$i]}/at 실행 파일이 다른 사용자(other)에 의해 실행이 가능합니다.\" >> $resultfile 2>&1\n\t\t\t\t\treturn 0\n\t\t\t\tfi\n\t\t\telse\n\t\t\t\techo \"※ U-65 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\techo \" ${path[$i]}/at 실행 파일의 그룹 사용자(group)에 대한 권한이 취약합니다.\" >> $resultfile 2>&1\n\t\t\t\treturn 0\n\t\t\tfi\n\t\tfi\n\tdone\n\tat_access_control_files=(\"/etc/at.allow\" \"/etc/at.deny\")\n\tfor ((i=0; i<${#at_access_control_files[@]}; i++))\n\tdo\n\t\tif [ -f ${at_access_control_files[$i]} ]; then\n\t\t\tat_file_owner_name=`ls -l ${at_access_control_files[$i]} | awk '{print $3}'`\n\t\t\tif [[ $at_file_owner_name =~ root ]]; then\n\t\t\t\tat_file_permission=`stat ${at_access_control_files[$i]} | grep -i 'Uid' | awk '{print $2}' | awk -F / '{print substr($1,3,3)}'`\n\t\t\t\tif [ $at_file_permission -le 640 ]; then\n\t\t\t\t\tat_file_owner_permission=`stat ${at_access_control_files[$i]} | grep -i 'Uid' | awk '{print $2}' | awk -F / '{print substr($1,3,1)}'`\n\t\t\t\t\tif [ $at_file_owner_permission -eq 6 ] || [ $at_file_owner_permission -eq 4 ] || [ $at_file_owner_permission -eq 2 ] || [ $at_file_owner_permission -eq 0 ]; then\n\t\t\t\t\t\tat_file_group_permission=`stat ${at_access_control_files[$i]} | grep -i 'Uid' | awk '{print $2}' | awk -F / '{print substr($1,4,1)}'`\n\t\t\t\t\t\tif [ $at_file_group_permission -eq 4 ] || $at_file_owner_permission -eq 0 ]; then\n\t\t\t\t\t\t\tat_file_other_permission=`stat ${at_access_control_files[$i]} | grep -i 'Uid' | awk '{print $2}' | awk -F / '{print substr($1,5,1)}'`\n\t\t\t\t\t\t\tif [ $at_file_other_permission -ne 0 ]; then\n\t\t\t\t\t\t\t\techo \"※ U-65 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\t\t\techo \" ${at_access_control_files[$i]} 파일의 다른 사용자(other)에 대한 권한이 취약합니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\t\t\treturn 0\n\t\t\t\t\t\t\tfi\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\techo \"※ U-65 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\t\techo \" ${at_access_control_files[$i]} 파일의 그룹 사용자(group)에 대한 권한이 취약합니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\t\treturn 0\n\t\t\t\t\t\tfi\n\t\t\t\t\telse\n\t\t\t\t\t\techo \"※ U-65 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\techo \" ${at_access_control_files[$i]} 파일의 사용자(owner)에 대한 권한이 취약합니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\treturn 0\n\t\t\t\t\tfi\n\t\t\t\telse\n\t\t\t\t\techo \"※ U-65 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\techo \" ${at_access_control_files[$i]} 파일의 권한이 640보다 큽니다.\" >> $resultfile 2>&1\n\t\t\t\t\treturn 0\n\t\t\t\tfi\n\t\t\telse\n\t\t\t\techo \"※ U-65 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\techo \" ${at_access_control_files[$i]} 파일의 소유자(owner)가 root가 아닙니다.\" >> $resultfile 2>&1\n\t\t\t\treturn 0\n\t\t\tfi\n\t\tfi\n\tdone\n\techo \"※ U-65 결과 : 양호(Good)\" >> $resultfile 2>&1\n\treturn 0\n}\n\nU_66() {\n\techo \"\"  >> $resultfile 2>&1\n\techo \"▶ U-66(중) | 3. 서비스 관리 > 3.30 SNMP 서비스 구동 점검 ◀\"  >> $resultfile 2>&1\n\techo \" 양호 판단 기준 : SNMP 서비스를 사용하지 않는 경우\" >> $resultfile 2>&1\n\tif [ `ps -ef | grep -i 'snmp' | grep -v 'grep' | wc -l` -gt 0 ]; then\n\t\techo \"※ U-66 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\techo \" SNMP 서비스를 사용하고 있습니다.\" >> $resultfile 2>&1\n\t\treturn 0\n\telse\n\t\techo \"※ U-66 결과 : 양호(Good)\" >> $resultfile 2>&1\n\t\treturn 0\n\tfi\n}\n\nU_67() {\n\techo \"\"  >> $resultfile 2>&1\n\techo \"▶ U-67(중) | 3. 서비스 관리 > 3.31 SNMP 서비스 Community String의 복잡성 설정 ◀\"  >> $resultfile 2>&1\n\techo \" 양호 판단 기준 : SNMP Community 이름이 public, private 이 아닌 경우\" >> $resultfile 2>&1\n\tps_snmp_count=`ps -ef | grep -i 'snmp' | grep -v 'grep' | wc -l`\n\tif [ $ps_snmp_count -gt 0 ]; then\n\t\tfind_snmpdconf_count=`find / -name 'snmpd.conf' -type f 2>/dev/null | wc -l`\n\t\tif [ $find_snmpdconf_count -gt 0 ]; then\n\t\t\tsnmpdconf_files=(`find / -name 'snmpd.conf' -type f 2>/dev/null`)\n\t\t\tfor ((i=0; i<${#snmpdconf_files[@]}; i++))\n\t\t\tdo\n\t\t\t\tsnmpconf_public_private_count=`grep -vE '^#|^\\s#' ${snmpdconf_files[$i]} | grep -iE 'public|private' | wc -l`\n\t\t\t\tif [ $snmpconf_public_private_count -gt 0 ]; then\n\t\t\t\t\techo \"※ U-67 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\techo \" SNMP Community String이 public 또는 private으로 설정되어 있습니다.\" >> $resultfile 2>&1\n\t\t\t\t\treturn 0\n\t\t\t\tfi\n\t\t\tdone\n\t\telse\n\t\t\techo \"※ U-67 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\techo \" SNMP 서비스를 사용하고, Community String을 설정하는 파일이 없습니다.\" >> $resultfile 2>&1\n\t\t\treturn 0\n\t\tfi\n\tfi\n\techo \"※ U-67 결과 : 양호(Good)\" >> $resultfile 2>&1\n\treturn 0\n}\n\nU_68() {\n\techo \"\"  >> $resultfile 2>&1\n\techo \"▶ U-68(하) | 3. 서비스 관리 > 3.32 로그온 시 경고 메시지 제공 ◀\"  >> $resultfile 2>&1\n\techo \" 양호 판단 기준 : 서버 및 Telnet, FTP, SMTP, DNS 서비스에 로그온 메시지가 설정되어 있는 경우\" >> $resultfile 2>&1\n\techo \" ### DNS 배너의 경우 '/etc/named.conf' 또는 '/var/named' 파일을 수동으로 점검하세요.\" >> $resultfile 2>&1\n\tif [ -f /etc/motd ]; then\n\t\tif [ `grep -vE '^ *#|^$' /etc/motd | wc -l` -eq 0 ]; then\n\t\t\techo \"※ U-68 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\techo \" /etc/motd 파일에 로그온 메시지를 설정하지 않았습니다.\" >> $resultfile 2>&1\n\t\t\treturn 0\n\t\tfi\n\telse\n\t\techo \"※ U-68 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\techo \" /etc/motd 파일이 없습니다.\" >> $resultfile 2>&1\n\t\treturn 0\n\tfi\n\tif [ -f /etc/services ]; then\n\t\ttelnet_port_count=`grep -vE '^#|^\\s#' /etc/services | awk 'tolower($1)==\"telnet\" {print $2}' | awk -F / 'tolower($2)==\"tcp\" {print $1}' | wc -l`\n\t\tif [ $telnet_port_count -gt 0 ]; then\n\t\t\ttelnet_port=(`grep -vE '^#|^\\s#' /etc/services | awk 'tolower($1)==\"telnet\" {print $2}' | awk -F / 'tolower($2)==\"tcp\" {print $1}'`)\n\t\t\tfor ((i=0; i<${#telnet_port[@]}; i++))\n\t\t\tdo\n\t\t\t\tnetstat_telnet_count=`netstat -nat 2>/dev/null | grep -w 'tcp' | grep -Ei 'listen|established|syn_sent|syn_received' | grep \":${telnet_port[$i]} \" | wc -l`\n\t\t\t\tif [ $netstat_telnet_count -gt 0 ]; then\n\t\t\t\t\tif [ -f /etc/issue.net ]; then\n\t\t\t\t\t\tif [ `grep -vE '^ *#|^$' /etc/issue.net | wc -l` -eq 0 ]; then\n\t\t\t\t\t\t\techo \"※ U-68 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\t\techo \" telnet 서비스를 사용하고, /etc/issue.net 파일에 로그온 메시지를 설정하지 않았습니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\t\treturn 0\n\t\t\t\t\t\tfi\n\t\t\t\t\telse\n\t\t\t\t\t\techo \"※ U-68 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\techo \" telnet 서비스를 사용하고, /etc/issue.net 파일이 없습니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\treturn 0\n\t\t\t\t\tfi\n\t\t\t\tfi\n\t\t\tdone\n\t\tfi\n\tfi\n\tps_telnet_count=`ps -ef | grep -i 'telnet' | grep -v 'grep' | wc -l`\n\tif [ $ps_telnet_count -gt 0 ]; then\n\t\tif [ -f /etc/issue.net ]; then\n\t\t\tif [ `grep -vE '^ *#|^$' /etc/issue.net | wc -l` -eq 0 ]; then\n\t\t\t\techo \"※ U-68 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\techo \" telnet 서비스를 사용하고, /etc/issue.net 파일에 로그온 메시지를 설정하지 않았습니다.\" >> $resultfile 2>&1\n\t\t\t\treturn 0\n\t\t\tfi\n\t\telse\n\t\t\techo \"※ U-68 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\techo \" telnet 서비스를 사용하고, /etc/issue.net 파일이 없습니다.\" >> $resultfile 2>&1\n\t\t\treturn 0\n\t\tfi\n\tfi\n\tif [ -f /etc/services ]; then\n\t\tftp_port_count=`grep -vE '^#|^\\s#' /etc/services | awk 'tolower($1)==\"ftp\" {print $2}' | awk -F / 'tolower($2)==\"tcp\" {print $1}' | wc -l`\n\t\tif [ $ftp_port_count -gt 0 ]; then\n\t\t\tftp_port=(`grep -vE '^#|^\\s#' /etc/services | awk 'tolower($1)==\"ftp\" {print $2}' | awk -F / 'tolower($2)==\"tcp\" {print $1}'`)\n\t\t\tfor ((i=0; i<${#ftp_port[@]}; i++))\n\t\t\tdo\n\t\t\t\tnetstat_ftp_count=`netstat -nat 2>/dev/null | grep -w 'tcp' | grep -Ei 'listen|established|syn_sent|syn_received' | grep \":${ftp_port[$i]} \" | wc -l`\n\t\t\t\tif [ $netstat_ftp_count -gt 0 ]; then\n\t\t\t\t\tftpdconf_file_exists_count=0\n\t\t\t\t\tif [ -f /etc/vsftpd.conf ]; then\n\t\t\t\t\t\t((ftpdconf_file_exists_count++))\n\t\t\t\t\t\tvsftpdconf_banner_count=`grep -vE '^#|^\\s#' /etc/vsftpd.conf | grep 'ftpd_banner' | awk -F = '$2!=\" \" {print $2}' | wc -l`\n\t\t\t\t\t\tif [ $vsftpdconf_banner_count -eq 0 ]; then\n\t\t\t\t\t\t\techo \"※ U-68 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\t\techo \" ftp 서비스를 사용하고, /etc/vsftpd.conf 파일에 로그온 메시지를 설정하지 않았습니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\t\treturn 0\n\t\t\t\t\t\tfi\n\t\t\t\t\tfi\n\t\t\t\t\tif [ -f /etc/proftpd/proftpd.conf ]; then\n\t\t\t\t\t\t((ftpdconf_file_exists_count++))\n\t\t\t\t\t\tproftpdconf_banner_count=`grep -vE '^#|^\\s#' /etc/proftpd/proftpd.conf | grep 'ServerIdent' | wc -l`\n\t\t\t\t\t\tif [ $proftpdconf_banner_count -eq 0 ]; then\n\t\t\t\t\t\t\techo \"※ U-68 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\t\techo \" ftp 서비스를 사용하고, /etc/proftpd/proftpd.conf 파일에 로그온 메시지를 설정하지 않았습니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\t\treturn 0\n\t\t\t\t\t\tfi\n\t\t\t\t\tfi\n\t\t\t\t\tif [ -f /etc/pure-ftpd/conf/WelcomeMsg ]; then\n\t\t\t\t\t\t((ftpdconf_file_exists_count++))\n\t\t\t\t\t\tpureftpd_conf_banner_count=`grep -vE '^ *#|^$' /etc/pure-ftpd/conf/WelcomeMsg | wc -l`\n\t\t\t\t\t\tif [ $pureftpd_conf_banner_count -eq 0 ]; then\n\t\t\t\t\t\t\techo \"※ U-68 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\t\techo \" ftp 서비스를 사용하고, /etc/pure-ftpd/conf/WelcomeMsg 파일에 로그온 메시지를 설정하지 않았습니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\t\treturn 0\n\t\t\t\t\t\tfi\n\t\t\t\t\tfi\n\t\t\t\t\tif [ $ftpdconf_file_exists_count -eq 0 ]; then\n\t\t\t\t\t\techo \"※ U-68 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\techo \" ftp 서비스를 사용하고, 로그온 메시지를 설정하는 파일이 없습니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\treturn 0\n\t\t\t\t\tfi\n\t\t\t\t\t\n\t\t\t\tfi\n\t\t\tdone\n\t\tfi\n\tfi\n\tps_ftp_count=`ps -ef | grep -i 'ftp' | grep -vE 'grep|tftp|sftp' | wc -l`\n\tif [ $ps_ftp_count -gt 0 ]; then\n\t\tftpdconf_file_exists_count=0\n\t\tif [ -f /etc/vsftpd.conf ]; then\n\t\t\t((ftpdconf_file_exists_count++))\n\t\t\tvsftpdconf_banner_count=`grep -vE '^#|^\\s#' /etc/vsftpd.conf | grep 'ftpd_banner' | awk -F = '$2!=\" \" {print $2}' | wc -l`\n\t\t\tif [ $vsftpdconf_banner_count -eq 0 ]; then\n\t\t\t\techo \"※ U-68 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\techo \" ftp 서비스를 사용하고, /etc/vsftpd.conf 파일에 로그온 메시지를 설정하지 않았습니다.\" >> $resultfile 2>&1\n\t\t\t\treturn 0\n\t\t\tfi\n\t\tfi\n\t\tif [ -f /etc/proftpd/proftpd.conf ]; then\n\t\t\t((ftpdconf_file_exists_count++))\n\t\t\tproftpdconf_banner_count=`grep -vE '^#|^\\s#' /etc/proftpd/proftpd.conf | grep 'ServerIdent' | wc -l`\n\t\t\tif [ $proftpdconf_banner_count -eq 0 ]; then\n\t\t\t\techo \"※ U-68 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\techo \" ftp 서비스를 사용하고, /etc/proftpd/proftpd.conf 파일에 로그온 메시지를 설정하지 않았습니다.\" >> $resultfile 2>&1\n\t\t\t\treturn 0\n\t\t\tfi\n\t\tfi\n\t\tif [ -f /etc/pure-ftpd/conf/WelcomeMsg ]; then\n\t\t\t((ftpdconf_file_exists_count++))\n\t\t\tpureftpd_conf_banner_count=`grep -vE '^ *#|^$' /etc/pure-ftpd/conf/WelcomeMsg | wc -l`\n\t\t\tif [ $pureftpd_conf_banner_count -eq 0 ]; then\n\t\t\t\techo \"※ U-68 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\techo \" ftp 서비스를 사용하고, /etc/pure-ftpd/conf/WelcomeMsg 파일에 로그온 메시지를 설정하지 않았습니다.\" >> $resultfile 2>&1\n\t\t\t\treturn 0\n\t\t\tfi\n\t\tfi\n\t\tif [ $ftpdconf_file_exists_count -eq 0 ]; then\n\t\t\techo \"※ U-68 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\techo \" ftp 서비스를 사용하고, 로그온 메시지를 설정하는 파일이 없습니다.\" >> $resultfile 2>&1\n\t\t\treturn 0\n\t\tfi\n\tfi\n\tif [ -f /etc/services ]; then\n\t\tsmtp_port_count=`grep -vE '^#|^\\s#' /etc/services | awk 'tolower($1)==\"smtp\" {print $2}' | awk -F / 'tolower($2)==\"tcp\" {print $1}' | wc -l`\n\t\tif [ $smtp_port_count -gt 0 ]; then\n\t\t\tsmtp_port=(`grep -vE '^#|^\\s#' /etc/services | awk 'tolower($1)==\"smtp\" {print $2}' | awk -F / 'tolower($2)==\"tcp\" {print $1}'`)\n\t\t\tfor ((i=0; i<${#smtp_port[@]}; i++))\n\t\t\tdo\n\t\t\t\tnetstat_smtp_count=`netstat -nat 2>/dev/null | grep -w 'tcp' | grep -Ei 'listen|established|syn_sent|syn_received' | grep \":${smtp_port[$i]} \" | wc -l`\n\t\t\t\tif [ $netstat_smtp_count -gt 0 ]; then\n\t\t\t\t\tfind_sendmailcf_count=`find / -name 'sendmail.cf' -type f 2>/dev/null | wc -l`\n\t\t\t\t\tif [ $find_sendmailcf_count -gt 0 ]; then\n\t\t\t\t\t\tsendmailcf_files=(`find / -name 'sendmail.cf' -type f 2>/dev/null`)\n\t\t\t\t\t\tfor ((j=0; j<${#sendmailcf_files[@]}; j++))\n\t\t\t\t\t\tdo\n\t\t\t\t\t\t\tsendmailcf_banner_count=`grep -vE '^#|^\\s#' ${sendmailcf_files[$j]} | grep 'Smtp' | grep 'GreetingMessage' | awk -F = '{gsub(\" \", \"\", $0); print $2}' | wc -l`\n\t\t\t\t\t\t\tif [ $sendmailcf_banner_count -eq 0 ]; then\n\t\t\t\t\t\t\t\techo \"※ U-68 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\t\t\techo \" smtp 서비스를 사용하고, ${sendmailcf_files[$j]} 파일에 로그온 메시지를 설정하지 않았습니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\t\t\treturn 0\n\t\t\t\t\t\t\tfi\n\t\t\t\t\t\tdone\n\t\t\t\t\telse\n\t\t\t\t\t\techo \"※ U-68 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\techo \" smtp 서비스를 사용하고, 로그온 메시지를 설정하는 파일이 없습니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\treturn 0\n\t\t\t\t\tfi\n\t\t\t\tfi\n\t\t\tdone\n\t\tfi\n\tfi\n\tps_smtp_count=`ps -ef | grep -iE 'smtp|sendmail' | grep -v 'grep' | wc -l`\n\tif [ $ps_smtp_count -gt 0 ]; then\n\t\tfind_sendmailcf_count=`find / -name 'sendmail.cf' -type f 2>/dev/null | wc -l`\n\t\tif [ $find_sendmailcf_count -gt 0 ]; then\n\t\t\tsendmailcf_files=(`find / -name 'sendmail.cf' -type f 2>/dev/null`)\n\t\t\tfor ((i=0; i<${#sendmailcf_files[@]}; i++))\n\t\t\tdo\n\t\t\t\tsendmailcf_banner_count=`grep -vE '^#|^\\s#' ${sendmailcf_files[$i]} | grep 'Smtp' | grep 'GreetingMessage' | awk -F = '{gsub(\" \", \"\", $0); print $2}' | wc -l`\n\t\t\t\tif [ $sendmailcf_banner_count -eq 0 ]; then\n\t\t\t\t\techo \"※ U-68 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\techo \" smtp 서비스를 사용하고, ${sendmailcf_files[$i]} 파일에 로그온 메시지를 설정하지 않았습니다.\" >> $resultfile 2>&1\n\t\t\t\t\treturn 0\n\t\t\t\tfi\n\t\t\tdone\n\t\telse\n\t\t\techo \"※ U-68 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\techo \" smtp 서비스를 사용하고, 로그온 메시지를 설정하는 파일이 없습니다.\" >> $resultfile 2>&1\n\t\t\treturn 0\n\t\tfi\n\tfi\n\techo \"※ U-68 결과 : 양호(Good)\" >> $resultfile 2>&1\n\treturn 0\n}\n\nU_69() {\n\techo \"\"  >> $resultfile 2>&1\n\techo \"▶ U-69(중) | 3. 서비스 관리 > 3.33 NFS 설정파일 접근권한 ◀\"  >> $resultfile 2>&1\n\techo \" 양호 판단 기준 : NFS 접근제어 설정파일의 소유자가 root 이고, 권한이 644 이하인 경우\" >> $resultfile 2>&1\n\tif [ -f /etc/exports ]; then\n\t\tetc_exports_owner_name=`ls -l /etc/exports | awk '{print $3}'`\n\t\tif [[ $etc_exports_owner_name =~ root ]]; then\n\t\t\tetc_exports_permission=`stat /etc/exports | grep -i 'Uid' | awk '{print $2}' | awk -F / '{print substr($1,3,3)}'`\n\t\t\tif [ $etc_exports_permission -le 644 ]; then\n\t\t\t\tetc_exports_owner_permission=`stat /etc/exports | grep -i 'Uid' | awk '{print $2}' | awk -F / '{print substr($1,3,1)}'`\n\t\t\t\tif [ $etc_exports_owner_permission -eq 6 ] || [ $etc_exports_owner_permission -eq 4 ] || [ $etc_exports_owner_permission -eq 2 ] || [ $etc_exports_owner_permission -eq 0 ]; then\n\t\t\t\t\tetc_exports_group_permission=`stat /etc/exports | grep -i 'Uid' | awk '{print $2}' | awk -F / '{print substr($1,4,1)}'`\n\t\t\t\t\tif [ $etc_exports_group_permission -eq 4 ] || [ $etc_exports_group_permission -eq 0 ]; then\n\t\t\t\t\t\tetc_exports_other_permission=`stat /etc/exports | grep -i 'Uid' | awk '{print $2}' | awk -F / '{print substr($1,5,1)}'`\n\t\t\t\t\t\tif [ $etc_exports_other_permission -eq 4 ] || [ $etc_exports_other_permission -eq 0 ]; then\n\t\t\t\t\t\t\techo \"※ U-69 결과 : 양호(Good)\" >> $resultfile 2>&1\n\t\t\t\t\t\t\treturn 0\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\techo \"※ U-69 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\t\techo \" /etc/exports 파일의 다른 사용자(other)에 대한 권한이 취약합니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\t\treturn 0\n\t\t\t\t\t\tfi\n\t\t\t\t\telse\n\t\t\t\t\t\techo \"※ U-69 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\techo \" /etc/exports 파일의 그룹 사용자(group)에 대한 권한이 취약합니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\treturn 0\n\t\t\t\t\tfi\n\t\t\t\telse\n\t\t\t\t\techo \"※ U-69 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\techo \" /etc/exports 파일의 사용자(owner)에 대한 권한이 취약합니다.\" >> $resultfile 2>&1\n\t\t\t\t\treturn 0\n\t\t\t\tfi\n\t\t\telse\n\t\t\t\techo \"※ U-69 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\techo \" /etc/exports 파일의 권한이 644보다 큽니다.\" >> $resultfile 2>&1\n\t\t\t\treturn 0\n\t\t\tfi\n\t\telse\n\t\t\techo \"※ U-69 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\techo \" /etc/exports 파일의 소유자(owner)가 root가 아닙니다.\" >> $resultfile 2>&1\n\t\t\treturn 0\n\t\tfi\n\telse\n\t\techo \"※ U-69 결과 : N/A\" >> $resultfile 2>&1\n\t\techo \" /etc/exports 파일이 없습니다.\" >> $resultfile 2>&1\n\t\treturn 0\n\tfi\n}\n\nU_70() {\n\techo \"\"  >> $resultfile 2>&1\n\techo \"▶ U-70(중) | 3. 서비스 관리 > 3.34 expn, vrfy 명령어 제한 ◀\"  >> $resultfile 2>&1\n\techo \" 양호 판단 기준 : SMTP 서비스 미사용 또는, noexpn, novrfy 옵션이 설정되어 있는 경우\" >> $resultfile 2>&1\n\tif [ -f /etc/services ]; then\n\t\tsmtp_port_count=`grep -vE '^#|^\\s#' /etc/services | awk 'tolower($1)==\"smtp\" {print $2}' | awk -F / 'tolower($2)==\"tcp\" {print $1}' | wc -l`\n\t\tif [ $smtp_port_count -gt 0 ]; then\n\t\t\tsmtp_port=(`grep -vE '^#|^\\s#' /etc/services | awk 'tolower($1)==\"smtp\" {print $2}' | awk -F / 'tolower($2)==\"tcp\" {print $1}'`)\n\t\t\tfor ((i=0; i<${#smtp_port[@]}; i++))\n\t\t\tdo\n\t\t\t\tnetstat_smtp_count=`netstat -nat 2>/dev/null | grep -w 'tcp' | grep -Ei 'listen|established|syn_sent|syn_received' | grep \":${smtp_port[$i]} \" | wc -l`\n\t\t\t\tif [ $netstat_smtp_count -gt 0 ]; then\n\t\t\t\t\tfind_sendmailcf_count=`find / -name 'sendmail.cf' -type f 2>/dev/null | wc -l`\n\t\t\t\t\tif [ $find_sendmailcf_count -gt 0 ]; then\n\t\t\t\t\t\tsendmailcf_files=(`find / -name 'sendmail.cf' -type f 2>/dev/null`)\n\t\t\t\t\t\tfor ((j=0; j<${#sendmailcf_files[@]}; j++))\n\t\t\t\t\t\tdo\n\t\t\t\t\t\t\tsendmailcf_goaway_count=`grep -vE '^#|^\\s#' ${sendmailcf_files[$j]} | grep -i 'PrivacyOptions' | grep -i 'goaway' | wc -l`\n\t\t\t\t\t\t\tsendmailcf_noexpnt_novrfy_count=`grep -vE '^#|^\\s#' ${sendmailcf_files[$j]} | grep -i 'PrivacyOptions' | grep -i 'noexpn' | grep -i 'novrfy' | wc -l`\n\t\t\t\t\t\t\tif [ $sendmailcf_goaway_count -eq 0 ] && [ $sendmailcf_noexpnt_novrfy_count -eq 0 ]; then\n\t\t\t\t\t\t\t\techo \"※ U-70 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\t\t\techo \" ${sendmailcf_files[$j]} 파일에 noexpn, novrfy 또는 goaway 설정이 없습니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\t\t\treturn 0\n\t\t\t\t\t\t\tfi\n\t\t\t\t\t\tdone\n\t\t\t\t\telse\n\t\t\t\t\t\techo \"※ U-70 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\techo \" noexpn, novrfy 또는 goaway 옵션을 설정하는 파일이 없습니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\treturn 0\n\t\t\t\t\tfi\n\t\t\t\tfi\n\t\t\tdone\n\t\tfi\n\tfi\n\tps_smtp_count=`ps -ef | grep -iE 'smtp|sendmail' | grep -v 'grep' | wc -l`\n\tif [ $ps_smtp_count -gt 0 ]; then\n\t\tfind_sendmailcf_count=`find / -name 'sendmail.cf' -type f 2>/dev/null | wc -l`\n\t\tif [ $find_sendmailcf_count -gt 0 ]; then\n\t\t\tsendmailcf_files=(`find / -name 'sendmail.cf' -type f 2>/dev/null`)\n\t\t\tfor ((i=0; i<${#sendmailcf_files[@]}; i++))\n\t\t\tdo\n\t\t\t\tsendmailcf_goaway_count=`grep -vE '^#|^\\s#' ${sendmailcf_files[$i]} | grep -i 'PrivacyOptions' | grep -i 'goaway' | wc -l`\n\t\t\t\tsendmailcf_noexpnt_novrfy_count=`grep -vE '^#|^\\s#' ${sendmailcf_files[$i]} | grep -i 'PrivacyOptions' | grep -i 'noexpn' | grep -i 'novrfy' | wc -l`\n\t\t\t\tif [ $sendmailcf_goaway_count -eq 0 ] && [ $sendmailcf_noexpnt_novrfy_count -eq 0 ]; then\n\t\t\t\t\techo \"※ U-70 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\techo \" ${sendmailcf_files[$i]} 파일에 noexpn, novrfy 또는 goaway 설정이 없습니다.\" >> $resultfile 2>&1\n\t\t\t\t\treturn 0\n\t\t\t\tfi\n\t\t\tdone\n\t\telse\n\t\t\techo \"※ U-70 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\techo \" noexpn, novrfy 또는 goaway 옵션을 설정하는 파일이 없습니다.\" >> $resultfile 2>&1\n\t\t\treturn 0\n\t\tfi\n\tfi\n\techo \"※ U-70 결과 : 양호(Good)\" >> $resultfile 2>&1\n\treturn 0\n}\n\nU_71() {\n\techo \"\"  >> $resultfile 2>&1\n\techo \"▶ U-71(중) | 3. 서비스 관리 > 3.35 Apache 웹 서비스 정보 숨김 ◀\"  >> $resultfile 2>&1\n\techo \" 양호 판단 기준 : ServerTokens Prod, ServerSignature Off로 설정되어있는 경우\" >> $resultfile 2>&1\n\twebconf_file_exists_count=0\n\twebconf_files=(\".htaccess\" \"httpd.conf\" \"apache2.conf\")\n\tfor ((i=0; i<${#webconf_files[@]}; i++))\n\tdo\n\t\tfind_webconf_file_count=`find / -name ${webconf_files[$i]} -type f 2>/dev/null | wc -l`\n\t\tif [ $find_webconf_file_count -gt 0 ]; then\n\t\t\t((webconf_file_exists_count++))\n\t\t\tfind_webconf_files=(`find / -name ${webconf_files[$i]} -type f 2>/dev/null`)\n\t\t\tfor ((j=0; j<${#find_webconf_files[@]}; j++))\n\t\t\tdo\n\t\t\t\twebconf_servertokens_prod_count=`grep -vE '^#|^\\s#' ${find_webconf_files[$j]} | grep -i 'ServerTokens' | grep -i 'Prod' | wc -l`\n\t\t\t\tif [ $webconf_servertokens_prod_count -gt 0 ]; then\n\t\t\t\t\twebconf_serversignature_off_count=`grep -vE '^#|^\\s#' ${find_webconf_files[$j]} | grep -i 'ServerSignature' | grep -i 'Off' | wc -l`\n\t\t\t\t\tif [ $webconf_serversignature_off_count -eq 0 ]; then\n\t\t\t\t\t\techo \"※ U-71 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\t\techo \" ${find_webconf_files[$j]} 파일에 ServerSignature off 설정이 없습니다.\" >> $resultfile 2>&1\n\t\t\t\t\t\treturn 0\n\t\t\t\t\tfi\n\t\t\t\telse\n\t\t\t\t\techo \"※ U-71 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\t\t\t\techo \" ${find_webconf_files[$j]} 파일에 ServerTokens Prod 설정이 없습니다.\" >> $resultfile 2>&1\n\t\t\t\t\treturn 0\n\t\t\t\tfi\n\t\t\tdone\n\t\tfi\n\tdone\n\tps_apache_count=`ps -ef | grep -iE 'httpd|apache2' | grep -v 'grep' | wc -l`\n\tif [ $ps_apache_count -gt 0 ] && [ $webconf_file_exists_count -eq 0 ]; then\n\t\techo \"※ U-71 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n\t\techo \" Apache 서비스를 사용하고, ServerTokens Prod, ServerSignature Off를 설정하는 파일이 없습니다.\" >> $resultfile 2>&1\n\t\treturn 0\n\telse\n\t\techo \"※ U-71 결과 : 양호(Good)\" >> $resultfile 2>&1\n\t\treturn 0\n\tfi\n}\n\nU_72() {\n\techo \"\"  >> $resultfile 2>&1\n\techo \"▶ U-72(하) | 5. 로그 관리 > 5.2 정책에 따른 시스템 로깅 설정 ◀\"  >> $resultfile 2>&1\n\techo \" 양호 판단 기준 : 로그 기록 정책이 정책에 따라 설정되어 수립되어 있으며 보안정책에 따라 로그를 남기고 있을 경우\" >> $resultfile 2>&1\n\techo \"※ U-72 결과 : N/A\" >> $resultfile 2>&1\n\techo \" 수동으로 점검하세요.\" >> $resultfile 2>&1\n}\n\necho \"\"  > $resultfile 2>&1\necho \" 점검일 : `date +'%F %H:%M:%S'`\"  >> $resultfile 2>&1\necho \"##############################################################################\" >> $resultfile 2>&1\necho \"#                                                                            #\" >> $resultfile 2>&1\necho \"#           Ubuntu vulnerability assessment results Version 1.1.3            #\" >> $resultfile 2>&1\necho \"#                         Copyright (c) 2023 Kim Jei                         #\" >> $resultfile 2>&1\necho \"#                                                                            #\" >> $resultfile 2>&1\necho \"##############################################################################\" >> $resultfile 2>&1\n\nU_01\nU_02\nU_03\nU_04\nU_05\nU_06\nU_07\nU_08\nU_09\nU_10\nU_11\nU_12\nU_13\nU_14\nU_15\nU_16\nU_17\nU_18\nU_19\nU_20\nU_21\nU_22\nU_23\nU_24\nU_25\nU_26\nU_27\nU_28\nU_29\nU_30\nU_31\nU_32\nU_33\nU_34\nU_35\nU_36\nU_37\nU_38\nU_39\nU_40\nU_41\nU_42\nU_43\nU_44\nU_45\nU_46\nU_47\nU_48\nU_49\nU_50\nU_51\nU_52\nU_53\nU_54\nU_55\nU_56\nU_57\nU_58\nU_59\nU_60\nU_61\nU_62\nU_63\nU_64\nU_65\nU_66\nU_67\nU_68\nU_69\nU_70\nU_71\nU_72\n\necho \"\"  >> $resultfile 2>&1\necho \"================================ 진단 결과 요약 ================================\" >> $resultfile 2>&1\necho \"\"  >> $resultfile 2>&1\necho \"                              ★ 항목 개수 = `cat $resultfile | grep '결과 : ' | wc -l`\" >> $resultfile 2>&1\necho \"                              ☆ 취약 개수 = `cat $resultfile | grep '결과 : 취약' | wc -l`\" >> $resultfile 2>&1\necho \"                              ★ 양호 개수 = `cat $resultfile | grep '결과 : 양호' | wc -l`\" >> $resultfile 2>&1\necho \"                              ☆ N/A 개수 = `cat $resultfile | grep '결과 : N/A' | wc -l`\" >> $resultfile 2>&1\necho \"\"  >> $resultfile 2>&1\necho \"==============================================================================\" >> $resultfile 2>&1\necho \"\"  >> $resultfile 2>&1"
      }
    ],
    "type": "shell"
  },
  {
    "id": 2,
    "name": "1111111111",
    "description": "11111111111",
    "lastRun": "실행 안됨",
    "status": "대기중",
    "tasks": 73,
    "filename": "2_test.sh",
    "sections": [
      {
        "id": "section_1",
        "name": "u_01",
        "description": "u_01 함수 실행",
        "content": "u_01() {\n\techo \"U_01: 원격에서 루트 계정 접근 제한\" >> $resultfile 2>&1\n    VULNERABLE=0\n    VULN_REASONS=\"\"\n    \n    # 1. 텔넷 서비스 점검\n    if dpkg -l 2>/dev/null | grep -iq telnet; then\n        VULNERABLE=1\n        VULN_REASONS=\"$VULN_REASONS- 텔넷 패키지가 설치되어 있음\\n\"\n    fi\n    \n    if systemctl list-unit-files 2>/dev/null | grep -iq telnet; then\n        VULNERABLE=1\n        VULN_REASONS=\"$VULN_REASONS- 텔넷 서비스가 등록되어 있음\\n\"\n    fi\n    \n    if systemctl is-active --quiet telnet.service 2>/dev/null; then\n        VULNERABLE=1\n        VULN_REASONS=\"$VULN_REASONS- 텔넷 서비스가 활성화되어 있음\\n\"\n    fi\n    \n    if netstat -tlnp 2>/dev/null | grep -q \":23 \" || ss -tlnp 2>/dev/null | grep -q \":23 \"; then\n        VULNERABLE=1\n        VULN_REASONS=\"$VULN_REASONS- 텔넷 포트(23)가 열려있음\\n\"\n    fi\n    \n    # 2. SSH 서비스 root 접속 설정 점검 \n    if [ -f \"/etc/ssh/sshd_config\" ]; then\n        if grep -Eq \"^\\s*PermitRootLogin\\s+yes\\s*$\" /etc/ssh/sshd_config; then\n            VULNERABLE=1\n            VULN_REASONS=\"$VULN_REASONS- SSH에서 root 직접 접속이 허용되어 있음\\n\"\n        elif ! grep -Eq \"^\\s*PermitRootLogin\\s+(no|prohibit-password|forced-commands-only)\\s*$\" /etc/ssh/sshd_config; then\n            VULNERABLE=1\n            VULN_REASONS=\"$VULN_REASONS- SSH PermitRootLogin 설정이 명시되지 않음\\n\"\n        fi\n    fi\n    \n    # 3. 기타 원격 접속 서비스 확인\n    if systemctl list-unit-files 2>/dev/null | grep -Eq \"(rlogin|rsh)\"; then\n        VULNERABLE=1\n        VULN_REASONS=\"$VULN_REASONS- rlogin/rsh 서비스가 등록되어 있음\\n\"\n    fi\n    \n    if [ $VULNERABLE -eq 1 ]; then\n        echo \"U-01 결과: 취약\" >> $resultfile 2>&1\n        echo \"취약 이유:\" >> $resultfile 2>&1\n        echo -e \"$VULN_REASONS\" >> $resultfile 2>&1\n    else\n        echo \"U-01 최종 결과: 양호\" >> $resultfile 2>&1\n    fi\n    \n    return $VULNERABLE\n}"
      },
      {
        "id": "section_2",
        "name": "u_02",
        "description": "u_02 함수 실행",
        "content": "u_02(){\n\techo \"U_02: 비밀번호 복잡성\">>$resultfile 2>&1\n\t   VULNERABLE=0\n    VULN_REASONS=\"\"\n\n    # /etc/security/pwquality.conf 파일 존재 확인\n    if [ ! -f \"/etc/security/pwquality.conf\" ]; then\n        VULNERABLE=1\n        VULN_REASONS=\"$VULN_REASONS- pwquality.conf 파일이 존재하지 않음\\n\"\n    else\n        # 각 설정값 확인\n\n        # minlen (최소 길이) - 권장: 9자 이상, 기본값: 8\n        minlen=$(grep -E \"^\\s*minlen\\s*=\" /etc/security/pwquality.conf 2>/dev/null | sed 's/.*=\\s*//')\n        [ -z \"$minlen\" ] && minlen=8  # 기본값\n        if [ \"$minlen\" -lt 9 ]; then\n            VULNERABLE=1\n            VULN_REASONS=\"$VULN_REASONS- 최소 비밀번호 길이가 부족함 (현재: $minlen, 권장: 9 이상)\\n\"\n        fi\n\n        # dcredit (숫자) - 권장: -1 (최소 1개 이상), 기본값: 0\n        dcredit=$(grep -E \"^\\s*dcredit\\s*=\" /etc/security/pwquality.conf 2>/dev/null | sed 's/.*=\\s*//')\n        [ -z \"$dcredit\" ] && dcredit=0  # 기본값\n        if [ \"$dcredit\" -gt -1 ]; then\n            VULNERABLE=1\n            VULN_REASONS=\"$VULN_REASONS- 숫자 문자 요구사항이 부족함 (현재: $dcredit, 권장: -1)\\n\"\n        fi\n\n        # ucredit (대문자) - 권장: -1 (최소 1개 이상), 기본값: 0\n        ucredit=$(grep -E \"^\\s*ucredit\\s*=\" /etc/security/pwquality.conf 2>/dev/null | sed 's/.*=\\s*//')\n        [ -z \"$ucredit\" ] && ucredit=0  # 기본값\n        if [ \"$ucredit\" -gt -1 ]; then\n            VULNERABLE=1\n            VULN_REASONS=\"$VULN_REASONS- 대문자 요구사항이 부족함 (현재: $ucredit, 권장: -1)\\n\"\n        fi\n\n        # lcredit (소문자) - 권장: -1 (최소 1개 이상), 기본값: 0\n        lcredit=$(grep -E \"^\\s*lcredit\\s*=\" /etc/security/pwquality.conf 2>/dev/null | sed 's/.*=\\s*//')\n        [ -z \"$lcredit\" ] && lcredit=0  # 기본값\n        if [ \"$lcredit\" -gt -1 ]; then\n            VULNERABLE=1\n            VULN_REASONS=\"$VULN_REASONS- 소문자 요구사항이 부족함 (현재: $lcredit, 권장: -1)\\n\"\n        fi\n\n        # ocredit (특수문자) - 권장: -1 (최소 1개 이상), 기본값: 0\n        ocredit=$(grep -E \"^\\s*ocredit\\s*=\" /etc/security/pwquality.conf 2>/dev/null | sed 's/.*=\\s*//')\n        [ -z \"$ocredit\" ] && ocredit=0  # 기본값\n        if [ \"$ocredit\" -gt -1 ]; then\n            VULNERABLE=1\n            VULN_REASONS=\"$VULN_REASONS- 특수문자 요구사항이 부족함 (현재: $ocredit, 권장: -1)\\n\"\n        fi\n\n        # difok (기존 패스워드와 차이) - 권장: 5 이상 (50%), 기본값: 1\n        difok=$(grep -E \"^\\s*difok\\s*=\" /etc/security/pwquality.conf 2>/dev/null | sed 's/.*=\\s*//')\n        [ -z \"$difok\" ] && difok=1  # 기본값\n        if [ \"$difok\" -lt 5 ]; then\n            VULNERABLE=1\n            VULN_REASONS=\"$VULN_REASONS- 기존 패스워드와 차이 요구사항이 부족함 (현재: $difok, 권장: 5 이상)\\n\"\n        fi\n    fi\n\n    # PAM 설정 확인 (pwquality 모듈 사용 여부)\n    if [ -f \"/etc/pam.d/common-password\" ]; then\n        if ! grep -q \"pam_pwquality.so\" /etc/pam.d/common-password; then\n            VULNERABLE=1\n            VULN_REASONS=\"$VULN_REASONS- PAM에서 pwquality 모듈이 설정되지 않음\\n\"\n        fi\n    else\n        VULNERABLE=1\n        VULN_REASONS=\"$VULN_REASONS- PAM password 설정 파일이 존재하지 않음\\n\"\n    fi\n\n    if [ $VULNERABLE -eq 1 ]; then\n        echo \"U-02 최종 결과: 취약\" >> $resultfile 2>&1\n        echo \"취약 이유:\" >> $resultfile 2>&1\n        echo -e \"$VULN_REASONS\" >> $resultfile 2>&1\n    else\n        echo \"U-02 최종 결과: 양호\" >> $resultfile 2>&1\n    fi\n\n    return $VULNERABLE\n}"
      },
      {
        "id": "section_3",
        "name": "u_03",
        "description": "u_03 함수 실행",
        "content": "u_03(){\n\techo \"U_03: 계정 잠금 임계값 설정\">>$resultfile 2>&1\n\tVULENRABLE=0\n\tVULN_REASONS=\"\"\n\n\t # PAM 설정 파일들 확인\n    pam_files=(\"/etc/pam.d/common-auth\" \"/etc/pam.d/system-auth\" \"/etc/pam.d/password-auth\")\n    found_config=0\n\n    for pam_file in \"${pam_files[@]}\"; do\n        if [ -f \"$pam_file\" ]; then\n            # pam_faillock 또는 pam_tally2 설정 확인\n            if grep -q \"pam_faillock\\|pam_tally2\" \"$pam_file\"; then\n                found_config=1\n\n                # deny 설정 확인 (권장: 5번 실패)\n                deny_value=$(grep -E \"(pam_faillock|pam_tally2)\" \"$pam_file\" | grep -o \"deny=[0-9]*\" | cut -d= -f2 | head -1)\n                if [ -z \"$deny_value\" ]; then\n                    VULNERABLE=1\n                    VULN_REASONS=\"$VULN_REASONS- deny 설정이 없음 → 권장: deny=5 옵션 추가\\n\"\n                elif [ \"$deny_value\" -gt 5 ] || [ \"$deny_value\" -lt 3 ]; then\n                    VULNERABLE=1\n                    VULN_REASONS=\"$VULN_REASONS- deny 값이 부적절함 (현재: $deny_value) → 권장: deny=5로 변경\\n\"\n                fi\n\n                # unlock_time 설정 확인 (권장: 600초/10분)\n                unlock_value=$(grep -E \"(pam_faillock|pam_tally2)\" \"$pam_file\" | grep -o \"unlock_time=[0-9]*\" | cut -d= -f2 | head -1)\n                if [ -z \"$unlock_value\" ]; then\n                    VULNERABLE=1\n                    VULN_REASONS=\"$VULN_REASONS- unlock_time 설정이 없음 → 권장: unlock_time=600 옵션 추가\\n\"\n                elif [ \"$unlock_value\" -lt 300 ] || [ \"$unlock_value\" -gt 1800 ]; then\n                    VULNERABLE=1\n                    VULN_REASONS=\"$VULN_REASONS- unlock_time 값이 부적절함 (현재: ${unlock_value}초) → 권장: unlock_time=600으로 변경\\n\"\n                fi\n\n                # even_deny_root 설정 확인 (권장: 활성화)\n                if ! grep -E \"(pam_faillock|pam_tally2)\" \"$pam_file\" | grep -q \"even_deny_root\"; then\n                    VULNERABLE=1\n                    VULN_REASONS=\"$VULN_REASONS- even_deny_root 설정이 없음 → 권장: even_deny_root 옵션 추가\\n\"\n                fi\n\n                # onerr 설정 확인 (권장: fail)\n                onerr_value=$(grep -E \"(pam_faillock|pam_tally2)\" \"$pam_file\" | grep -o \"onerr=[a-z]*\" | cut -d= -f2 | head -1)\n                if [ -z \"$onerr_value\" ]; then\n                    VULNERABLE=1\n                    VULN_REASONS=\"$VULN_REASONS- onerr 설정이 없음 → 권장: onerr=fail 옵션 추가\\n\"\n                elif [ \"$onerr_value\" != \"fail\" ]; then\n                    VULNERABLE=1\n                    VULN_REASONS=\"$VULN_REASONS- onerr 값이 부적절함 (현재: $onerr_value) → 권장: onerr=fail로 변경\\n\"\n                fi\n\n                break\n            fi\n        fi\n    done\n\n    # PAM 모듈 설정이 아예 없는 경우\n    if [ \"$found_config\" -eq 0 ]; then\n        VULNERABLE=1\n        VULN_REASONS=\"$VULN_REASONS- 계정 잠금 정책이 설정되지 않음 → 권장: PAM 파일에 'auth required pam_faillock.so deny=5 unlock_time=600 even_deny_root onerr=fail' 추가\\n\"\n    fi\n\n    # /etc/login.defs에서 추가 설정 확인\n    if [ -f \"/etc/login.defs\" ]; then\n        # LOGIN_RETRIES 확인\n        login_retries=$(grep -E \"^\\s*LOGIN_RETRIES\" /etc/login.defs | awk '{print $2}')\n        if [ -z \"$login_retries\" ]; then\n            VULNERABLE=1\n            VULN_REASONS=\"$VULN_REASONS- LOGIN_RETRIES 설정이 없음 → 권장: /etc/login.defs에 'LOGIN_RETRIES 5' 추가\\n\"\n        elif [ \"$login_retries\" -gt 5 ] || [ \"$login_retries\" -lt 3 ]; then\n            VULNERABLE=1\n            VULN_REASONS=\"$VULN_REASONS- LOGIN_RETRIES 값이 부적절함 (현재: $login_retries) → 권장: LOGIN_RETRIES 5로 변경\\n\"\n        fi\n    else\n        VULNERABLE=1\n        VULN_REASONS=\"$VULN_REASONS- login.defs 파일이 존재하지 않음 → 권장: /etc/login.defs 파일 생성 필요\\n\"\n    fi\n\n    # 최종 결과만 출력\n    if [ $VULNERABLE -eq 1 ]; then\n        echo \"U-03 최종 결과: 취약\" >> $resultfile 2>&1\n        echo \"취약 이유:\" >> $resultfile 2>&1\n        echo -e \"$VULN_REASONS\" >> $resultfile 2>&1\n    else\n        echo \"U-03 최종 결과: 양호\" >> $resultfile 2>&1\n    fi\n\n    return $VULNERABLE\n}"
      },
      {
        "id": "section_4",
        "name": "u_04",
        "description": "u_04 함수 실행",
        "content": "u_04() {\n    echo \"U_04:계정 비번 암호화 여부\" >> $resultfile 2>&1\n    VULNERABLE=0\n    VULN_REASONS=\"\"\n    \n    # shadow 패스워드를 사용하지 않는 계정 찾기 (두 번째 필드가 \"x\"가 아닌 경우)\n    non_shadow_accounts=$(awk -F: '$2!=\"x\" && $2!=\"\" && $2!=\"*\" && $2!=\"!\" && $2!=\"!!\" {print $1}' /etc/passwd)\n    \n    # 최종 결과 출력\n    if [ -n \"$non_shadow_accounts\" ]; then\n        VULNERABLE=1\n        VULN_REASONS=\"shadow를 사용하고 있지 않습니다.\"\n        \n        echo \"U-04 결과 : 취약(Vulnerable)\" >> $resultfile 2>&1\n        echo \"취약 이유:\" >> $resultfile 2>&1\n        echo \"$VULN_REASONS\" >> $resultfile 2>&1\n        echo \"암호화되지 않은 패스워드 발견:\" >> $resultfile 2>&1\n        \n        # 취약 계정 목록 출력\n        echo \"$non_shadow_accounts\" | while IFS= read -r account; do\n            echo \"  계정: $account\" >> $resultfile 2>&1\n        done\n    else\n        echo \"※ U-04 결과 : 양호(Good)\" >> $resultfile 2>&1\n    fi\n    \n    return $VULNERABLE\n}"
      },
      {
        "id": "section_5",
        "name": "u_44",
        "description": "u_44 함수 실행",
        "content": "u_44() {\n    echo \"U-44 루트 이외의 UID가 0인지\" >> $resultfile 2>&1\n    VULNERABLE=0\n    VULN_REASONS=\"\"\n\n    # UID가 0인 계정 중 root가 아닌 계정 찾기\n    non_root_uid0=$(awk -F: '$3 == 0 && $1 != \"root\" {print $1}' /etc/passwd)\n\n    if [ -n \"$non_root_uid0\" ]; then\n        VULNERABLE=1\n        echo \"$non_root_uid0의 uid를 변경하세요\" >> $resultfile 2>&1\n        VULN_REASONS=\"$VULN_REASONS- root 이외의 UID 0 계정 발견: $non_root_uid0 → 권장: usermod -u [새UID] [계정명]\\n\"\n    fi\n\n    # 최종 결과 출력\n    if [ $VULNERABLE -eq 1 ]; then\n        echo \"U-44 최종 결과: 취약\" >> $resultfile 2>&1\n        echo \"취약 이유:\" >> $resultfile 2>&1\n        echo -e \"$VULN_REASONS\" >> $resultfile 2>&1\n    else\n        echo \"U-44 최종 결과: 양호\" >> $resultfile 2>&1\n    fi\n\n    return $VULNERABLE\n}"
      },
      {
        "id": "section_6",
        "name": "u_45",
        "description": "u_45 함수 실행",
        "content": "u_45() {\n    echo \"U-45: 루트계정 su 제한\" >> $resultfile 2>&1\n    VULNERABLE=0\n    VULN_REASONS=\"\"\n    \n    # 1. PAM 설정에서 pam_wheel.so 확인\n    pam_wheel_check=$(grep -E \"^\\s*auth\\s+required\\s+pam_wheel.so\" /etc/pam.d/su 2>/dev/null)\n    if [ -z \"$pam_wheel_check\" ]; then\n        VULNERABLE=1\n        VULN_REASONS=\"$VULN_REASONS- PAM에서 wheel 그룹 제한이 설정되지 않음 → 권장: /etc/pam.d/su에 'auth required pam_wheel.so' 추가\\n\"\n    fi\n    \n    # 2. wheel 그룹 또는 sudo 그룹 존재 확인\n    wheel_group=$(grep \"^wheel:\" /etc/group 2>/dev/null)\n    sudo_group=$(grep \"^sudo:\" /etc/group 2>/dev/null)\n    \n    if [ -z \"$wheel_group\" ] && [ -z \"$sudo_group\" ]; then\n        VULNERABLE=1\n        VULN_REASONS=\"$VULN_REASONS- wheel 또는 sudo 그룹이 존재하지 않음 → 권장: groupadd wheel 명령으로 그룹 생성\\n\"\n    else\n        if [ -n \"$wheel_group\" ]; then\n            echo \"wheel 그룹 존재: $wheel_group\" >> $resultfile 2>&1\n        fi\n        if [ -n \"$sudo_group\" ]; then\n            echo \"sudo 그룹 존재: $sudo_group\" >> $resultfile 2>&1\n        fi\n    fi\n    \n    # 3. su 명령어 권한 확인 (권장: 4750)\n    if [ -f \"/bin/su\" ]; then\n        su_perm=$(stat -c \"%a\" /bin/su 2>/dev/null)\n        if [ \"$su_perm\" != \"4750\" ]; then\n            VULNERABLE=1\n            VULN_REASONS=\"$VULN_REASONS- su 명령어 권한이 부적절함 (현재: $su_perm) → 권장: chmod 4750 /bin/su\\n\"\n        fi\n        \n        # su 명령어 그룹 소유권 확인\n        su_group=$(stat -c \"%G\" /bin/su 2>/dev/null)\n        if [ \"$su_group\" != \"wheel\" ] && [ \"$su_group\" != \"sudo\" ]; then\n            VULNERABLE=1\n            VULN_REASONS=\"$VULN_REASONS- su 명령어 그룹 소유권이 부적절함 (현재: $su_group) → 권장: chgrp wheel /bin/su\\n\"\n        fi\n    fi\n    \n    # 4. 일반 사용자 계정 존재 확인 (UID 1000 이상)\n    regular_users=$(awk -F: '$3 >= 1000 && $7 !~ /(nologin|false)$/ {print $1}' /etc/passwd)\n    if [ -z \"$regular_users\" ]; then\n        echo \"일반 사용자 계정이 없어 su 제한 불필요\" >> $resultfile 2>&1\n        VULNERABLE=0  # 일반 사용자가 없으면 제한 불필요\n        VULN_REASONS=\"\"\n    fi\n    \n    # 최종 결과 출력\n    if [ $VULNERABLE -eq 1 ]; then\n        echo \"U-45 최종 결과: 취약\" >> $resultfile 2>&1\n        echo \"취약 이유:\" >> $resultfile 2>&1\n        echo -e \"$VULN_REASONS\" >> $resultfile 2>&1\n    else\n        echo \"U-45 최종 결과: 양호\" >> $resultfile 2>&1\n    fi\n    \n    return $VULNERABLE\n}"
      },
      {
        "id": "section_7",
        "name": "u_46",
        "description": "u_46 함수 실행",
        "content": "u_46() {\n    echo \"U-46: 패스워드 최소 길이 설정\" >> $resultfile 2>&1\n    VULNERABLE=0\n    VULN_REASONS=\"\"\n\n    # /etc/security/pwquality.conf에서 minlen 확인\n    minlen=$(grep -E \"^\\s*minlen\\s*=\" /etc/security/pwquality.conf 2>/dev/null | sed 's/.*=\\s*//')\n    # 빈 값이거나 숫자가 아닌 경우 기본값 설정\n    if [ -z \"$minlen\" ] || ! [[ \"$minlen\" =~ ^[0-9]+$ ]]; then\n        minlen=8  # 기본값\n    fi\n\n    if [ \"$minlen\" -lt 8 ]; then\n        VULNERABLE=1\n        VULN_REASONS=\"$VULN_REASONS- 최소 비밀번호 길이가 부족함 (현재: $minlen) → 권장: minlen = 8 이상\\n\"\n    fi\n\n    # /etc/login.defs에서 PASS_MIN_LEN 확인\n    pass_min_len=$(grep -E \"^\\s*PASS_MIN_LEN\" /etc/login.defs 2>/dev/null | awk '{print $2}')\n    if [ -n \"$pass_min_len\" ] && [[ \"$pass_min_len\" =~ ^[0-9]+$ ]] && [ \"$pass_min_len\" -lt 8 ]; then\n        VULNERABLE=1\n        VULN_REASONS=\"$VULN_REASONS- PASS_MIN_LEN이 부족함 (현재: $pass_min_len) → 권장: PASS_MIN_LEN 8 이상\\n\"\n    fi\n\n    # 최종 결과 출력\n    if [ $VULNERABLE -eq 1 ]; then\n        echo \"U-46 최종 결과: 취약\" >> $resultfile 2>&1\n        echo \"취약 이유:\" >> $resultfile 2>&1\n        echo -e \"$VULN_REASONS\" >> $resultfile 2>&1\n    else\n        echo \"U-46 최종 결과: 양호\" >> $resultfile 2>&1\n    fi\n\n    return $VULNERABLE\n}"
      },
      {
        "id": "section_8",
        "name": "u_47",
        "description": "u_47 함수 실행",
        "content": "u_47() {\n    echo \"U-47: 패스워드 최대 사용기간\" >> $resultfile 2>&1\n    VULNERABLE=0\n    VULN_REASONS=\"\"\n\n    # /etc/login.defs에서 PASS_MAX_DAYS 확인\n    pass_max_days=$(grep -E \"^\\s*PASS_MAX_DAYS\" /etc/login.defs 2>/dev/null | awk '{print $2}')\n\n    if [ -z \"$pass_max_days\" ]; then\n        VULNERABLE=1\n        VULN_REASONS=\"$VULN_REASONS- PASS_MAX_DAYS 설정이 없음 → 권장: PASS_MAX_DAYS 90 설정\\n\"\n    elif [[ \"$pass_max_days\" =~ ^[0-9]+$ ]] && ([ \"$pass_max_days\" -gt 90 ] || [ \"$pass_max_days\" -eq 99999 ]); then\n        VULNERABLE=1\n        VULN_REASONS=\"$VULN_REASONS- 패스워드 최대 사용기간이 과도함 (현재: $pass_max_days일) → 권장: PASS_MAX_DAYS 90 이하\\n\"\n    fi\n\n    # 실제 사용자 계정의 패스워드 만료 설정 확인\n    user_accounts=$(awk -F: '$3 >= 1000 && $7 !~ /(nologin|false)$/ {print $1}' /etc/passwd)\n    if [ -n \"$user_accounts\" ]; then\n        for user in $user_accounts; do\n            user_max_days=$(chage -l \"$user\" 2>/dev/null | grep \"Maximum number of days\" | awk -F: '{print $2}' | tr -d ' ')\n            # 빈 값이거나 숫자가 아닌 경우 처리\n            if [ -z \"$user_max_days\" ] || ! [[ \"$user_max_days\" =~ ^-?[0-9]+$ ]]; then\n                user_max_days=99999  # 기본값\n            fi\n\n            if [ \"$user_max_days\" = \"-1\" ] || [ \"$user_max_days\" -gt 90 ]; then\n                VULNERABLE=1\n                VULN_REASONS=\"$VULN_REASONS- 계정 $user의 패스워드 만료 설정이 부적절함 (현재: $user_max_days) → 권장: chage -M 90 $user\\n\"\n            fi\n        done\n    fi\n\n    # 최종 결과 출력\n    if [ $VULNERABLE -eq 1 ]; then\n        echo \"U-47 최종 결과: 취약\" >> $resultfile 2>&1\n        echo \"취약 이유:\" >> $resultfile 2>&1\n        echo -e \"$VULN_REASONS\" >> $resultfile 2>&1\n    else\n        echo \"U-47 최종 결과: 양호\" >> $resultfile 2>&1\n    fi\n\n    return $VULNERABLE\n}"
      },
      {
        "id": "section_9",
        "name": "u_48",
        "description": "u_48 함수 실행",
        "content": "u_48() {\n    echo \"U-48: 패스워드 최소 사용기간\" >> $resultfile 2>&1\n    VULNERABLE=0\n    VULN_REASONS=\"\"\n\n    # /etc/login.defs에서 PASS_MIN_DAYS 확인\n    pass_min_days=$(grep -E \"^\\s*PASS_MIN_DAYS\" /etc/login.defs 2>/dev/null | awk '{print $2}')\n\n    if [ -z \"$pass_min_days\" ]; then\n        VULNERABLE=1\n        VULN_REASONS=\"$VULN_REASONS- PASS_MIN_DAYS 설정이 없음 → 권장: PASS_MIN_DAYS 1 설정\\n\"\n    elif [[ \"$pass_min_days\" =~ ^[0-9]+$ ]] && [ \"$pass_min_days\" -lt 1 ]; then\n        VULNERABLE=1\n        VULN_REASONS=\"$VULN_REASONS- 패스워드 최소 사용기간이 부족함 (현재: $pass_min_days일) → 권장: PASS_MIN_DAYS 1 이상\\n\"\n    fi\n\n    # 실제 사용자 계정의 패스워드 최소 사용기간 확인\n    user_accounts=$(awk -F: '$3 >= 1000 && $7 !~ /(nologin|false)$/ {print $1}' /etc/passwd)\n    if [ -n \"$user_accounts\" ]; then\n        for user in $user_accounts; do\n            user_min_days=$(chage -l \"$user\" 2>/dev/null | grep \"Minimum number of days\" | awk -F: '{print $2}' | tr -d ' ')\n            # 빈 값이거나 숫자가 아닌 경우 처리\n            if [ -z \"$user_min_days\" ] || ! [[ \"$user_min_days\" =~ ^-?[0-9]+$ ]]; then\n                user_min_days=0  # 기본값\n            fi\n\n            if [ \"$user_min_days\" -lt 1 ]; then\n                VULNERABLE=1\n                VULN_REASONS=\"$VULN_REASONS- 계정 $user의 패스워드 최소 사용기간이 부족함 (현재: $user_min_days) → 권장: chage -m 1 $user\\n\"\n            fi\n        done\n    fi\n\n    # 최종 결과 출력\n    if [ $VULNERABLE -eq 1 ]; then\n        echo \"U-48 최종 결과: 취약\" >> $resultfile 2>&1\n        echo \"취약 이유:\" >> $resultfile 2>&1\n        echo -e \"$VULN_REASONS\" >> $resultfile 2>&1\n    else\n        echo \"U-48 최종 결과: 양호\" >> $resultfile 2>&1\n    fi\n\n    return $VULNERABLE\n}"
      },
      {
        "id": "section_10",
        "name": "u_49",
        "description": "u_49 함수 실행",
        "content": "u_49() {\n    echo \"U-49: 불필요한 계정 제거\" >> $resultfile 2>&1\n    VULNERABLE=0\n    VULN_REASONS=\"\"\n\n    # 불필요한 계정 목록 정의\n    truly_unnecessary=\"www-data|games|gopher|ftp|apache|httpd|mysql|mariadb|postgres|postfix|uucp|news\"\n\n    if [ -f \"/etc/passwd\" ]; then\n        # 불필요한 계정 탐지\n        found_accounts=$(awk -F: '{print $1}' /etc/passwd | grep -wE \"$unnecessary_accounts\")\n\n        if [ -n \"$found_accounts\" ]; then\n            VULNERABLE=1\n            # 줄바꿈을 공백으로 변환하여 한 줄로 표시\n            account_list=$(echo \"$found_accounts\" | tr '\\n' ' ' | sed 's/ $//')\n            VULN_REASONS=\"$VULN_REASONS- 불필요한 계정 발견: $account_list → 권장: userdel 명령으로 제거\\n\"\n        fi\n    else\n        VULNERABLE=1\n        VULN_REASONS=\"$VULN_REASONS- /etc/passwd 파일이 존재하지 않음\\n\"\n    fi\n\n    # 최종 결과 출력\n    if [ $VULNERABLE -eq 1 ]; then\n        echo \"U-49 최종 결과: 취약\" >> $resultfile 2>&1\n        echo \"취약 이유:\" >> $resultfile 2>&1\n        echo -e \"$VULN_REASONS\" >> $resultfile 2>&1\n    else\n        echo \"U-49 최종 결과: 양호\" >> $resultfile 2>&1\n    fi\n\n    return $VULNERABLE\n}"
      },
      {
        "id": "section_11",
        "name": "u_50",
        "description": "u_50 함수 실행",
        "content": "u_50() {\n    echo \"U-50: 관리자 그룹에 최소한의 계정 포함\" >> $resultfile 2>&1\n    VULNERABLE=0\n    VULN_REASONS=\"\"\n\n    # 불필요한 계정 목록 정의\n    unnecessary_accounts=\"daemon|bin|sys|adm|listen|nobody|nobody4|noaccess|diag|operator|gopher|games|ftp|apache|httpd|www-data|mysql|mariadb|postgres|mail|postfix|news|lp|uucp|nuucp\"\n\n    if [ -f \"/etc/group\" ]; then\n        # root 그룹의 멤버 확인\n        root_members=$(awk -F: '$1==\"root\" {print $4}' /etc/group)\n\n        if [ -n \"$root_members\" ]; then\n            # 쉼표로 구분된 멤버를 줄바꿈으로 변환하여 불필요한 계정 확인\n            found_accounts=$(echo \"$root_members\" | tr ',' '\\n' | grep -wE \"$unnecessary_accounts\")\n\n            if [ -n \"$found_accounts\" ]; then\n                VULNERABLE=1\n                # 줄바꿈을 공백으로 변환하여 한 줄로 표시\n                account_list=$(echo \"$found_accounts\" | tr '\\n' ' ' | sed 's/ $//')\n                VULN_REASONS=\"$VULN_REASONS- root 그룹에 불필요한 계정 포함: $account_list → 권장: gpasswd -d [계정명] root\\n\"\n            fi\n        fi\n\n        # sudo 그룹도 확인 (Ubuntu의 경우)\n        sudo_members=$(awk -F: '$1==\"sudo\" {print $4}' /etc/group)\n        if [ -n \"$sudo_members\" ]; then\n            found_sudo_accounts=$(echo \"$sudo_members\" | tr ',' '\\n' | grep -wE \"$unnecessary_accounts\")\n\n            if [ -n \"$found_sudo_accounts\" ]; then\n                VULNERABLE=1\n                account_list=$(echo \"$found_sudo_accounts\" | tr '\\n' ' ' | sed 's/ $//')\n                VULN_REASONS=\"$VULN_REASONS- sudo 그룹에 불필요한 계정 포함: $account_list → 권장: gpasswd -d [계정명] sudo\\n\"\n            fi\n        fi\n\n    else\n        VULNERABLE=1\n        VULN_REASONS=\"$VULN_REASONS- /etc/group 파일이 존재하지 않음\\n\"\n    fi\n\n    # 최종 결과 출력\n    if [ $VULNERABLE -eq 1 ]; then\n        echo \"U-50 최종 결과: 취약\" >> $resultfile 2>&1\n        echo \"취약 이유:\" >> $resultfile 2>&1\n        echo -e \"$VULN_REASONS\" >> $resultfile 2>&1\n    else\n        echo \"U-50 최종 결과: 양호\" >> $resultfile 2>&1\n    fi\n\n    return $VULNERABLE\n}"
      },
      {
        "id": "section_12",
        "name": "u_51",
        "description": "u_51 함수 실행",
        "content": "u_51() {\n    echo \"U-51: 계정이 존재하지 않는 GID 금지\" >> $resultfile 2>&1\n    VULNERABLE=0\n    VULN_REASONS=\"\"\n    \n    # 시스템 기본 그룹 목록 (제외할 그룹들)\n    system_groups=\"root|daemon|bin|sys|adm|tty|disk|lp|mail|news|uucp|man|proxy|kmem|dialout|fax|voice|cdrom|floppy|tape|sudo|audio|dip|www-data|backup|operator|list|irc|src|gnats|shadow|utmp|video|sasl|plugdev|staff|games|users|nogroup|systemd-journal|systemd-network|systemd-resolve|systemd-timesync|input|sgx|kvm|render|crontab|messagebus|systemd-coredump|syslog|_ssh|tss|ssl-cert|systemd-oom|bluetooth|netdev|avahi|tcpdump|sssd|fwupd-refresh|saned|colord|geoclue|pulse|pulse-access|gdm|lxd|nm-openvpn|rtkit|saned|whoopsie|systemd-network|systemd-resolve\"\n\n    # /etc/group에서만 확인 \n    if [ -f \"/etc/group\" ]; then\n        # GID 1000 이상이면서 멤버가 없는 그룹 찾기\n        empty_user_groups=$(awk -F: '$3 >= 1000 && ($4 == \"\" || $4 == \" \") {print $1 \":\" $3}' /etc/group)\n\n        if [ -n \"$empty_user_groups\" ]; then\n            VULNERABLE=1\n            group_list=$(echo \"$empty_user_groups\" | while read line; do\n                group_name=$(echo \"$line\" | cut -d: -f1)\n                group_gid=$(echo \"$line\" | cut -d: -f2)\n                echo -n \"$group_name(GID:$group_gid) \"\n            done)\n            VULN_REASONS=\"$VULN_REASONS- 사용자 정의 그룹 중 멤버가 없는 그룹: $group_list→ 권장: groupdel 명령으로 제거\\n\"\n        fi\n    else\n        VULNERABLE=1\n        VULN_REASONS=\"$VULN_REASONS- /etc/group 파일이 존재하지 않음\\n\"\n    fi\n\n    # 최종 결과 출력\n    if [ $VULNERABLE -eq 1 ]; then\n        echo \"U-51 최종 결과: 취약\" >> $resultfile 2>&1\n        echo \"취약 이유:\" >> $resultfile 2>&1\n        echo -e \"$VULN_REASONS\" >> $resultfile 2>&1\n    else\n        echo \"U-51 최종 결과: 양호\" >> $resultfile 2>&1\n    fi\n\n    return $VULNERABLE\n}"
      },
      {
        "id": "section_13",
        "name": "u_52",
        "description": "u_52 함수 실행",
        "content": "u_52() {\n    echo \"U-52: 동일한 UID 금지\" >> $resultfile 2>&1\n    VULNERABLE=0\n    VULN_REASONS=\"\"\n    \n    if [ -f \"/etc/passwd\" ]; then\n        # UID가 중복되는 계정들 찾기\n        duplicate_uids=$(awk -F: '{print $3}' /etc/passwd | sort | uniq -d)\n        \n        if [ -n \"$duplicate_uids\" ]; then\n            VULNERABLE=1\n            \n            # 각 중복 UID에 대해 해당 계정들 찾기\n            for uid in $duplicate_uids; do\n                # 동일한 UID를 가진 계정들 찾기\n                accounts_with_uid=$(awk -F: -v target_uid=\"$uid\" '$3 == target_uid {print $1}' /etc/passwd)\n                \n                if [ -n \"$accounts_with_uid\" ]; then\n                    # 줄바꿈을 공백으로 변환하여 한 줄로 표시\n                    account_list=$(echo \"$accounts_with_uid\" | tr '\\n' ' ' | sed 's/ $//')\n                    VULN_REASONS=\"$VULN_REASONS- UID $uid 중복 계정: $account_list → 권장: usermod -u [새UID] [계정명]\\n\"\n                fi\n            done\n        fi\n        \n    else\n        VULNERABLE=1\n        VULN_REASONS=\"$VULN_REASONS- /etc/passwd 파일이 존재하지 않음\\n\"\n    fi\n    \n    # 최종 결과 출력\n    if [ $VULNERABLE -eq 1 ]; then\n        echo \"U-52 최종 결과: 취약\" >> $resultfile 2>&1\n        echo \"취약 이유:\" >> $resultfile 2>&1\n        echo -e \"$VULN_REASONS\" >> $resultfile 2>&1\n    else\n        echo \"U-52 최종 결과: 양호\" >> $resultfile 2>&1\n    fi\n    \n    return $VULNERABLE\n}"
      },
      {
        "id": "section_14",
        "name": "u_53",
        "description": "u_53 함수 실행",
        "content": "u_53() {\n    echo \"U-53: 사용자 Shell 점검\" >> $resultfile 2>&1\n    VULNERABLE=0\n    VULN_REASONS=\"\"\n    \n    if [ -f \"/etc/passwd\" ]; then\n        # UID 1000 미만 시스템 계정 중 로그인 가능한 쉘을 가진 계정 확인\n        system_accounts_with_shell=$(awk -F: '\n            $3 < 1000 && $1 != \"root\" && \n            $7 !~ /(nologin|false|sync|halt|shutdown)$/ && \n            $7 != \"\" {\n                print $1 \":\" $3 \":\" $7\n            }' /etc/passwd)\n        \n        if [ -n \"$system_accounts_with_shell\" ]; then\n            VULNERABLE=1\n            echo \"로그인 가능한 쉘을 가진 시스템 계정:\" >> $resultfile 2>&1\n            echo \"$system_accounts_with_shell\" | while read line; do\n                account=$(echo $line | cut -d: -f1)\n                uid=$(echo $line | cut -d: -f2)\n                shell=$(echo $line | cut -d: -f3)\n                echo \"  계정: $account (UID:$uid), 쉘: $shell\" >> $resultfile 2>&1\n            done\n            \n            account_list=$(echo \"$system_accounts_with_shell\" | cut -d: -f1 | tr '\\n' ' ' | sed 's/ $//')\n            VULN_REASONS=\"$VULN_REASONS- 시스템 계정이 로그인 가능한 쉘 사용: $account_list → 권장: usermod -s /usr/sbin/nologin [계정명]\\n\"\n        fi\n        \n        # 일반 사용자 계정(UID 1000 이상) 중 비정상적인 쉘 확인\n        user_accounts_bad_shell=$(awk -F: '\n            $3 >= 1000 && \n            $7 ~ /(nologin|false|sync|halt|shutdown)$/ {\n                print $1 \":\" $3 \":\" $7\n            }' /etc/passwd)\n        \n        if [ -n \"$user_accounts_bad_shell\" ]; then\n            echo \"로그인이 제한된 일반 사용자 계정:\" >> $resultfile 2>&1\n            echo \"$user_accounts_bad_shell\" | while read line; do\n                account=$(echo $line | cut -d: -f1)\n                uid=$(echo $line | cut -d: -f2)\n                shell=$(echo $line | cut -d: -f3)\n                echo \"  계정: $account (UID:$uid), 쉘: $shell\" >> $resultfile 2>&1\n            done\n        fi\n        \n        # 존재하지 않는 쉘 경로 확인\n        invalid_shells=$(awk -F: '$7 != \"\" && $7 !~ /(nologin|false|sync|halt|shutdown)$/ {print $7}' /etc/passwd | sort -u | while read shell; do\n            if [ ! -x \"$shell\" ]; then\n                echo \"$shell\"\n            fi\n        done)\n        \n        if [ -n \"$invalid_shells\" ]; then\n            VULNERABLE=1\n            shell_list=$(echo \"$invalid_shells\" | tr '\\n' ' ' | sed 's/ $//')\n            VULN_REASONS=\"$VULN_REASONS- 존재하지 않는 쉘 경로 사용: $shell_list → 권장: 유효한 쉘로 변경\\n\"\n        fi\n        \n    else\n        VULNERABLE=1\n        VULN_REASONS=\"$VULN_REASONS- /etc/passwd 파일이 존재하지 않음\\n\"\n    fi\n    \n    # 최종 결과 출력\n    if [ $VULNERABLE -eq 1 ]; then\n        echo \"U-53 최종 결과: 취약\" >> $resultfile 2>&1\n        echo \"취약 이유:\" >> $resultfile 2>&1\n        echo -e \"$VULN_REASONS\" >> $resultfile 2>&1\n    else\n        echo \"U-53 최종 결과: 양호\" >> $resultfile 2>&1\n    fi\n    \n    return $VULNERABLE\n}"
      },
      {
        "id": "section_15",
        "name": "u_54",
        "description": "u_54 함수 실행",
        "content": "u_54() {\n    echo \"U-54: 세션 타임아웃 설정\" >> $resultfile 2>&1\n    VULNERABLE=0\n    VULN_REASONS=\"\"\n\n    # 1. 전역 프로필에서 TMOUT 설정 확인\n    profile_files=(\"/etc/profile\" \"/etc/bash.bashrc\" \"/etc/bashrc\")\n    tmout_found=0\n\n    for profile in \"${profile_files[@]}\"; do\n        if [ -f \"$profile\" ]; then\n            # TMOUT 설정이 있고 주석이 아닌 경우\n            tmout_setting=$(grep -E \"^\\s*export\\s+TMOUT=|^\\s*TMOUT=\" \"$profile\" 2>/dev/null | grep -v \"^#\")\n            if [ -n \"$tmout_setting\" ]; then\n                tmout_found=1\n                # TMOUT 값 추출\n                tmout_value=$(echo \"$tmout_setting\" | sed -E 's/.*TMOUT=([0-9]+).*/\\1/')\n\n                if [ -n \"$tmout_value\" ] && [[ \"$tmout_value\" =~ ^[0-9]+$ ]]; then\n                    if [ \"$tmout_value\" -gt 600 ] || [ \"$tmout_value\" -eq 0 ]; then\n                        VULNERABLE=1\n                        VULN_REASONS=\"$VULN_REASONS- $profile에서 TMOUT 값이 부적절함 (현재: ${tmout_value}초) → 권장: TMOUT=600 이하 설정\\n\"\n                    else\n                        echo \"$profile에서 TMOUT=$tmout_value 설정됨 [양호]\" >> $resultfile 2>&1\n                    fi\n                fi\n            fi\n        fi\n    done\n\n    if [ \"$tmout_found\" -eq 0 ]; then\n        VULNERABLE=1\n        VULN_REASONS=\"$VULN_REASONS- 전역 프로필에서 TMOUT 설정이 없음 → 권장: /etc/profile에 'export TMOUT=600' 추가\\n\"\n    fi\n\n    # 2. SSH 설정에서 세션 타임아웃 확인\n    if [ -f \"/etc/ssh/sshd_config\" ]; then\n        # ClientAliveInterval 확인\n        client_alive_interval=$(grep -E \"^\\s*ClientAliveInterval\" /etc/ssh/sshd_config | awk '{print $2}')\n        if [ -z \"$client_alive_interval\" ]; then\n            VULNERABLE=1\n            VULN_REASONS=\"$VULN_REASONS- SSH ClientAliveInterval 설정이 없음 → 권장: ClientAliveInterval 300 설정\\n\"\n        elif [ \"$client_alive_interval\" -gt 600 ] || [ \"$client_alive_interval\" -eq 0 ]; then\n            VULNERABLE=1\n            VULN_REASONS=\"$VULN_REASONS- SSH ClientAliveInterval 값이 부적절함 (현재: $client_alive_interval) → 권장: 300 이하로 설정\\n\"\n        fi\n\n        # ClientAliveCountMax 확인\n        client_alive_count=$(grep -E \"^\\s*ClientAliveCountMax\" /etc/ssh/sshd_config | awk '{print $2}')\n        if [ -z \"$client_alive_count\" ]; then\n            VULNERABLE=1\n            VULN_REASONS=\"$VULN_REASONS- SSH ClientAliveCountMax 설정이 없음 → 권장: ClientAliveCountMax 0 설정\\n\"\n        elif [ \"$client_alive_count\" -gt 3 ]; then\n            VULNERABLE=1\n            VULN_REASONS=\"$VULN_REASONS- SSH ClientAliveCountMax 값이 부적절함 (현재: $client_alive_count) → 권장: 0-3 범위로 설정\\n\"\n        fi\n    else\n        echo \"SSH 설정 파일이 존재하지 않음\" >> $resultfile 2>&1\n    fi\n\n    # 3. 현재 TMOUT 환경변수 확인\n    if [ -n \"$TMOUT\" ]; then\n        if [ \"$TMOUT\" -gt 600 ] || [ \"$TMOUT\" -eq 0 ]; then\n            echo \"현재 세션 TMOUT=$TMOUT (부적절)\" >> $resultfile 2>&1\n        else\n            echo \"현재 세션 TMOUT=$TMOUT (적절)\" >> $resultfile 2>&1\n        fi\n    else\n        echo \"현재 세션에 TMOUT 설정 없음\" >> $resultfile 2>&1\n    fi\n\n    # 최종 결과 출력\n    if [ $VULNERABLE -eq 1 ]; then\n        echo \"U-54 최종 결과: 취약\" >> $resultfile 2>&1\n        echo \"취약 이유:\" >> $resultfile 2>&1\n        echo -e \"$VULN_REASONS\" >> $resultfile 2>&1\n    else\n        echo \"U-54 최종 결과: 양호\" >> $resultfile 2>&1\n    fi\n\n    return $VULNERABLE\n}\n#task 파일 및 디렉터리 | 파일이나 디렉터리의 접근 권한 등을 점검"
      },
      {
        "id": "section_16",
        "name": "u_05",
        "description": "u_05 함수 실행",
        "content": "u_05(){\n\n    echo \"U-05: root홈, 패스 디렉토리 권한 및 패스 설정\" >> $resultfile 2>&1\n    VULNERABLE=0\n    VULN_REASONS=\"\"\n\n    # PATH에서 현재 디렉토리(.) 또는 연속된 콜론(::) 확인\n    if echo \"$PATH\" | grep -q '\\.' || echo \"$PATH\" | grep -q '::'; then\n        VULNERABLE=1\n        VULN_REASONS=\"$VULN_REASONS- PATH에 현재 디렉토리(.) 또는 빈 경로가 포함됨 → 권장: PATH 설정 수정\\n\"\n    fi\n\n    # 최종 결과 출력\n    if [ $VULNERABLE -eq 1 ]; then\n        echo \"U-05 최종 결과: 취약\" >> $resultfile 2>&1\n        echo \"취약 이유:\" >> $resultfile 2>&1\n        echo -e \"$VULN_REASONS\" >> $resultfile 2>&1\n    else\n        echo \"U-05 최종 결과: 양호\" >> $resultfile 2>&1\n    fi\n\n    return $VULNERABLE\n}\n#검사하는데 다소 시간이 걸리는 항목"
      },
      {
        "id": "section_17",
        "name": "u_06",
        "description": "u_06 함수 실행",
        "content": "u_06() {\n    echo \"U-06: 파일 및 디렉터리 소유자 설정\" >> $resultfile 2>&1\n    VULNERABLE=0\n    VULN_REASONS=\"\"\n    \n    # 소유자가 존재하지 않는 파일/디렉터리 검색\n    echo \"전체 파일시스템 검사 중... (시간이 소요될 수 있습니다)\" >> $resultfile 2>&1\n    \n    # 개수만 먼저 확인\n    orphan_count=$(find / \\( -nouser -o -nogroup \\) 2>/dev/null | wc -l)\n    \n    if [ \"$orphan_count\" -gt 0 ]; then\n        VULNERABLE=1\n        echo \"소유자가 존재하지 않는 파일/디렉터리: $orphan_count 개 발견\" >> $resultfile 2>&1\n        \n        # 처음 5개만 예시로 표시\n        echo \"예시 (처음 5개):\" >> $resultfile 2>&1\n        find / \\( -nouser -o -nogroup \\) 2>/dev/null | head -5 | while read file; do\n            echo \"  $file\" >> $resultfile 2>&1\n        done\n        \n        if [ \"$orphan_count\" -gt 5 ]; then\n            echo \"  ... 외 $((orphan_count - 5))개 더 있음\" >> $resultfile 2>&1\n        fi\n        \n        VULN_REASONS=\"$VULN_REASONS- 소유자가 존재하지 않는 파일 $orphan_count개 발견 → 권장: find / -nouser -o -nogroup 으로 전체 확인 후 chown 설정\\n\"\n    fi\n    \n    # 최종 결과 출력\n    if [ $VULNERABLE -eq 1 ]; then\n        echo \"U-06 최종 결과: 취약\" >> $resultfile 2>&1\n        echo \"취약 이유:\" >> $resultfile 2>&1\n        echo -e \"$VULN_REASONS\" >> $resultfile 2>&1\n    else\n        echo \"U-06 최종 결과: 양호\" >> $resultfile 2>&1\n    fi\n    \n    return $VULNERABLE\n}"
      },
      {
        "id": "section_18",
        "name": "u_07",
        "description": "u_07 함수 실행",
        "content": "u_07() {\n    echo \"U-07: /etc/passwd 파일 소유자 및 권한 설정\" >> $resultfile 2>&1\n    VULNERABLE=0\n    VULN_REASONS=\"\"\n    \n    if [ -f \"/etc/passwd\" ]; then\n        # 소유자 확인\n        pw_owner=$(stat -c \"%U\" /etc/passwd 2>/dev/null)\n        if [ \"$pw_owner\" != \"root\" ]; then\n            VULNERABLE=1\n            VULN_REASONS=\"$VULN_REASONS- /etc/passwd 파일 소유자가 root가 아님 (현재: $pw_owner) → 권장: chown root /etc/passwd\\n\"\n        fi\n        \n        # 그룹 확인\n        pw_group=$(stat -c \"%G\" /etc/passwd 2>/dev/null)\n        if [ \"$pw_group\" != \"root\" ]; then\n            VULNERABLE=1\n            VULN_REASONS=\"$VULN_REASONS- /etc/passwd 파일 그룹이 root가 아님 (현재: $pw_group) → 권장: chgrp root /etc/passwd\\n\"\n        fi\n        \n        # 권한 확인 (644 이하)\n        pw_perm=$(stat -c \"%a\" /etc/passwd 2>/dev/null)\n        if [ -n \"$pw_perm\" ] && [[ \"$pw_perm\" =~ ^[0-9]+$ ]]; then\n            if [ \"$pw_perm\" -gt 644 ]; then\n                VULNERABLE=1\n                VULN_REASONS=\"$VULN_REASONS- /etc/passwd 파일 권한이 644보다 큼 (현재: $pw_perm) → 권장: chmod 644 /etc/passwd\\n\"\n            fi\n        fi\n    else\n        VULNERABLE=1\n        VULN_REASONS=\"$VULN_REASONS- /etc/passwd 파일이 존재하지 않음\\n\"\n    fi\n    \n    # 최종 결과 출력\n    if [ $VULNERABLE -eq 1 ]; then\n        echo \"U-07 최종 결과: 취약\" >> $resultfile 2>&1\n        echo \"취약 이유:\" >> $resultfile 2>&1\n        echo -e \"$VULN_REASONS\" >> $resultfile 2>&1\n    else\n        echo \"U-07 최종 결과: 양호\" >> $resultfile 2>&1\n    fi\n    \n    return $VULNERABLE\n}"
      },
      {
        "id": "section_19",
        "name": "u_08",
        "description": "u_08 함수 실행",
        "content": "u_08() {\n    echo \"U-08: /etc/shadow 파일 소유자 및 권한 설정\" >> $resultfile 2>&1\n    VULNERABLE=0\n    VULN_REASONS=\"\"\n \n    if [ -f \"/etc/shadow\" ]; then\n        # 소유자 확인 - 수정: /etc/shadow 파일 확인\n        shadow_owner=$(stat -c \"%U\" /etc/shadow 2>/dev/null)\n        if [ \"$shadow_owner\" != \"root\" ]; then\n            VULNERABLE=1\n            VULN_REASONS=\"$VULN_REASONS- /etc/shadow 파일 소유자가 root가 아님 (현재: $shadow_owner) → 권장: chown root /etc/shadow\\n\"\n        fi\n        \n        # 그룹 확인 - 추가\n        shadow_group=$(stat -c \"%G\" /etc/shadow 2>/dev/null)\n        if [ \"$shadow_group\" != \"root\" ] && [ \"$shadow_group\" != \"shadow\" ]; then\n            VULNERABLE=1\n            VULN_REASONS=\"$VULN_REASONS- /etc/shadow 파일 그룹이 적절하지 않음 (현재: $shadow_group) → 권장: chgrp shadow /etc/shadow\\n\"\n        fi\n        \n        # 권한 확인 (640 이하) - 수정: /etc/shadow 파일 확인 및 적절한 권한값\n        shadow_perm=$(stat -c \"%a\" /etc/shadow 2>/dev/null)\n        if [ -n \"$shadow_perm\" ] && [[ \"$shadow_perm\" =~ ^[0-9]+$ ]]; then\n            if [ \"$shadow_perm\" -gt 640 ]; then\n                VULNERABLE=1\n                VULN_REASONS=\"$VULN_REASONS- /etc/shadow 파일 권한이 640보다 큼 (현재: $shadow_perm) → 권장: chmod 640 /etc/shadow\\n\"\n            fi\n        fi\n    else\n        VULNERABLE=1\n        VULN_REASONS=\"$VULN_REASONS- /etc/shadow 파일이 존재하지 않음\\n\"\n    fi\n    \n    # 최종 결과 출력\n    if [ $VULNERABLE -eq 1 ]; then\n        echo \"U-08 최종 결과: 취약\" >> $resultfile 2>&1\n        echo \"취약 이유:\" >> $resultfile 2>&1\n        echo -e \"$VULN_REASONS\" >> $resultfile 2>&1\n    else\n        echo \"U-08 최종 결과: 양호\" >> $resultfile 2>&1\n    fi\n    \n    return $VULNERABLE\n}"
      },
      {
        "id": "section_20",
        "name": "u_09",
        "description": "u_09 함수 실행",
        "content": "u_09() {\n    echo \"U-09: /etc/hosts 파일 소유자 및 권한 설정\" >> $resultfile 2>&1\n    VULNERABLE=0\n    VULN_REASONS=\"\"\n    \n    if [ -f \"/etc/hosts\" ]; then\n        # 소유자 확인 - 수정: /etc/hosts 파일 확인\n        hosts_owner=$(stat -c \"%U\" /etc/hosts 2>/dev/null)\n        if [ \"$hosts_owner\" != \"root\" ]; then\n            VULNERABLE=1\n            VULN_REASONS=\"$VULN_REASONS- /etc/hosts 파일 소유자가 root가 아님 (현재: $hosts_owner) → 권장: chown root /etc/hosts\\n\"\n        fi\n        \n        # 그룹 확인 - 수정: /etc/hosts 파일 확인\n        hosts_group=$(stat -c \"%G\" /etc/hosts 2>/dev/null)\n        if [ \"$hosts_group\" != \"root\" ]; then\n            VULNERABLE=1\n            VULN_REASONS=\"$VULN_REASONS- /etc/hosts 파일 그룹이 root가 아님 (현재: $hosts_group) → 권장: chgrp root /etc/hosts\\n\"\n        fi\n        \n        # 권한 확인 (644 이하) - 수정: 적절한 권한값\n        hosts_perm=$(stat -c \"%a\" /etc/hosts 2>/dev/null)\n        if [ -n \"$hosts_perm\" ] && [[ \"$hosts_perm\" =~ ^[0-9]+$ ]]; then\n            if [ \"$hosts_perm\" -gt 644 ]; then\n                VULNERABLE=1\n                VULN_REASONS=\"$VULN_REASONS- /etc/hosts 파일 권한이 644보다 큼 (현재: $hosts_perm) → 권장: chmod 644 /etc/hosts\\n\"\n            fi\n        fi\n    else\n        VULNERABLE=1\n        VULN_REASONS=\"$VULN_REASONS- /etc/hosts 파일이 존재하지 않음\\n\"\n    fi\n    \n    # 최종 결과 출력\n    if [ $VULNERABLE -eq 1 ]; then\n        echo \"U-09 최종 결과: 취약\" >> $resultfile 2>&1\n        echo \"취약 이유:\" >> $resultfile 2>&1\n        echo -e \"$VULN_REASONS\" >> $resultfile 2>&1\n    else\n        echo \"U-09 최종 결과: 양호\" >> $resultfile 2>&1\n    fi\n    \n    return $VULNERABLE\n}"
      },
      {
        "id": "section_21",
        "name": "u_10",
        "description": "u_10 함수 실행",
        "content": "u_10() {\n    echo \"U-10: /etc/inetd.conf 파일 소유자 및 권한 설정\" >> $resultfile 2>&1\n    VULNERABLE=0\n    VULN_REASONS=\"\"\n    \n    if [ -f \"/etc/inetd.conf\" ]; then\n        # 소유자 확인\n        inetd_owner=$(stat -c \"%U\" /etc/inetd.conf 2>/dev/null)\n        if [ \"$inetd_owner\" != \"root\" ]; then\n            VULNERABLE=1\n            VULN_REASONS=\"$VULN_REASONS- /etc/inetd.conf 파일 소유자가 root가 아님 (현재: $inetd_owner) → 권장: chown root /etc/inetd.conf\\n\"\n        fi\n        \n        # 그룹 확인\n        inetd_group=$(stat -c \"%G\" /etc/inetd.conf 2>/dev/null)\n        if [ \"$inetd_group\" != \"root\" ]; then\n            VULNERABLE=1\n            VULN_REASONS=\"$VULN_REASONS- /etc/inetd.conf 파일 그룹이 root가 아님 (현재: $inetd_group) → 권장: chgrp root /etc/inetd.conf\\n\"\n        fi\n        \n        # 권한 확인 (600 이하)\n        inetd_perm=$(stat -c \"%a\" /etc/inetd.conf 2>/dev/null)\n        if [ -n \"$inetd_perm\" ] && [[ \"$inetd_perm\" =~ ^[0-9]+$ ]]; then\n            if [ \"$inetd_perm\" -gt 600 ]; then\n                VULNERABLE=1\n                VULN_REASONS=\"$VULN_REASONS- /etc/inetd.conf 파일 권한이 600보다 큼 (현재: $inetd_perm) → 권장: chmod 600 /etc/inetd.conf\\n\"\n            fi\n        fi\n    else\n        echo \"/etc/inetd.conf 파일이 존재하지 않음 (최근 시스템에서는 정상)\" >> $resultfile 2>&1\n    fi\n    \n    # 최종 결과 출력\n    if [ $VULNERABLE -eq 1 ]; then\n        echo \"U-10 최종 결과: 취약\" >> $resultfile 2>&1\n        echo \"취약 이유:\" >> $resultfile 2>&1\n        echo -e \"$VULN_REASONS\" >> $resultfile 2>&1\n    else\n        echo \"U-10 최종 결과: 양호\" >> $resultfile 2>&1\n    fi\n    \n    return $VULNERABLE\n}"
      },
      {
        "id": "section_22",
        "name": "u_11",
        "description": "u_11 함수 실행",
        "content": "u_11() {\n    echo \"U-11: /etc/syslog.conf 파일 소유자 및 권한 설정\" >> $resultfile 2>&1\n    VULNERABLE=0\n    VULN_REASONS=\"\"\n    \n    # syslog.conf 또는 rsyslog.conf 확인\n    syslog_files=(\"/etc/syslog.conf\" \"/etc/rsyslog.conf\")\n    found_file=\"\"\n    \n    for file in \"${syslog_files[@]}\"; do\n        if [ -f \"$file\" ]; then\n            found_file=\"$file\"\n            break\n        fi\n    done\n    \n    if [ -n \"$found_file\" ]; then\n        echo \"점검 대상 파일: $found_file\" >> $resultfile 2>&1\n        \n        # 소유자 확인\n        syslog_owner=$(stat -c \"%U\" \"$found_file\" 2>/dev/null)\n        if [ \"$syslog_owner\" != \"root\" ]; then\n            VULNERABLE=1\n            VULN_REASONS=\"$VULN_REASONS- $found_file 파일 소유자가 root가 아님 (현재: $syslog_owner) → 권장: chown root $found_file\\n\"\n        fi\n        \n        # 그룹 확인\n        syslog_group=$(stat -c \"%G\" \"$found_file\" 2>/dev/null)\n        if [ \"$syslog_group\" != \"root\" ]; then\n            VULNERABLE=1\n            VULN_REASONS=\"$VULN_REASONS- $found_file 파일 그룹이 root가 아님 (현재: $syslog_group) → 권장: chgrp root $found_file\\n\"\n        fi\n        \n        # 권한 확인 (640 이하)\n        syslog_perm=$(stat -c \"%a\" \"$found_file\" 2>/dev/null)\n        if [ -n \"$syslog_perm\" ] && [[ \"$syslog_perm\" =~ ^[0-9]+$ ]]; then\n            if [ \"$syslog_perm\" -gt 640 ]; then\n                VULNERABLE=1\n                VULN_REASONS=\"$VULN_REASONS- $found_file 파일 권한이 640보다 큼 (현재: $syslog_perm) → 권장: chmod 640 $found_file\\n\"\n            fi\n        fi\n    else\n        echo \"syslog 설정 파일이 존재하지 않음 (systemd-journald 사용 가능)\" >> $resultfile 2>&1\n    fi\n    \n    # 최종 결과 출력\n    if [ $VULNERABLE -eq 1 ]; then\n        echo \"U-11 최종 결과: 취약\" >> $resultfile 2>&1\n        echo \"취약 이유:\" >> $resultfile 2>&1\n        echo -e \"$VULN_REASONS\" >> $resultfile 2>&1\n    else\n        echo \"U-11 최종 결과: 양호\" >> $resultfile 2>&1\n    fi\n    \n    return $VULNERABLE\n}"
      },
      {
        "id": "section_23",
        "name": "u_12",
        "description": "u_12 함수 실행",
        "content": "u_12() {\n    echo \"U-12: /etc/services 파일 소유자 및 권한 설정\" >> $resultfile 2>&1\n    VULNERABLE=0\n    VULN_REASONS=\"\"\n    \n    if [ -f \"/etc/services\" ]; then\n        # 소유자 확인\n        services_owner=$(stat -c \"%U\" /etc/services 2>/dev/null)\n        if [ \"$services_owner\" != \"root\" ]; then\n            VULNERABLE=1\n            VULN_REASONS=\"$VULN_REASONS- /etc/services 파일 소유자가 root가 아님 (현재: $services_owner) → 권장: chown root /etc/services\\n\"\n        fi\n        \n        # 그룹 확인\n        services_group=$(stat -c \"%G\" /etc/services 2>/dev/null)\n        if [ \"$services_group\" != \"root\" ]; then\n            VULNERABLE=1\n            VULN_REASONS=\"$VULN_REASONS- /etc/services 파일 그룹이 root가 아님 (현재: $services_group) → 권장: chgrp root /etc/services\\n\"\n        fi\n        \n        # 권한 확인 (644 이하)\n        services_perm=$(stat -c \"%a\" /etc/services 2>/dev/null)\n        if [ -n \"$services_perm\" ] && [[ \"$services_perm\" =~ ^[0-9]+$ ]]; then\n            if [ \"$services_perm\" -gt 644 ]; then\n                VULNERABLE=1\n                VULN_REASONS=\"$VULN_REASONS- /etc/services 파일 권한이 644보다 큼 (현재: $services_perm) → 권장: chmod 644 /etc/services\\n\"\n            fi\n        fi\n    else\n        VULNERABLE=1\n        VULN_REASONS=\"$VULN_REASONS- /etc/services 파일이 존재하지 않음\\n\"\n    fi\n    \n    # 최종 결과 출력\n    if [ $VULNERABLE -eq 1 ]; then\n        echo \"U-12 최종 결과: 취약\" >> $resultfile 2>&1\n        echo \"취약 이유:\" >> $resultfile 2>&1\n        echo -e \"$VULN_REASONS\" >> $resultfile 2>&1\n    else\n        echo \"U-12 최종 결과: 양호\" >> $resultfile 2>&1\n    fi\n    \n    return $VULNERABLE\n}"
      },
      {
        "id": "section_24",
        "name": "u_13",
        "description": "u_13 함수 실행",
        "content": "u_13() {\n    echo \"U-13: SUID/SGID 파일 점검\" >> $resultfile 2>&1\n    VULNERABLE=0\n    VULN_REASONS=\"\"\n    \n    # 주요 디렉터리에서 SUID/SGID 파일 검색 (시간 제한)\n    echo \"SUID/SGID 파일 검색 중...\" >> $resultfile 2>&1\n    \n    # 위험할 수 있는 SUID/SGID 파일들 (일반적으로 불필요한 것들)\n    dangerous_files=(\"/sbin/dump\" \"/sbin/restore\" \"/sbin/unix_chkpwd\" \"/usr/bin/at\" \"/usr/bin/lpq\" \"/usr/bin/lpq-lpd\" \"/usr/bin/lpr\" \"/usr/bin/lpr-lpd\" \"/usr/bin/lprm\" \"/usr/bin/lprm-lpd\" \"/usr/bin/newgrp\" \"/usr/sbin/lpc\" \"/usr/sbin/lpc-lpd\" \"/usr/sbin/traceroute\")\n    \n    # 위험한 파일들 중 SUID/SGID 설정된 것 확인\n    found_dangerous=0\n    for file in \"${dangerous_files[@]}\"; do\n        if [ -f \"$file\" ]; then\n            # SUID(4000) 또는 SGID(2000) 비트 확인\n            if [ -u \"$file\" ] || [ -g \"$file\" ]; then\n                if [ $found_dangerous -eq 0 ]; then\n                    echo \"위험할 수 있는 SUID/SGID 파일 발견:\" >> $resultfile 2>&1\n                    found_dangerous=1\n                fi\n                \n                file_perm=$(stat -c \"%a\" \"$file\" 2>/dev/null)\n                file_owner=$(stat -c \"%U:%G\" \"$file\" 2>/dev/null)\n                echo \"  $file (권한:$file_perm, 소유자:$file_owner)\" >> $resultfile 2>&1\n                VULNERABLE=1\n            fi\n        fi\n    done\n    \n    if [ $found_dangerous -eq 1 ]; then\n        VULN_REASONS=\"$VULN_REASONS- 위험할 수 있는 SUID/SGID 파일이 발견됨 → 권장: chmod u-s,g-s [파일명] 으로 제거\\n\"\n    fi\n    \n    # 전체 시스템에서 SUID/SGID 파일 목록 확인 (주요 디렉터리만)\n    echo \"전체 SUID/SGID 파일 목록:\" >> $resultfile 2>&1\n    suid_files=$(find /bin /sbin /usr/bin /usr/sbin -type f \\( -perm -4000 -o -perm -2000 \\) 2>/dev/null)\n    \n    if [ -n \"$suid_files\" ]; then\n        echo \"$suid_files\" | while read file; do\n            if [ -f \"$file\" ]; then\n                file_perm=$(stat -c \"%a\" \"$file\" 2>/dev/null)\n                file_owner=$(stat -c \"%U:%G\" \"$file\" 2>/dev/null)\n                echo \"  $file (권한:$file_perm, 소유자:$file_owner)\" >> $resultfile 2>&1\n            fi\n        done\n        \n        suid_count=$(echo \"$suid_files\" | wc -l)\n        echo \"총 $suid_count 개의 SUID/SGID 파일 발견\" >> $resultfile 2>&1\n        \n        if [ \"$suid_count\" -gt 50 ]; then\n            VULNERABLE=1\n            VULN_REASONS=\"$VULN_REASONS- SUID/SGID 파일이 과도하게 많음 ($suid_count개) → 권장: 불필요한 파일들의 SUID/SGID 제거\\n\"\n        fi\n    else\n        echo \"  SUID/SGID 파일이 발견되지 않음\" >> $resultfile 2>&1\n    fi\n    \n    # 추가 보안 점검: 일반 사용자 소유의 SUID 파일\n    user_suid=$(find /home -type f -perm -4000 2>/dev/null)\n    if [ -n \"$user_suid\" ]; then\n        VULNERABLE=1\n        echo \"일반 사용자 디렉터리의 SUID 파일:\" >> $resultfile 2>&1\n        echo \"$user_suid\" | while read file; do\n            echo \"  $file\" >> $resultfile 2>&1\n        done\n        VULN_REASONS=\"$VULN_REASONS- 일반 사용자 디렉터리에 SUID 파일 발견 → 권장: 제거 또는 권한 조정\\n\"\n    fi\n    \n    # 최종 결과 출력\n    if [ $VULNERABLE -eq 1 ]; then\n        echo \"U-13 최종 결과: 취약\" >> $resultfile 2>&1\n        echo \"취약 이유:\" >> $resultfile 2>&1\n        echo -e \"$VULN_REASONS\" >> $resultfile 2>&1\n        echo \"참고: find / -type f \\\\( -perm -4000 -o -perm -2000 \\\\) 명령으로 전체 확인 가능\" >> $resultfile 2>&1\n    else\n        echo \"U-13 최종 결과: 양호\" >> $resultfile 2>&1\n    fi\n    \n    return $VULNERABLE\n}"
      },
      {
        "id": "section_25",
        "name": "u_14",
        "description": "u_14 함수 실행",
        "content": "u_14() {\n    echo \"U-14: 사용자, 시스템 시작 파일 및 환경 파일 소유자 및 권한 설정\" >> $resultfile 2>&1\n    VULNERABLE=0\n    VULN_REASONS=\"\"\n    \n    # 점검할 환경 파일들\n    start_files=(\".profile\" \".cshrc\" \".login\" \".kshrc\" \".bash_profile\" \".bashrc\" \".bash_login\")\n    \n    # 로그인 가능한 사용자의 홈 디렉터리 확인\n    while IFS=: read -r username _ uid _ _ homedir shell; do\n        # 로그인 가능한 사용자만 (nologin, false 제외)\n        if [[ \"$shell\" != \"/bin/false\" && \"$shell\" != \"/sbin/nologin\" && \"$homedir\" != \"\" && -d \"$homedir\" ]]; then\n            \n            for start_file in \"${start_files[@]}\"; do\n                file_path=\"$homedir/$start_file\"\n                \n                if [ -f \"$file_path\" ]; then\n                    # 파일 소유자 확인\n                    file_owner=$(stat -c \"%U\" \"$file_path\" 2>/dev/null)\n                    file_perm=$(stat -c \"%a\" \"$file_path\" 2>/dev/null)\n                    \n                    # 소유자가 root 또는 해당 사용자가 아닌 경우\n                    if [ \"$file_owner\" != \"root\" ] && [ \"$file_owner\" != \"$username\" ]; then\n                        VULNERABLE=1\n                        VULN_REASONS=\"$VULN_REASONS- $file_path 파일 소유자가 부적절함 (소유자: $file_owner, 해당사용자: $username) → 권장: chown $username $file_path\\n\"\n                    fi\n                    \n                    # other 권한에 쓰기 권한이 있는지 확인 (마지막 자리가 2,3,6,7인 경우)\n                    if [ -n \"$file_perm\" ]; then\n                        other_perm=$((file_perm % 10))\n                        if [ $((other_perm & 2)) -ne 0 ]; then\n                            VULNERABLE=1\n                            VULN_REASONS=\"$VULN_REASONS- $file_path 파일에 other 쓰기 권한 있음 (권한: $file_perm) → 권장: chmod o-w $file_path\\n\"\n                        fi\n                    fi\n                fi\n            done\n        fi\n    done < /etc/passwd\n    \n    # /home 디렉터리의 추가 사용자 디렉터리 확인\n    if [ -d \"/home\" ]; then\n        for user_dir in /home/*; do\n            if [ -d \"$user_dir\" ]; then\n                username=$(basename \"$user_dir\")\n                \n                for start_file in \"${start_files[@]}\"; do\n                    file_path=\"$user_dir/$start_file\"\n                    \n                    if [ -f \"$file_path\" ]; then\n                        file_owner=$(stat -c \"%U\" \"$file_path\" 2>/dev/null)\n                        file_perm=$(stat -c \"%a\" \"$file_path\" 2>/dev/null)\n                        \n                        # 소유자 확인\n                        if [ \"$file_owner\" != \"root\" ] && [ \"$file_owner\" != \"$username\" ]; then\n                            VULNERABLE=1\n                            VULN_REASONS=\"$VULN_REASONS- $file_path 파일 소유자가 부적절함 (소유자: $file_owner) → 권장: chown $username $file_path\\n\"\n                        fi\n                        \n                        # other 쓰기 권한 확인\n                        if [ -n \"$file_perm\" ]; then\n                            other_perm=$((file_perm % 10))\n                            if [ $((other_perm & 2)) -ne 0 ]; then\n                                VULNERABLE=1\n                                VULN_REASONS=\"$VULN_REASONS- $file_path 파일에 other 쓰기 권한 있음 (권한: $file_perm) → 권장: chmod o-w $file_path\\n\"\n                            fi\n                        fi\n                    fi\n                done\n            fi\n        done\n    fi\n    \n    # 최종 결과 출력\n    if [ $VULNERABLE -eq 1 ]; then\n        echo \"U-14 최종 결과: 취약\" >> $resultfile 2>&1\n        echo \"취약 이유:\" >> $resultfile 2>&1\n        echo -e \"$VULN_REASONS\" >> $resultfile 2>&1\n    else\n        echo \"U-14 최종 결과: 양호\" >> $resultfile 2>&1\n    fi\n    \n    return $VULNERABLE\n}"
      },
      {
        "id": "section_26",
        "name": "u_15",
        "description": "u_15 함수 실행",
        "content": "u_15() {\n    echo \"U-15: world writable 파일 점검\" >> $resultfile 2>&1\n    VULNERABLE=0\n    VULN_REASONS=\"\"\n    \n    # /proc, /sys, /dev 등 시스템 디렉터리 제외하고 전체 검색\n    world_writable=$(find / -type f -perm -002 ! -path \"/proc/*\" ! -path \"/sys/*\" ! -path \"/dev/*\" ! -path \"/run/*\" ! -path \"/tmp/*\" 2>/dev/null)\n    \n    if [ -n \"$world_writable\" ]; then\n        VULNERABLE=1\n        echo \"world writable 파일 발견:\" >> $resultfile 2>&1\n        echo \"$world_writable\" | while read file; do\n            if [ -f \"$file\" ]; then\n                file_perm=$(stat -c \"%a\" \"$file\" 2>/dev/null)\n                file_owner=$(stat -c \"%U:%G\" \"$file\" 2>/dev/null)\n                echo \"  $file (권한:$file_perm, 소유자:$file_owner)\" >> $resultfile 2>&1\n            fi\n        done\n        \n        file_count=$(echo \"$world_writable\" | wc -l)\n        VULN_REASONS=\"$VULN_REASONS- world writable 파일 $file_count개 발견 → 권장: chmod o-w [파일명] 으로 쓰기 권한 제거\\n\"\n    fi\n    \n    # /tmp 디렉터리 별도 확인 (sticky bit 있는지)\n    if [ -d \"/tmp\" ]; then\n        tmp_perm=$(stat -c \"%a\" /tmp 2>/dev/null)\n        if [ -n \"$tmp_perm\" ]; then\n            # sticky bit (1000번대) 확인\n            if [ \"$tmp_perm\" -lt 1000 ]; then\n                VULNERABLE=1\n                VULN_REASONS=\"$VULN_REASONS- /tmp 디렉터리에 sticky bit가 설정되지 않음 (현재: $tmp_perm) → 권장: chmod 1777 /tmp\\n\"\n            fi\n        fi\n    fi\n    \n    # 홈 디렉터리 내 world writable 파일 확인\n    if [ -d \"/home\" ]; then\n        home_writable=$(find /home -type f -perm -002 2>/dev/null)\n        if [ -n \"$home_writable\" ]; then\n            VULNERABLE=1\n            echo \"홈 디렉터리 내 world writable 파일:\" >> $resultfile 2>&1\n            echo \"$home_writable\" | while read file; do\n                echo \"  $file\" >> $resultfile 2>&1\n            done\n            VULN_REASONS=\"$VULN_REASONS- 홈 디렉터리에 world writable 파일 발견 → 권장: 권한 조정 필요\\n\"\n        fi\n    fi\n    \n    # 최종 결과 출력\n    if [ $VULNERABLE -eq 1 ]; then\n        echo \"U-15 최종 결과: 취약\" >> $resultfile 2>&1\n        echo \"취약 이유:\" >> $resultfile 2>&1\n        echo -e \"$VULN_REASONS\" >> $resultfile 2>&1\n        echo \"참고: find / -type f -perm -002 명령으로 전체 확인 가능\" >> $resultfile 2>&1\n    else\n        echo \"U-15 최종 결과: 양호\" >> $resultfile 2>&1\n    fi\n    \n    return $VULNERABLE\n}"
      },
      {
        "id": "section_27",
        "name": "u_16",
        "description": "u_16 함수 실행",
        "content": "u_16() {\n    echo \"U-16: /dev에 존재하지 않는 device 파일 점검\" >> $resultfile 2>&1\n    VULNERABLE=0\n    VULN_REASONS=\"\"\n    \n    if [ -d \"/dev\" ]; then\n        # /dev 디렉터리에서 일반 파일(regular file) 검색\n        regular_files=$(find /dev -type f 2>/dev/null)\n        \n        if [ -n \"$regular_files\" ]; then\n            VULNERABLE=1\n            echo \"/dev 디렉터리에서 일반 파일 발견:\" >> $resultfile 2>&1\n            \n            echo \"$regular_files\" | while read file; do\n                if [ -f \"$file\" ]; then\n                    file_perm=$(stat -c \"%a\" \"$file\" 2>/dev/null)\n                    file_owner=$(stat -c \"%U:%G\" \"$file\" 2>/dev/null)\n                    file_size=$(stat -c \"%s\" \"$file\" 2>/dev/null)\n                    echo \"  $file (권한:$file_perm, 소유자:$file_owner, 크기:${file_size}bytes)\" >> $resultfile 2>&1\n                fi\n            done\n            \n            file_count=$(echo \"$regular_files\" | wc -l)\n            VULN_REASONS=\"$VULN_REASONS- /dev 디렉터리에 일반 파일 $file_count개 발견 → 권장: 파일 확인 후 제거 또는 적절한 위치로 이동\\n\"\n        fi\n        \n        # 추가로 의심스러운 실행 파일 확인\n        executable_files=$(find /dev -type f -executable 2>/dev/null)\n        if [ -n \"$executable_files\" ]; then\n            VULNERABLE=1\n            echo \"/dev 디렉터리에서 실행 가능한 파일 발견:\" >> $resultfile 2>&1\n            echo \"$executable_files\" | while read file; do\n                echo \"  $file\" >> $resultfile 2>&1\n            done\n            VULN_REASONS=\"$VULN_REASONS- /dev 디렉터리에 실행 파일 발견 → 권장: 즉시 제거 (보안 위험)\\n\"\n        fi\n        \n        # 숨겨진 파일 확인\n        hidden_files=$(find /dev -name \".*\" -type f 2>/dev/null)\n        if [ -n \"$hidden_files\" ]; then\n            VULNERABLE=1\n            echo \"/dev 디렉터리에서 숨겨진 파일 발견:\" >> $resultfile 2>&1\n            echo \"$hidden_files\" | while read file; do\n                echo \"  $file\" >> $resultfile 2>&1\n            done\n            VULN_REASONS=\"$VULN_REASONS- /dev 디렉터리에 숨겨진 파일 발견 → 권장: 파일 확인 후 제거\\n\"\n        fi\n        \n    else\n        VULNERABLE=1\n        VULN_REASONS=\"$VULN_REASONS- /dev 디렉터리가 존재하지 않음\\n\"\n    fi\n    \n    # 최종 결과 출력\n    if [ $VULNERABLE -eq 1 ]; then\n        echo \"U-16 최종 결과: 취약\" >> $resultfile 2>&1\n        echo \"취약 이유:\" >> $resultfile 2>&1\n        echo -e \"$VULN_REASONS\" >> $resultfile 2>&1\n        echo \"참고: /dev 디렉터리에는 디바이스 파일만 존재해야 합니다\" >> $resultfile 2>&1\n    else\n        echo \"U-16 최종 결과: 양호\" >> $resultfile 2>&1\n        echo \"/dev 디렉터리에 일반 파일이 존재하지 않습니다\" >> $resultfile 2>&1\n    fi\n    \n    return $VULNERABLE\n}"
      },
      {
        "id": "section_28",
        "name": "u_17",
        "description": "u_17 함수 실행",
        "content": "u_17() {\n    echo \"U-17: \\$HOME/.rhosts, hosts.equiv 사용 금지\" >> $resultfile 2>&1\n    VULNERABLE=0\n    VULN_REASONS=\"\"\n\n    # r-command 서비스 사용 여부 확인\n    rlogin_running=$(ps aux | grep -E \"(rlogind|rshd)\" | grep -v grep 2>/dev/null)\n    if [ -n \"$rlogin_running\" ]; then\n        echo \"r-command 서비스 실행 중:\" >> $resultfile 2>&1\n        echo \"$rlogin_running\" >> $resultfile 2>&1\n    else\n        echo \"r-command 서비스가 실행되지 않음\" >> $resultfile 2>&1\n    fi\n\n    # 1. /etc/hosts.equiv 파일 점검\n    if [ -f \"/etc/hosts.equiv\" ]; then\n        echo \"/etc/hosts.equiv 파일이 존재합니다\" >> $resultfile 2>&1\n\n        # 소유자 확인\n        file_owner=$(stat -c \"%U\" /etc/hosts.equiv 2>/dev/null)\n        if [ \"$file_owner\" != \"root\" ]; then\n            VULNERABLE=1\n            VULN_REASONS=\"$VULN_REASONS- /etc/hosts.equiv 파일 소유자가 root가 아님 (현재: $file_owner) → 권장: chown root /etc/hosts.equiv\\n\"\n        fi\n\n        # 권한 확인 (600 이하)\n        file_perm=$(stat -c \"%a\" /etc/hosts.equiv 2>/dev/null)\n        if [ -n \"$file_perm\" ] && [ \"$file_perm\" -gt 600 ]; then\n            VULNERABLE=1\n            VULN_REASONS=\"$VULN_REASONS- /etc/hosts.equiv 파일 권한이 600을 초과함 (현재: $file_perm) → 권장: chmod 600 /etc/hosts.equiv\\n\"\n        fi\n\n        # '+' 설정 확인\n        plus_setting=$(grep -E \"^\\s*\\+\\s*$|^\\s*\\+\\s+\\+\\s*$\" /etc/hosts.equiv 2>/dev/null)\n        if [ -n \"$plus_setting\" ]; then\n            VULNERABLE=1\n            VULN_REASONS=\"$VULN_REASONS- /etc/hosts.equiv 파일에 '+' 설정이 있음 (모든 호스트 허용) → 권장: '+' 설정 제거\\n\"\n            echo \"  위험한 '+' 설정 발견:\" >> $resultfile 2>&1\n            echo \"$plus_setting\" | while read line; do\n                echo \"    $line\" >> $resultfile 2>&1\n            done\n        fi\n\n        # 파일 내용 요약\n        echo \"  /etc/hosts.equiv 파일 정보: 소유자=$file_owner, 권한=$file_perm\" >> $resultfile 2>&1\n    fi\n\n    # 2. 사용자 홈 디렉터리의 .rhosts 파일 점검\n    while IFS=: read -r username _ uid _ _ homedir shell; do\n        if [[ \"$shell\" != \"/bin/false\" && \"$shell\" != \"/sbin/nologin\" && \"$homedir\" != \"\" && -d \"$homedir\" ]]; then\n            rhosts_file=\"$homedir/.rhosts\"\n\n            if [ -f \"$rhosts_file\" ]; then\n                echo \"$username 사용자의 .rhosts 파일이 존재합니다\" >> $resultfile 2>&1\n\n                # 소유자 확인\n                file_owner=$(stat -c \"%U\" \"$rhosts_file\" 2>/dev/null)\n                if [ \"$file_owner\" != \"root\" ] && [ \"$file_owner\" != \"$username\" ]; then\n                    VULNERABLE=1\n                    VULN_REASONS=\"$VULN_REASONS- $rhosts_file 파일 소유자가 부적절함 (소유자: $file_owner) → 권장: chown $username $rhosts_file\\n\"\n                fi\n\n                # 권한 확인 (600 이하)\n                file_perm=$(stat -c \"%a\" \"$rhosts_file\" 2>/dev/null)\n                if [ -n \"$file_perm\" ] && [ \"$file_perm\" -gt 600 ]; then\n                    VULNERABLE=1\n                    VULN_REASONS=\"$VULN_REASONS- $rhosts_file 파일 권한이 600을 초과함 (현재: $file_perm) → 권장: chmod 600 $rhosts_file\\n\"\n                fi\n\n                # '+' 설정 확인\n                plus_setting=$(grep -E \"^\\s*\\+\\s*$|^\\s*\\+\\s+\\+\\s*$\" \"$rhosts_file\" 2>/dev/null)\n                if [ -n \"$plus_setting\" ]; then\n                    VULNERABLE=1\n                    VULN_REASONS=\"$VULN_REASONS- $rhosts_file 파일에 '+' 설정이 있음 (모든 호스트 허용) → 권장: '+' 설정 제거\\n\"\n                    echo \"  $rhosts_file에서 위험한 '+' 설정 발견:\" >> $resultfile 2>&1\n                    echo \"$plus_setting\" | while read line; do\n                        echo \"    $line\" >> $resultfile 2>&1\n                    done\n                fi\n\n                echo \"  $rhosts_file 파일 정보: 소유자=$file_owner, 권한=$file_perm\" >> $resultfile 2>&1\n            fi\n        fi\n    done < /etc/passwd\n\n    # 3. xinetd 또는 inetd에서 r-command 서비스 확인\n    rcommand_services=\"\"\n    if [ -d \"/etc/xinetd.d\" ]; then\n        rcommand_services=$(grep -l \"rlogin\\|rsh\\|rexec\" /etc/xinetd.d/* 2>/dev/null)\n        if [ -n \"$rcommand_services\" ]; then\n            echo \"xinetd에서 r-command 서비스 설정 발견:\" >> $resultfile 2>&1\n            echo \"$rcommand_services\" >> $resultfile 2>&1\n        fi\n    fi\n\n    if [ -f \"/etc/inetd.conf\" ]; then\n        inetd_rcommand=$(grep -E \"^[^#]*rlogin|^[^#]*rsh|^[^#]*rexec\" /etc/inetd.conf 2>/dev/null)\n        if [ -n \"$inetd_rcommand\" ]; then\n            echo \"inetd.conf에서 r-command 서비스 설정 발견:\" >> $resultfile 2>&1\n            echo \"$inetd_rcommand\" >> $resultfile 2>&1\n            VULN_REASONS=\"$VULN_REASONS- inetd.conf에서 r-command 서비스가 활성화됨 → 권장: 서비스 비활성화\\n\"\n        fi\n    fi\n\n    # 최종 결과 출력\n    if [ $VULNERABLE -eq 1 ]; then\n        echo \"U-17 최종 결과: 취약\" >> $resultfile 2>&1\n        echo \"취약 이유:\" >> $resultfile 2>&1\n        echo -e \"$VULN_REASONS\" >> $resultfile 2>&1\n        echo \"권장사항: r-command 서비스를 SSH로 대체하는 것을 권장합니다\" >> $resultfile 2>&1\n    else\n        if [ ! -f \"/etc/hosts.equiv\" ] && [ -z \"$(find /home -name \".rhosts\" -type f 2>/dev/null)\" ]; then\n            echo \"U-17 최종 결과: 양호\" >> $resultfile 2>&1\n            echo \"hosts.equiv 및 .rhosts 파일이 존재하지 않습니다\" >> $resultfile 2>&1\n        else\n            echo \"U-17 최종 결과: 양호\" >> $resultfile 2>&1\n            echo \"r-command 관련 파일들이 안전하게 설정되어 있습니다\" >> $resultfile 2>&1\n        fi\n    fi\n\n    return $VULNERABLE\n}"
      },
      {
        "id": "section_29",
        "name": "u_18",
        "description": "u_18 함수 실행",
        "content": "u_18() {\n    echo \"U-18: 접속 IP 및 포트 제한\" >> $resultfile 2>&1\n    VULNERABLE=0\n    VULN_REASONS=\"\"\n    \n    # 1. /etc/hosts.deny 파일 점검\n    if [ -f \"/etc/hosts.deny\" ]; then\n        # 소유자 확인\n        hosts_deny_owner=$(stat -c \"%U\" /etc/hosts.deny 2>/dev/null)\n        if [ \"$hosts_deny_owner\" != \"root\" ]; then\n            VULNERABLE=1\n            VULN_REASONS=\"$VULN_REASONS- /etc/hosts.deny 파일의 소유자가 root가 아님 (현재: $hosts_deny_owner) → 권장: chown root /etc/hosts.deny\\n\"\n        fi\n        \n        # ALL:ALL 설정 확인\n        if ! grep -vE '^[[:space:]]*#|^[[:space:]]*$' /etc/hosts.deny 2>/dev/null | grep -qiE '^[[:space:]]*ALL[[:space:]]*:[[:space:]]*ALL[[:space:]]*'; then\n            VULNERABLE=1\n            VULN_REASONS=\"$VULN_REASONS- /etc/hosts.deny에 ALL:ALL 설정이 없음 → 권장: 'ALL:ALL' 설정 추가\\n\"\n        fi\n    else\n        VULNERABLE=1\n        VULN_REASONS=\"$VULN_REASONS- /etc/hosts.deny 파일이 존재하지 않음 → 권장: 파일 생성 후 'ALL:ALL' 설정\\n\"\n    fi\n    \n    # 2. /etc/hosts.allow 파일 점검\n    if [ -f \"/etc/hosts.allow\" ]; then\n        # 소유자 확인\n        hosts_allow_owner=$(stat -c \"%U\" /etc/hosts.allow 2>/dev/null)\n        if [ \"$hosts_allow_owner\" != \"root\" ]; then\n            VULNERABLE=1\n            VULN_REASONS=\"$VULN_REASONS- /etc/hosts.allow 파일의 소유자가 root가 아님 (현재: $hosts_allow_owner) → 권장: chown root /etc/hosts.allow\\n\"\n        fi\n        \n        # 위험한 ALL:ALL 설정 확인\n        if grep -vE '^[[:space:]]*#|^[[:space:]]*$' /etc/hosts.allow 2>/dev/null | grep -qiE '^[[:space:]]*ALL[[:space:]]*:[[:space:]]*ALL[[:space:]]*'; then\n            VULNERABLE=1\n            VULN_REASONS=\"$VULN_REASONS- /etc/hosts.allow에 ALL:ALL 설정이 있음 (모든 접근 허용) → 권장: 특정 IP/서비스만 허용하도록 수정\\n\"\n        fi\n    fi\n    \n    # 3. iptables 방화벽 점검\n    if command -v iptables >/dev/null 2>&1; then\n        # INPUT 체인 기본 정책 확인\n        input_policy=$(iptables -L INPUT -n 2>/dev/null | head -1)\n        if [ -n \"$input_policy\" ]; then\n            if echo \"$input_policy\" | grep -q \"policy ACCEPT\"; then\n                VULNERABLE=1\n                VULN_REASONS=\"$VULN_REASONS- iptables INPUT 체인 기본 정책이 ACCEPT로 설정됨 → 권장: iptables -P INPUT DROP\\n\"\n            fi\n        fi\n    else\n        VULNERABLE=1\n        VULN_REASONS=\"$VULN_REASONS- iptables 방화벽이 설치되지 않음 → 권장: 방화벽 설치 및 설정\\n\"\n    fi\n    \n    # 4. UFW 방화벽 점검\n    if command -v ufw >/dev/null 2>&1; then\n        ufw_status=$(ufw status 2>/dev/null)\n        if [ -n \"$ufw_status\" ]; then\n            if echo \"$ufw_status\" | grep -q \"Status: inactive\"; then\n                VULNERABLE=1\n                VULN_REASONS=\"$VULN_REASONS- UFW 방화벽이 비활성화되어 있음 → 권장: ufw enable\\n\"\n            fi\n        fi\n    fi\n    \n    # 최종 결과 출력\n    if [ $VULNERABLE -eq 1 ]; then\n        echo \"U-18 최종 결과: 취약\" >> $resultfile 2>&1\n        echo \"취약 이유:\" >> $resultfile 2>&1\n        printf \"%b\" \"$VULN_REASONS\" >> $resultfile 2>&1\n    else\n        echo \"U-18 최종 결과: 양호\" >> $resultfile 2>&1\n    fi\n    \n    return $VULNERABLE\n}"
      },
      {
        "id": "section_30",
        "name": "u_55",
        "description": "u_55 함수 실행",
        "content": "u_55() {\n    echo \"U-55: hosts.lpd 파일 소유자 및 권한 설정\" >> $resultfile 2>&1\n    VULNERABLE=0\n    VULN_REASONS=\"\"\n    \n    # /etc/hosts.lpd 파일 점검\n    if [ -f \"/etc/hosts.lpd\" ]; then\n        # 소유자 확인\n        hosts_lpd_owner=$(stat -c \"%U\" /etc/hosts.lpd 2>/dev/null)\n        if [ \"$hosts_lpd_owner\" != \"root\" ]; then\n            VULNERABLE=1\n            VULN_REASONS=\"$VULN_REASONS- /etc/hosts.lpd 파일 소유자가 root가 아님 (현재: $hosts_lpd_owner) → 권장: chown root /etc/hosts.lpd\\n\"\n        fi\n        \n        # 그룹 확인\n        hosts_lpd_group=$(stat -c \"%G\" /etc/hosts.lpd 2>/dev/null)\n        if [ \"$hosts_lpd_group\" != \"root\" ]; then\n            VULNERABLE=1\n            VULN_REASONS=\"$VULN_REASONS- /etc/hosts.lpd 파일 그룹이 root가 아님 (현재: $hosts_lpd_group) → 권장: chgrp root /etc/hosts.lpd\\n\"\n        fi\n        \n        # 권한 확인 (600 이하)\n        hosts_lpd_perm=$(stat -c \"%a\" /etc/hosts.lpd 2>/dev/null)\n        if [ -n \"$hosts_lpd_perm\" ] && [[ \"$hosts_lpd_perm\" =~ ^[0-9]+$ ]]; then\n            if [ \"$hosts_lpd_perm\" -gt 600 ]; then\n                VULNERABLE=1\n                VULN_REASONS=\"$VULN_REASONS- /etc/hosts.lpd 파일 권한이 600을 초과함 (현재: $hosts_lpd_perm) → 권장: chmod 600 /etc/hosts.lpd\\n\"\n            fi\n        fi\n        \n        echo \"/etc/hosts.lpd 파일이 존재합니다 - 권한 점검 완료\" >> $resultfile 2>&1\n    else\n        echo \"/etc/hosts.lpd 파일이 존재하지 않습니다 (양호)\" >> $resultfile 2>&1\n    fi\n    \n    # 최종 결과 출력\n    if [ $VULNERABLE -eq 1 ]; then\n        echo \"U-55 최종 결과: 취약\" >> $resultfile 2>&1\n        echo \"취약 이유:\" >> $resultfile 2>&1\n        printf \"%b\" \"$VULN_REASONS\" >> $resultfile 2>&1\n    else\n        echo \"U-55 최종 결과: 양호\" >> $resultfile 2>&1\n    fi\n    \n    return $VULNERABLE\n}"
      },
      {
        "id": "section_31",
        "name": "u_56",
        "description": "u_56 함수 실행",
        "content": "u_56() {\n    echo \"U-56: UMASK 설정 관리\" >> $resultfile 2>&1\n    VULNERABLE=0\n    VULN_REASONS=\"\"\n    \n    # 1. 현재 umask 값 확인\n    if command -v umask >/dev/null 2>&1; then\n        current_umask=$(umask 2>/dev/null)\n        if [ -n \"$current_umask\" ]; then\n            # 4자리로 맞춤 (예: 22 -> 0022)\n            while [ ${#current_umask} -lt 4 ]; do\n                current_umask=\"0${current_umask}\"\n            done\n            \n            # group 권한 확인 (3번째 자리)\n            group_digit=\"${current_umask:2:1}\"\n            if [ \"$group_digit\" -lt 2 ]; then\n                VULNERABLE=1\n                VULN_REASONS=\"$VULN_REASONS- 현재 UMASK의 그룹 사용자 권한이 취약함 (현재: $current_umask) → 권장: umask 022 설정\\n\"\n            fi\n            \n            # other 권한 확인 (4번째 자리)\n            other_digit=\"${current_umask:3:1}\"\n            if [ \"$other_digit\" -lt 2 ]; then\n                VULNERABLE=1\n                VULN_REASONS=\"$VULN_REASONS- 현재 UMASK의 다른 사용자 권한이 취약함 (현재: $current_umask) → 권장: umask 022 설정\\n\"\n            fi\n            \n            echo \"현재 UMASK: $current_umask\" >> $resultfile 2>&1\n        else\n            VULNERABLE=1\n            VULN_REASONS=\"$VULN_REASONS- 현재 UMASK 값을 확인할 수 없음 → 권장: umask 022 설정\\n\"\n        fi\n    fi\n    \n    # 2. /etc/login.defs 파일에서 UMASK 설정 확인\n    if [ -f \"/etc/login.defs\" ]; then\n        login_defs_umask=$(grep -v \"^#\" /etc/login.defs 2>/dev/null | grep -i \"^UMASK\" | awk '{print $2}' | tail -1)\n        if [ -n \"$login_defs_umask\" ]; then\n            # 4자리로 맞춤\n            while [ ${#login_defs_umask} -lt 4 ]; do\n                login_defs_umask=\"0${login_defs_umask}\"\n            done\n            \n            # group 권한 확인\n            group_digit=\"${login_defs_umask:2:1}\"\n            if [ \"$group_digit\" -lt 2 ]; then\n                VULNERABLE=1\n                VULN_REASONS=\"$VULN_REASONS- /etc/login.defs의 UMASK 그룹 권한이 취약함 (현재: $login_defs_umask) → 권장: UMASK 022로 변경\\n\"\n            fi\n            \n            # other 권한 확인\n            other_digit=\"${login_defs_umask:3:1}\"\n            if [ \"$other_digit\" -lt 2 ]; then\n                VULNERABLE=1\n                VULN_REASONS=\"$VULN_REASONS- /etc/login.defs의 UMASK 다른 사용자 권한이 취약함 (현재: $login_defs_umask) → 권장: UMASK 022로 변경\\n\"\n            fi\n            \n            echo \"/etc/login.defs UMASK: $login_defs_umask\" >> $resultfile 2>&1\n        else\n            VULNERABLE=1\n            VULN_REASONS=\"$VULN_REASONS- /etc/login.defs에 UMASK 설정이 없음 → 권장: UMASK 022 추가\\n\"\n        fi\n    fi\n    \n    # 3. /etc/profile에서 umask 설정 확인\n    if [ -f \"/etc/profile\" ]; then\n        profile_umask=$(grep -v \"^#\" /etc/profile 2>/dev/null | grep -i \"umask\" | grep -o \"[0-9][0-9][0-9]\" | tail -1)\n        if [ -n \"$profile_umask\" ]; then\n            # 4자리로 맞춤\n            while [ ${#profile_umask} -lt 4 ]; do\n                profile_umask=\"0${profile_umask}\"\n            done\n            \n            # group 권한 확인\n            group_digit=\"${profile_umask:2:1}\"\n            if [ \"$group_digit\" -lt 2 ]; then\n                VULNERABLE=1\n                VULN_REASONS=\"$VULN_REASONS- /etc/profile의 umask 그룹 권한이 취약함 (현재: $profile_umask) → 권장: umask 022로 변경\\n\"\n            fi\n            \n            # other 권한 확인\n            other_digit=\"${profile_umask:3:1}\"\n            if [ \"$other_digit\" -lt 2 ]; then\n                VULNERABLE=1\n                VULN_REASONS=\"$VULN_REASONS- /etc/profile의 umask 다른 사용자 권한이 취약함 (현재: $profile_umask) → 권장: umask 022로 변경\\n\"\n            fi\n            \n            echo \"/etc/profile umask: $profile_umask\" >> $resultfile 2>&1\n        fi\n    fi\n    \n    # 최종 결과 출력\n    if [ $VULNERABLE -eq 1 ]; then\n        echo \"U-56 최종 결과: 취약\" >> $resultfile 2>&1\n        echo \"취약 이유:\" >> $resultfile 2>&1\n        printf \"%b\" \"$VULN_REASONS\" >> $resultfile 2>&1\n    else\n        echo \"U-56 최종 결과: 양호\" >> $resultfile 2>&1\n    fi\n    \n    return $VULNERABLE\n}"
      },
      {
        "id": "section_32",
        "name": "u_57",
        "description": "u_57 함수 실행",
        "content": "u_57() {\n    echo \"U-57: 홈디렉토리 소유자 및 권한 설정\" >> $resultfile 2>&1\n    VULNERABLE=0\n    VULN_REASONS=\"\"\n    \n    # /etc/passwd 파일에서 /home 하위 홈 디렉터리만 필터링 (시스템 디렉터리 제외)\n    user_homedirectory_path=($(awk -F : '$7!=\"/bin/false\" && $7!=\"/sbin/nologin\" && $6~/^\\/home\\// {print $6}' /etc/passwd 2>/dev/null))\n    \n    # /home 디렉터리 내 위치한 홈 디렉터리 배열 생성\n    if [ -d \"/home\" ]; then\n        user_homedirectory_path2=($(ls -d /home/* 2>/dev/null | grep -v \"lost+found\"))\n    else\n        user_homedirectory_path2=()\n    fi\n    \n    # 두 개의 배열 합침\n    for ((i=0; i<${#user_homedirectory_path2[@]}; i++)); do\n        if [ -d \"${user_homedirectory_path2[$i]}\" ] && [ \"${user_homedirectory_path2[$i]}\" != \"/home\" ]; then\n            user_homedirectory_path[${#user_homedirectory_path[@]}]=\"${user_homedirectory_path2[$i]}\"\n        fi\n    done\n    \n    # /etc/passwd 파일에서 /home 하위 사용자명만 필터링\n    user_homedirectory_owner_name=($(awk -F : '$7!=\"/bin/false\" && $7!=\"/sbin/nologin\" && $6~/^\\/home\\// {print $1}' /etc/passwd 2>/dev/null))\n    \n    # user_homedirectory_path2 배열에서 사용자명만 따로 출력하여 배열에 저장\n    for ((i=0; i<${#user_homedirectory_path2[@]}; i++)); do\n        if [ -d \"${user_homedirectory_path2[$i]}\" ] && [ \"${user_homedirectory_path2[$i]}\" != \"/home\" ]; then\n            dirname=$(echo \"${user_homedirectory_path2[$i]}\" | awk -F / '{print $3}')\n            if [ -n \"$dirname\" ]; then\n                user_homedirectory_owner_name[${#user_homedirectory_owner_name[@]}]=\"$dirname\"\n            fi\n        fi\n    done\n    \n    # 각 홈 디렉터리 점검\n    if [ ${#user_homedirectory_path[@]} -eq 0 ]; then\n        echo \"점검할 홈 디렉터리가 없음\" >> $resultfile 2>&1\n        echo \"U-57 최종 결과: 양호\" >> $resultfile 2>&1\n        return 0\n    fi\n    \n    for ((i=0; i<${#user_homedirectory_path[@]}; i++)); do\n        if [ -d \"${user_homedirectory_path[$i]}\" ]; then\n            # 실제 소유자 확인\n            homedirectory_owner_name=$(ls -ld \"${user_homedirectory_path[$i]}\" 2>/dev/null | awk '{print $3}')\n            \n            # 소유자 일치 여부 확인\n            if [[ ! \"$homedirectory_owner_name\" =~ ${user_homedirectory_owner_name[$i]} ]]; then\n                VULNERABLE=1\n                VULN_REASONS=\"$VULN_REASONS- ${user_homedirectory_path[$i]} 홈 디렉터리의 소유자가 ${user_homedirectory_owner_name[$i]}이(가) 아닙니다 (현재: $homedirectory_owner_name) → 권장: chown ${user_homedirectory_owner_name[$i]} ${user_homedirectory_path[$i]}\\n\"\n            fi\n            \n            # stat 명령어로 other 권한 확인\n            homedirectory_other_permission=$(stat \"${user_homedirectory_path[$i]}\" 2>/dev/null | grep -i 'Uid' | awk '{print $2}' | awk -F / '{print substr($1,5,1)}')\n            \n            # other 쓰기 권한이 있는 경우 (7,6,3,2) - 숫자인지 확인 후 비교\n            if [ -n \"$homedirectory_other_permission\" ] && [[ \"$homedirectory_other_permission\" =~ ^[0-9]+$ ]]; then\n                if [ \"$homedirectory_other_permission\" -eq 7 ] || [ \"$homedirectory_other_permission\" -eq 6 ] || [ \"$homedirectory_other_permission\" -eq 3 ] || [ \"$homedirectory_other_permission\" -eq 2 ]; then\n                    VULNERABLE=1\n                    VULN_REASONS=\"$VULN_REASONS- ${user_homedirectory_path[$i]} 홈 디렉터리에 다른 사용자(other)의 쓰기 권한이 부여되어 있습니다 → 권장: chmod o-w ${user_homedirectory_path[$i]}\\n\"\n                fi\n            fi\n        fi\n    done\n    \n    # 최종 결과 출력\n    if [ $VULNERABLE -eq 1 ]; then\n        echo \"U-57 최종 결과: 취약\" >> $resultfile 2>&1\n        echo \"취약 이유:\" >> $resultfile 2>&1\n        printf \"%b\" \"$VULN_REASONS\" >> $resultfile 2>&1\n    else\n        echo \"U-57 최종 결과: 양호\" >> $resultfile 2>&1\n    fi\n    \n    return $VULNERABLE\n}"
      },
      {
        "id": "section_33",
        "name": "u_58",
        "description": "u_58 함수 실행",
        "content": "u_58() {\n    echo \"U-58: 홈디렉토리로 지정한 디렉토리의 존재 관리\" >> $resultfile 2>&1\n    VULNERABLE=0\n    VULN_COUNT=0\n    \n    # 카테고리별 카운터\n    not_set_count=0      # 홈디렉토리 미설정\n    root_set_count=0     # 루트(/) 설정\n    not_exist_count=0    # 디렉토리 존재하지 않음\n    orphan_count=0       # /home에 있지만 미등록\n    \n    # /etc/passwd에서 홈 디렉토리 정보 수집\n    while IFS=: read -r username _ uid _ _ homedir shell; do\n        # 로그인 가능한 사용자만 확인 (nologin, false 제외)\n        if [[ \"$shell\" != \"/bin/false\" && \"$shell\" != \"/sbin/nologin\" ]]; then\n            \n            # 홈 디렉토리가 설정되지 않은 경우 (빈 값)\n            if [ -z \"$homedir\" ]; then\n                VULNERABLE=1\n                VULN_COUNT=$((VULN_COUNT + 1))\n                not_set_count=$((not_set_count + 1))\n            # 홈 디렉토리가 루트(/)로 설정된 경우\n            elif [ \"$homedir\" = \"/\" ]; then\n                VULNERABLE=1\n                VULN_COUNT=$((VULN_COUNT + 1))\n                root_set_count=$((root_set_count + 1))\n            else\n                # 홈 디렉토리가 존재하지 않는 경우\n                if [ ! -d \"$homedir\" ]; then\n                    VULNERABLE=1\n                    VULN_COUNT=$((VULN_COUNT + 1))\n                    not_exist_count=$((not_exist_count + 1))\n                fi\n            fi\n        fi\n    done < /etc/passwd\n    \n    # 추가로 /home 디렉토리에 있지만 /etc/passwd에 등록되지 않은 디렉토리 확인\n    if [ -d \"/home\" ]; then\n        for user_dir in /home/*; do\n            if [ -d \"$user_dir\" ]; then\n                dirname=$(basename \"$user_dir\")\n                \n                # /etc/passwd에서 해당 사용자 확인\n                if ! grep -q \"^$dirname:\" /etc/passwd 2>/dev/null; then\n                    VULNERABLE=1\n                    VULN_COUNT=$((VULN_COUNT + 1))\n                    orphan_count=$((orphan_count + 1))\n                fi\n            fi\n        done\n    fi\n    \n    # 최종 결과 출력\n    if [ $VULNERABLE -eq 1 ]; then\n        echo \"U-58 최종 결과: 취약 (취약 항목 $VULN_COUNT개)\" >> $resultfile 2>&1\n        if [ $not_set_count -gt 0 ]; then\n            echo \"- 홈디렉토리 미설정: ${not_set_count}개\" >> $resultfile 2>&1\n        fi\n        if [ $root_set_count -gt 0 ]; then\n            echo \"- 홈디렉토리 /로 설정: ${root_set_count}개\" >> $resultfile 2>&1\n        fi\n        if [ $not_exist_count -gt 0 ]; then\n            echo \"- 홈디렉토리 존재하지 않음: ${not_exist_count}개\" >> $resultfile 2>&1\n        fi\n        if [ $orphan_count -gt 0 ]; then\n            echo \"- /home에 미등록 디렉토리: ${orphan_count}개\" >> $resultfile 2>&1\n        fi\n    else\n        echo \"U-58 최종 결과: 양호\" >> $resultfile 2>&1\n    fi\n    \n    return $VULNERABLE\n}"
      },
      {
        "id": "section_34",
        "name": "u_59",
        "description": "u_59 함수 실행",
        "content": "u_59() {\n    echo \"U-59: 숨겨진 파일 및 디렉토리 검색 및 제거\" >> $resultfile 2>&1\n    \n    # 1단계: 사용자 영역 우선 검사 (우선순위 높음)\n    user_hidden_files=$(find /home /tmp /var/tmp -name '.*' -type f 2>/dev/null | wc -l)\n    user_hidden_dirs=$(find /home /tmp /var/tmp -name '.*' -type d 2>/dev/null | wc -l)\n    \n    # 2단계: 전체 시스템 영역 검사 (참고용)\n    total_hidden_files=$(find / -name '.*' -type f 2>/dev/null | wc -l)\n    total_hidden_dirs=$(find / -name '.*' -type d 2>/dev/null | wc -l)\n    \n    # 결과 판단\n    if [ \"$user_hidden_files\" -gt 0 ] || [ \"$user_hidden_dirs\" -gt 0 ]; then\n        echo \"U-59 최종 결과: 취약\" >> $resultfile 2>&1\n        echo \"※ 우선 조치 권장 영역:\" >> $resultfile 2>&1\n        echo \"- 사용자 영역 숨겨진 파일: ${user_hidden_files}개\" >> $resultfile 2>&1\n        echo \"- 사용자 영역 숨겨진 디렉토리: ${user_hidden_dirs}개\" >> $resultfile 2>&1\n        echo \"전체 시스템 현황:\" >> $resultfile 2>&1\n        echo \"- 전체 숨겨진 파일: ${total_hidden_files}개\" >> $resultfile 2>&1\n        echo \"- 전체 숨겨진 디렉토리: ${total_hidden_dirs}개\" >> $resultfile 2>&1\n        return 1\n    else\n        echo \"U-59 최종 결과: 양호 (사용자 영역 깨끗함)\" >> $resultfile 2>&1\n        echo \"전체 시스템 현황:\" >> $resultfile 2>&1\n        echo \"- 전체 숨겨진 파일: ${total_hidden_files}개\" >> $resultfile 2>&1\n        echo \"- 전체 숨겨진 디렉토리: ${total_hidden_dirs}개\" >> $resultfile 2>&1\n        return 0\n    fi\n}\n#task 서비스관리 | 취약한 서비스들에 대한 점검"
      },
      {
        "id": "section_35",
        "name": "u_19",
        "description": "u_19 함수 실행",
        "content": "u_19(){\n\n    echo \"U-19: finger 서비스 비활성화\" >> $resultfile 2>&1\n    VULNERABLE=0\n    \n    # systemd 서비스 상태 확인\n    active_finger=$(systemctl list-unit-files | grep -i finger | grep enabled 2>/dev/null)\n    if [ -n \"$active_finger\" ]; then\n        VULNERABLE=1\n    fi\n    \n    # finger 프로세스 실행 확인\n    finger_processes=$(ps aux | grep -i finger | grep -v grep 2>/dev/null)\n    if [ -n \"$finger_processes\" ]; then\n        VULNERABLE=1\n    fi\n    \n    # finger 패키지 설치 여부 확인 (Ubuntu)\n    finger_packages=$(dpkg -l | grep -i finger 2>/dev/null)\n    if [ -n \"$finger_packages\" ]; then\n        VULNERABLE=1\n    fi\n    \n    # 최종 결과\n    if [ $VULNERABLE -eq 1 ]; then\n        echo \"U-19 최종 결과: 취약\" >> $resultfile 2>&1\n        return 1\n    else\n        echo \"U-19 최종 결과: 양호 서비스 비활성화\" >> $resultfile 2>&1\n        return 0\n    fi\n}"
      },
      {
        "id": "section_36",
        "name": "u_20",
        "description": "u_20 함수 실행",
        "content": "u_20() {\n    echo \"U-20: Anonymous FTP 비활성화\" >> $resultfile 2>&1\n    VULNERABLE=0\n    VULN_REASONS=\"\"\n\n    # 1. FTP 서비스 실행 확인\n    ftp_process=$(ps aux | grep -E \"(vsftpd|proftpd|pureftpd|ftpd)\" | grep -v grep)\n    \n    # 2. systemd FTP 서비스 상태 확인\n    ftp_services=$(systemctl list-unit-files 2>/dev/null | grep -E \"(vsftpd|proftpd|pureftpd|ftpd)\" | grep enabled)\n    \n    # 3. FTP 패키지 설치 확인 (Ubuntu)\n    ftp_packages=$(dpkg -l 2>/dev/null | grep -E \"(vsftpd|proftpd|pureftpd)\")\n\n    # FTP 서비스가 활성화되어 있다면 Anonymous 설정 확인\n    if [ -n \"$ftp_process\" ] || [ -n \"$ftp_services\" ] || [ -n \"$ftp_packages\" ]; then\n        \n        # vsftpd 설정 확인\n        if [ -f \"/etc/vsftpd.conf\" ]; then\n            anonymous_enabled=$(grep -E \"^anonymous_enable\\s*=\\s*YES\" /etc/vsftpd.conf 2>/dev/null)\n            if [ -n \"$anonymous_enabled\" ]; then\n                VULNERABLE=1\n                VULN_REASONS=\"${VULN_REASONS}- vsftpd에서 anonymous_enable=YES로 설정됨\\n\"\n            fi\n        fi\n        \n        # proftpd 설정 확인\n        if [ -f \"/etc/proftpd/proftpd.conf\" ] || [ -f \"/etc/proftpd.conf\" ]; then\n            anonymous_user=$(grep -E \"^User\\s+ftp\" /etc/proftpd/proftpd.conf /etc/proftpd.conf 2>/dev/null)\n            if [ -n \"$anonymous_user\" ]; then\n                VULNERABLE=1\n                VULN_REASONS=\"${VULN_REASONS}- proftpd에서 User ftp 설정으로 Anonymous 접근 허용\\n\"\n            fi\n        fi\n        \n        # pureftpd 설정 확인\n        if [ -d \"/etc/pure-ftpd\" ]; then\n            if [ -f \"/etc/pure-ftpd/conf/NoAnonymous\" ]; then\n                no_anonymous=$(cat /etc/pure-ftpd/conf/NoAnonymous 2>/dev/null)\n                if [ \"$no_anonymous\" != \"yes\" ] && [ \"$no_anonymous\" != \"1\" ]; then\n                    VULNERABLE=1\n                    VULN_REASONS=\"${VULN_REASONS}- pure-ftpd에서 NoAnonymous 설정이 비활성화됨\\n\"\n                fi\n            else\n                # NoAnonymous 파일이 없으면 기본적으로 anonymous 허용\n                VULNERABLE=1\n                VULN_REASONS=\"${VULN_REASONS}- pure-ftpd에서 NoAnonymous 설정 파일이 없어 Anonymous 접근 허용\\n\"\n            fi\n        fi\n        \n        # 최종 결과 출력\n        if [ $VULNERABLE -eq 1 ]; then\n            echo \"U-20 최종 결과: 취약\" >> $resultfile 2>&1\n            printf \"%b\" \"$VULN_REASONS\" >> $resultfile 2>&1\n        else\n            echo \"U-20 최종 결과: 양호 (FTP 서비스 존재하나 Anonymous 비활성화)\" >> $resultfile 2>&1\n        fi\n    else\n        # FTP 서비스 자체가 없는 경우\n        echo \"U-20 최종 결과: 양호 (FTP 서비스 비활성화)\" >> $resultfile 2>&1\n    fi\n\n    return $VULNERABLE\n}"
      },
      {
        "id": "section_37",
        "name": "u_21",
        "description": "u_21 함수 실행",
        "content": "u_21() {\n    echo \"U-21: r계열 서비스 비활성화\" >> $resultfile 2>&1\n    VULNERABLE=0\n    VULN_REASONS=\"\"\n\n    # 1. systemd 서비스 상태 확인 (rsh, rlogin, rexec)\n    r_services=$(systemctl list-unit-files 2>/dev/null | grep -E \"(rsh|rlogin|rexec)\" | grep enabled)\n    if [ -n \"$r_services\" ]; then\n        VULNERABLE=1\n        VULN_REASONS=\"${VULN_REASONS}- systemd에서 r계열 서비스가 활성화됨\\n\"\n    fi\n\n    # 2. r계열 프로세스 실행 확인\n    r_process=$(ps aux | grep -E \"(rshd|rlogind|rexecd)\" | grep -v grep)\n    if [ -n \"$r_process\" ]; then\n        VULNERABLE=1\n        VULN_REASONS=\"${VULN_REASONS}- r계열 서비스 프로세스가 실행 중\\n\"\n    fi\n\n    # 3. r계열 패키지 설치 확인 (Ubuntu)\n    r_packages=$(dpkg -l 2>/dev/null | grep -E \"(rsh-server|rsh-client|rlogin)\")\n    if [ -n \"$r_packages\" ]; then\n        VULNERABLE=1\n        VULN_REASONS=\"${VULN_REASONS}- r계열 서비스 패키지가 설치됨\\n\"\n    fi\n\n    # 최종 결과 출력\n    if [ $VULNERABLE -eq 1 ]; then\n        echo \"U-21 최종 결과: 취약\" >> $resultfile 2>&1\n        printf \"%b\" \"$VULN_REASONS\" >> $resultfile 2>&1\n    else\n        echo \"U-21 최종 결과: 양호 서비스 비활성화\" >> $resultfile 2>&1\n    fi\n\n    return $VULNERABLE\n}"
      },
      {
        "id": "section_38",
        "name": "u_22",
        "description": "u_22 함수 실행",
        "content": "u_22() {\n    echo \"U-22: crond 파일 소유자 및 권한 설정\" >> $resultfile 2>&1\n    VULNERABLE=0\n    VULN_REASONS=\"\"\n\n    # /etc/crontab 파일 확인\n    if [ -f \"/etc/crontab\" ]; then\n        # 소유자 확인\n        crontab_owner=$(stat -c \"%U\" /etc/crontab 2>/dev/null)\n        if [ \"$crontab_owner\" != \"root\" ]; then\n            VULNERABLE=1\n            VULN_REASONS=\"${VULN_REASONS}- /etc/crontab 파일의 소유자가 root가 아님 ($crontab_owner)\\n\"\n        fi\n        \n        # 권한 확인 (other 사용자 쓰기 권한 확인)\n        crontab_perm=$(stat -c \"%a\" /etc/crontab 2>/dev/null)\n        if [ -n \"$crontab_perm\" ]; then\n            # 마지막 자리수(other 권한) 추출\n            other_perm=${crontab_perm: -1}\n            # other 사용자에게 쓰기 권한이 있는지 확인 (2, 3, 6, 7)\n            if [ \"$other_perm\" -eq 2 ] || [ \"$other_perm\" -eq 3 ] || [ \"$other_perm\" -eq 6 ] || [ \"$other_perm\" -eq 7 ]; then\n                VULNERABLE=1\n                VULN_REASONS=\"${VULN_REASONS}- /etc/crontab 파일에 other 사용자 쓰기 권한이 부여됨 ($crontab_perm)\\n\"\n            fi\n        fi\n    else\n        # /etc/crontab 파일이 없는 경우는 양호로 처리\n        echo \"U-22 최종 결과: 양호 (/etc/crontab 파일 없음)\" >> $resultfile 2>&1\n        return 0\n    fi\n\n    # 최종 결과 출력\n    if [ $VULNERABLE -eq 1 ]; then\n        echo \"U-22 최종 결과: 취약\" >> $resultfile 2>&1\n        printf \"%b\" \"$VULN_REASONS\" >> $resultfile 2>&1\n    else\n        echo \"U-22 최종 결과: 양호\" >> $resultfile 2>&1\n    fi\n\n    return $VULNERABLE\n}"
      },
      {
        "id": "section_39",
        "name": "u_23",
        "description": "u_23 함수 실행",
        "content": "u_23() {\n    echo \"U-23: DoS 공격 취약 서비스 비활성화\" >> $resultfile 2>&1\n    VULNERABLE=0\n    VULN_REASONS=\"\"\n\n    # DoS 취약 서비스 목록\n    vulnerable_services=(\"echo\" \"discard\" \"daytime\" \"chargen\" \"ntp\" \"snmp\" \"dns\" \"smtp\")\n\n    # 1. systemd 서비스 상태 확인\n    for service in \"${vulnerable_services[@]}\"; do\n        # systemd 서비스 활성화 확인\n        if systemctl list-unit-files 2>/dev/null | grep -E \"^${service}.*enabled\" >/dev/null; then\n            VULNERABLE=1\n            VULN_REASONS=\"${VULN_REASONS}- systemd에서 ${service} 서비스가 활성화됨\\n\"\n        fi\n        \n        # ntp의 경우 ntp.service와 ntpd.service 모두 확인\n        if [ \"$service\" = \"ntp\" ]; then\n            if systemctl list-unit-files 2>/dev/null | grep -E \"^ntpd.*enabled\" >/dev/null; then\n                VULNERABLE=1\n                VULN_REASONS=\"${VULN_REASONS}- systemd에서 ntpd 서비스가 활성화됨\\n\"\n            fi\n        fi\n        \n        # snmp의 경우 snmpd.service 확인\n        if [ \"$service\" = \"snmp\" ]; then\n            if systemctl list-unit-files 2>/dev/null | grep -E \"^snmpd.*enabled\" >/dev/null; then\n                VULNERABLE=1\n                VULN_REASONS=\"${VULN_REASONS}- systemd에서 snmpd 서비스가 활성화됨\\n\"\n            fi\n        fi\n        \n        # dns의 경우 bind9, named 확인\n        if [ \"$service\" = \"dns\" ]; then\n            if systemctl list-unit-files 2>/dev/null | grep -E \"^(bind9|named).*enabled\" >/dev/null; then\n                VULNERABLE=1\n                VULN_REASONS=\"${VULN_REASONS}- systemd에서 DNS 서비스가 활성화됨\\n\"\n            fi\n        fi\n        \n        # smtp의 경우 postfix, sendmail, exim 확인\n        if [ \"$service\" = \"smtp\" ]; then\n            if systemctl list-unit-files 2>/dev/null | grep -E \"^(postfix|sendmail|exim4?).*enabled\" >/dev/null; then\n                VULNERABLE=1\n                VULN_REASONS=\"${VULN_REASONS}- systemd에서 SMTP 서비스가 활성화됨\\n\"\n            fi\n        fi\n    done\n\n    # 2. 실행 중인 프로세스 확인\n    ntpd_process=$(ps aux | grep \"ntpd\" | grep -v grep)\n    if [ -n \"$ntpd_process\" ]; then\n        VULNERABLE=1\n        VULN_REASONS=\"${VULN_REASONS}- ntpd 프로세스가 실행 중\\n\"\n    fi\n\n    snmpd_process=$(ps aux | grep \"snmpd\" | grep -v grep)\n    if [ -n \"$snmpd_process\" ]; then\n        VULNERABLE=1\n        VULN_REASONS=\"${VULN_REASONS}- snmpd 프로세스가 실행 중\\n\"\n    fi\n\n    # DNS 프로세스 확인\n    dns_process=$(ps aux | grep -E \"(named|bind)\" | grep -v grep)\n    if [ -n \"$dns_process\" ]; then\n        VULNERABLE=1\n        VULN_REASONS=\"${VULN_REASONS}- DNS 프로세스가 실행 중\\n\"\n    fi\n\n    # SMTP 프로세스 확인\n    smtp_process=$(ps aux | grep -E \"(postfix|sendmail|exim)\" | grep -v grep)\n    if [ -n \"$smtp_process\" ]; then\n        VULNERABLE=1\n        VULN_REASONS=\"${VULN_REASONS}- SMTP 프로세스가 실행 중\\n\"\n    fi\n\n    # 3. 패키지 설치 확인 (Ubuntu)\n    ntp_package=$(dpkg -l 2>/dev/null | grep -E \"^ii.*ntp[[:space:]]\")\n    if [ -n \"$ntp_package\" ]; then\n        VULNERABLE=1\n        VULN_REASONS=\"${VULN_REASONS}- ntp 패키지가 설치됨\\n\"\n    fi\n\n    snmp_package=$(dpkg -l 2>/dev/null | grep -E \"^ii.*(snmp|snmpd)\")\n    if [ -n \"$snmp_package\" ]; then\n        VULNERABLE=1\n        VULN_REASONS=\"${VULN_REASONS}- snmp 패키지가 설치됨\\n\"\n    fi\n\n    # DNS 패키지 확인\n    dns_package=$(dpkg -l 2>/dev/null | grep -E \"^ii.*(bind9|named)\")\n    if [ -n \"$dns_package\" ]; then\n        VULNERABLE=1\n        VULN_REASONS=\"${VULN_REASONS}- DNS 패키지가 설치됨\\n\"\n    fi\n\n    # SMTP 패키지 확인\n    smtp_package=$(dpkg -l 2>/dev/null | grep -E \"^ii.*(postfix|sendmail|exim4?)\")\n    if [ -n \"$smtp_package\" ]; then\n        VULNERABLE=1\n        VULN_REASONS=\"${VULN_REASONS}- SMTP 패키지가 설치됨\\n\"\n    fi\n\n    # 4. xinetd 설정 확인 (echo, discard, daytime, chargen)\n    if [ -d \"/etc/xinetd.d\" ]; then\n        for service in echo discard daytime chargen; do\n            if [ -f \"/etc/xinetd.d/$service\" ]; then\n                service_disabled=$(grep -E \"disable\\s*=\\s*yes\" \"/etc/xinetd.d/$service\" 2>/dev/null)\n                if [ -z \"$service_disabled\" ]; then\n                    VULNERABLE=1\n                    VULN_REASONS=\"${VULN_REASONS}- /etc/xinetd.d/$service 서비스가 비활성화되지 않음\\n\"\n                fi\n            fi\n        done\n    fi\n\n    # 최종 결과 출력\n    if [ $VULNERABLE -eq 1 ]; then\n        echo \"U-23 최종 결과: 취약\" >> $resultfile 2>&1\n        printf \"%b\" \"$VULN_REASONS\" >> $resultfile 2>&1\n    else\n        echo \"U-23 최종 결과: 양호 \" >> $resultfile 2>&1\n\techo \"echo,discard,daytime,chargen,ntp,snmp,dns,smtp 서비스 외에 dos 취약 서비스가 있으수도 있습니다. 한번더 체크 하기를 바랍니다.\" >> $resultfile 2>&1\n    fi\n\n    return $VULNERABLE\n}"
      },
      {
        "id": "section_40",
        "name": "u_24",
        "description": "u_24 함수 실행",
        "content": "u_24() {\n    echo \"U-24: NFS 서비스 비활성화\" >> $resultfile 2>&1\n    VULNERABLE=0\n    VULN_REASONS=\"\"\n\n    # NFS 관련 서비스 활성화 상태 확인\n    nfs_services=(\"nfs-server\" \"nfs-lock\" \"nfs-idmapd\" \"rpcbind\")\n    \n    for service in \"${nfs_services[@]}\"; do\n        if systemctl is-active \"$service\" >/dev/null 2>&1; then\n            VULNERABLE=1\n            VULN_REASONS=\"${VULN_REASONS}- ${service} 서비스가 활성화됨\\n\"\n        fi\n    done\n\n    # 최종 결과 출력\n    if [ $VULNERABLE -eq 1 ]; then\n        echo \"U-24 최종 결과: 취약\" >> $resultfile 2>&1\n        printf \"%b\" \"$VULN_REASONS\" >> $resultfile 2>&1\n    else\n        echo \"U-24 최종 결과: 양호\" >> $resultfile 2>&1\n    fi\n\n    return $VULNERABLE\n}"
      },
      {
        "id": "section_41",
        "name": "u_25",
        "description": "u_25 함수 실행",
        "content": "u_25() {\n    echo \"U-25: NFS 서비스 접근 통제\" >> $resultfile 2>&1\n    VULNERABLE=0\n    VULN_REASONS=\"\"\n\n    # 1. /etc/exports 파일 존재 여부 확인\n    if [ ! -f \"/etc/exports\" ]; then\n        echo \"U-25 최종 결과: 양호\" >> $resultfile 2>&1\n        return 0\n    fi\n\n    # 2. /etc/exports 파일에서 활성 설정 라인 추출 (주석 제외)\n    active_exports=$(grep -E \"^[^#]\" /etc/exports 2>/dev/null | grep -v \"^$\")\n    \n    if [ -z \"$active_exports\" ]; then\n        echo \"U-25 최종 결과: 양호\" >> $resultfile 2>&1\n        return 0\n    fi\n\n    # 3. 각 공유 설정 라인 검사\n    # 모든 호스트 접근 허용 (*) 확인\n    if echo \"$active_exports\" | grep -E \"\\*|everyone\" >/dev/null; then\n        VULNERABLE=1\n        VULN_REASONS=\"${VULN_REASONS}- 모든 호스트(*)에 대한 접근이 허용됨\\n\"\n    fi\n\n    # no_root_squash 옵션 확인 (보안 취약)\n    if echo \"$active_exports\" | grep \"no_root_squash\" >/dev/null; then\n        VULNERABLE=1\n        VULN_REASONS=\"${VULN_REASONS}- no_root_squash 옵션으로 root 권한 유지됨\\n\"\n    fi\n\n    # 읽기/쓰기 권한과 적절한 호스트 제한 확인\n    if echo \"$active_exports\" | grep -E \"rw\" >/dev/null; then\n        if ! echo \"$active_exports\" | grep -E \"[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+\" >/dev/null; then\n            VULNERABLE=1\n            VULN_REASONS=\"${VULN_REASONS}- 특정 IP 제한 없이 읽기/쓰기 권한 허용\\n\"\n        fi\n    fi\n\n    # 4. /etc/exports 파일 권한 확인\n    exports_perm=$(stat -c \"%a\" /etc/exports 2>/dev/null)\n    if [ \"$exports_perm\" != \"644\" ] && [ \"$exports_perm\" != \"640\" ]; then\n        VULNERABLE=1\n        VULN_REASONS=\"${VULN_REASONS}- /etc/exports 파일 권한이 부적절함 (현재: $exports_perm)\\n\"\n    fi\n\n    # 최종 결과 출력\n    if [ $VULNERABLE -eq 1 ]; then\n        echo \"U-25 최종 결과: 취약\" >> $resultfile 2>&1\n        printf \"%b\" \"$VULN_REASONS\" >> $resultfile 2>&1\n    else\n        echo \"U-25 최종 결과: 양호\" >> $resultfile 2>&1\n    fi\n\n    return $VULNERABLE\n}"
      },
      {
        "id": "section_42",
        "name": "u_26",
        "description": "u_26 함수 실행",
        "content": "u_26() {\n    echo \"U-26: automountd 제거\" >> $resultfile 2>&1\n    VULNERABLE=0\n    VULN_REASONS=\"\"\n\n    # autofs 서비스 활성화 상태 확인\n    if systemctl is-active autofs >/dev/null 2>&1; then\n        VULNERABLE=1\n        VULN_REASONS=\"${VULN_REASONS}- autofs 서비스가 활성화됨\\n\"\n    fi\n\n    # 최종 결과 출력\n    if [ $VULNERABLE -eq 1 ]; then\n        echo \"U-26 최종 결과: 취약\" >> $resultfile 2>&1\n        printf \"%b\" \"$VULN_REASONS\" >> $resultfile 2>&1\n    else\n        echo \"U-26 최종 결과: 양호\" >> $resultfile 2>&1\n    fi\n\n    return $VULNERABLE\n}"
      },
      {
        "id": "section_43",
        "name": "u_27",
        "description": "u_27 함수 실행",
        "content": "u_27() {\n    echo \"U-27: RPC 서비스 확인\" >> $resultfile 2>&1\n    VULNERABLE=0\n    VULN_REASONS=\"\"\n\n    # RPC 관련 서비스 활성화 상태 확인\n    rpc_services=(\"rpcbind\" \"rpc-statd\" \"nfs-lock\" \"nfs-idmapd\")\n    \n    for service in \"${rpc_services[@]}\"; do\n        if systemctl is-active \"$service\" >/dev/null 2>&1; then\n            VULNERABLE=1\n            VULN_REASONS=\"${VULN_REASONS}- ${service} 서비스가 활성화됨\\n\"\n        fi\n    done\n\n    # 최종 결과 출력\n    if [ $VULNERABLE -eq 1 ]; then\n        echo \"U-27 최종 결과: 취약\" >> $resultfile 2>&1\n        printf \"%b\" \"$VULN_REASONS\" >> $resultfile 2>&1\n    else\n        echo \"U-27 최종 결과: 양호\" >> $resultfile 2>&1\n    fi\n\n    return $VULNERABLE\n}"
      },
      {
        "id": "section_44",
        "name": "u_28",
        "description": "u_28 함수 실행",
        "content": "u_28() {\n    echo \"U-28: NIS/NIS+ 점검\" >> $resultfile 2>&1\n    VULNERABLE=0\n    VULN_REASONS=\"\"\n\n    # NIS 관련 서비스 활성화 상태 확인\n    nis_services=(\"ypserv\" \"ypbind\" \"yppasswdd\" \"ypxfrd\" \"ypupdated\")\n    \n    for service in \"${nis_services[@]}\"; do\n        if systemctl is-active \"$service\" >/dev/null 2>&1; then\n            VULNERABLE=1\n            VULN_REASONS=\"${VULN_REASONS}- ${service} 서비스가 활성화됨\\n\"\n        fi\n    done\n\n    # 최종 결과 출력\n    if [ $VULNERABLE -eq 1 ]; then\n        echo \"U-28 최종 결과: 취약 (NIS 서비스 활성화)\" >> $resultfile 2>&1\n        printf \"%b\" \"$VULN_REASONS\" >> $resultfile 2>&1\n    else\n        echo \"U-28 최종 결과: 양호 (NIS 서비스 비활성화, 필요시 NIS+ 사용)\" >> $resultfile 2>&1\n    fi\n\n    return $VULNERABLE\n}"
      },
      {
        "id": "section_45",
        "name": "u_29",
        "description": "u_29 함수 실행",
        "content": "u_29() {\n    echo \"U-29: tftp,talk 서비스 비활성화\" >> $resultfile 2>&1\n    VULNERABLE=0\n    VULN_REASONS=\"\"\n\n    if systemctl status talk ntalk tftp > /dev/null 2>&1;then\n\t    VULNERABLE=1\n\t    VULN_REASONS=\"${VULN_REASONS}- tftp, talk 서비스가 활성화됨\\n\"\n    fi\n\n    # 최종 결과 출력\n    if [ $VULNERABLE -eq 1 ]; then\n        echo \"U-29 최종 결과: 취약 \" >> $resultfile 2>&1\n        printf \"%b\" \"$VULN_REASONS\" >> $resultfile 2>&1\n    else\n        echo \"U-29 최종 결과: 양호 \" >> $resultfile 2>&1\n    fi\n\n    return $VULNERABLE\n}"
      },
      {
        "id": "section_46",
        "name": "u_30",
        "description": "u_30 함수 실행",
        "content": "u_30() {\n    echo \"U-30: sendmail 버전 점검\" >> $resultfile 2>&1\n    VULNERABLE=0\n    VULN_REASONS=\"\"\n\n    # sendmail 설치 여부 확인\n    if ! command -v sendmail >/dev/null 2>&1 && ! dpkg -l sendmail >/dev/null 2>&1; then\n        echo \"U-30 최종 결과: 양호\" >> $resultfile 2>&1\n        return 0\n    fi\n\n    # sendmail 버전 확인\n    if command -v sendmail >/dev/null 2>&1; then\n        sendmail_version=$(sendmail -d0.1 -bt < /dev/null 2>&1 | grep \"Version\" | head -1)\n        if [ -n \"$sendmail_version\" ]; then\n            # 버전 번호 추출 (8.x.x 형태)\n            version_num=$(echo \"$sendmail_version\" | grep -o \"8\\.[0-9]\\+\\.[0-9]\\+\" | head -1)\n            if [ -n \"$version_num\" ]; then\n                major=$(echo \"$version_num\" | cut -d. -f1)\n                minor=$(echo \"$version_num\" | cut -d. -f2)\n                patch=$(echo \"$version_num\" | cut -d. -f3)\n                \n                # 8.15.0 미만을 취약한 버전으로 판단 (최신 버전 기준)\n                if [ \"$major\" -lt 8 ] || ([ \"$major\" -eq 8 ] && [ \"$minor\" -lt 15 ]); then\n                    VULNERABLE=1\n                    VULN_REASONS=\"${VULN_REASONS}- sendmail 취약한 버전 사용 (최신 버전 아님): $version_num\\n\"\n                fi\n            else\n                # 버전을 파싱할 수 없는 경우\n                VULNERABLE=1\n                VULN_REASONS=\"${VULN_REASONS}- sendmail 버전 확인 불가\\n\"\n            fi\n        else\n            # 버전 정보를 얻을 수 없는 경우\n            VULNERABLE=1\n            VULN_REASONS=\"${VULN_REASONS}- sendmail 버전 정보 확인 불가\\n\"\n        fi\n    fi\n\n    # 최종 결과 출력\n    if [ $VULNERABLE -eq 1 ]; then\n        echo \"U-30 최종 결과: 취약\" >> $resultfile 2>&1\n        printf \"%b\" \"$VULN_REASONS\" >> $resultfile 2>&1\n    else\n        echo \"U-30 최종 결과: 양호\" >> $resultfile 2>&1\n    fi\n\n    return $VULNERABLE\n}"
      },
      {
        "id": "section_47",
        "name": "u_31",
        "description": "u_31 함수 실행",
        "content": "u_31() {\n    echo \"U-31: 스팸 메일 릴레이 제한\" >> $resultfile 2>&1\n    VULNERABLE=0\n    VULN_REASONS=\"\"\n\n    # sendmail 설치 여부 확인\n    if ! command -v sendmail >/dev/null 2>&1 && ! dpkg -l sendmail >/dev/null 2>&1; then\n        echo \"U-31 최종 결과: 양호\" >> $resultfile 2>&1\n        return 0\n    fi\n\n    # sendmail.cf 파일 존재 확인\n    sendmail_cf=\"/etc/mail/sendmail.cf\"\n    if [ ! -f \"$sendmail_cf\" ]; then\n        sendmail_cf=\"/etc/sendmail.cf\"\n    fi\n\n    if [ -f \"$sendmail_cf\" ]; then\n        # 릴레이 관련 설정 확인\n        # R$* 릴레이 허용 설정 확인\n        if grep -E \"^R.*\\$\\*.*relay\" \"$sendmail_cf\" >/dev/null 2>&1; then\n            VULNERABLE=1\n            VULN_REASONS=\"${VULN_REASONS}- 무제한 릴레이 허용 설정 발견\\n\"\n        fi\n\n        # FEATURE(promiscuous_relay) 확인\n        if grep -i \"promiscuous_relay\" \"$sendmail_cf\" >/dev/null 2>&1; then\n            VULNERABLE=1\n            VULN_REASONS=\"${VULN_REASONS}- promiscuous_relay 기능 활성화됨\\n\"\n        fi\n    fi\n\n    # access 파일 확인\n    access_file=\"/etc/mail/access\"\n    if [ -f \"$access_file\" ]; then\n        # RELAY 허용 설정 확인\n        if grep -E \"^.*RELAY$\" \"$access_file\" >/dev/null 2>&1; then\n            relay_entries=$(grep -E \"^.*RELAY$\" \"$access_file\" | wc -l)\n            if [ \"$relay_entries\" -gt 5 ]; then\n                VULNERABLE=1\n                VULN_REASONS=\"${VULN_REASONS}- 과도한 릴레이 허용 설정 ($relay_entries 개)\\n\"\n            fi\n        fi\n    fi\n\n    # 최종 결과 출력\n    if [ $VULNERABLE -eq 1 ]; then\n        echo \"U-31 최종 결과: 취약\" >> $resultfile 2>&1\n        printf \"%b\" \"$VULN_REASONS\" >> $resultfile 2>&1\n    else\n        echo \"U-31 최종 결과: 양호\" >> $resultfile 2>&1\n    fi\n\n    return $VULNERABLE\n}"
      },
      {
        "id": "section_48",
        "name": "u_32",
        "description": "u_32 함수 실행",
        "content": "u_32() {\n    echo \"U-32: 일반 사용자 sendmail 실행 방지\" >> $resultfile 2>&1\n    VULNERABLE=0\n    VULN_REASONS=\"\"\n\n    # sendmail 실행 파일 경로 확인\n    sendmail_paths=(\"/usr/sbin/sendmail\" \"/usr/lib/sendmail\" \"/usr/bin/sendmail\")\n    \n    for sendmail_path in \"${sendmail_paths[@]}\"; do\n        if [ -f \"$sendmail_path\" ]; then\n            # 파일 권한 확인\n            perm=$(stat -c \"%a\" \"$sendmail_path\" 2>/dev/null)\n            owner=$(stat -c \"%U\" \"$sendmail_path\" 2>/dev/null)\n            \n            # setuid 비트 확인 (4755 등)\n            if [ \"${perm:0:1}\" = \"4\" ]; then\n                VULNERABLE=1\n                VULN_REASONS=\"${VULN_REASONS}- $sendmail_path setuid 권한 설정됨 ($perm)\\n\"\n            fi\n            \n            # 일반 사용자 실행 권한 확인 (others 실행 권한)\n            if [ \"${perm:2:1}\" -ge \"1\" ] && [ \"${perm:2:1}\" -le \"7\" ]; then\n                VULNERABLE=1\n                VULN_REASONS=\"${VULN_REASONS}- $sendmail_path 일반 사용자 실행 권한 있음 ($perm)\\n\"\n            fi\n            \n            # 소유자가 root가 아닌 경우\n            if [ \"$owner\" != \"root\" ]; then\n                VULNERABLE=1\n                VULN_REASONS=\"${VULN_REASONS}- $sendmail_path 소유자가 root가 아님 ($owner)\\n\"\n            fi\n        fi\n    done\n\n    # sendmail이 없는 경우\n    if [ ! -f \"/usr/sbin/sendmail\" ] && [ ! -f \"/usr/lib/sendmail\" ] && [ ! -f \"/usr/bin/sendmail\" ]; then\n        echo \"U-32 최종 결과: 양호\" >> $resultfile 2>&1\n        return 0\n    fi\n\n    # 최종 결과 출력\n    if [ $VULNERABLE -eq 1 ]; then\n        echo \"U-32 최종 결과: 취약\" >> $resultfile 2>&1\n        printf \"%b\" \"$VULN_REASONS\" >> $resultfile 2>&1\n    else\n        echo \"U-32 최종 결과: 양호\" >> $resultfile 2>&1\n    fi\n\n    return $VULNERABLE\n}"
      },
      {
        "id": "section_49",
        "name": "u_33",
        "description": "u_33 함수 실행",
        "content": "u_33() {\n    echo \"U-33: DNS 보안 버전 패치\" >> $resultfile 2>&1\n    VULNERABLE=0\n    VULN_REASONS=\"\"\n\n    # BIND(named) 설치 여부 확인\n    if ! command -v named >/dev/null 2>&1 && ! dpkg -l bind9 >/dev/null 2>&1; then\n        echo \"U-33 최종 결과: 양호\" >> $resultfile 2>&1\n        return 0\n    fi\n\n    # BIND 버전 확인\n    if command -v named >/dev/null 2>&1; then\n        bind_version=$(named -v 2>/dev/null | head -1)\n        if [ -n \"$bind_version\" ]; then\n            # 취약한 버전 패턴 확인 (BIND 9.11.0 미만은 취약)\n            version_num=$(echo \"$bind_version\" | grep -o \"9\\.[0-9]\\+\\.[0-9]\\+\" | head -1)\n            if [ -n \"$version_num\" ]; then\n                major=$(echo \"$version_num\" | cut -d. -f1)\n                minor=$(echo \"$version_num\" | cut -d. -f2)\n                patch=$(echo \"$version_num\" | cut -d. -f3)\n\n                if [ \"$major\" -lt 9 ] || ([ \"$major\" -eq 9 ] && [ \"$minor\" -lt 11 ]); then\n                    VULNERABLE=1\n                    VULN_REASONS=\"${VULN_REASONS}- BIND 취약한 버전 사용: $version_num\\n\"\n                fi\n            fi\n        fi\n    fi\n\n    # named.conf에서 버전 정보 노출 확인\n    named_conf=\"/etc/bind/named.conf\"\n    if [ ! -f \"$named_conf\" ]; then\n        named_conf=\"/etc/named.conf\"\n    fi\n\n    if [ -f \"$named_conf\" ]; then\n        # version 옵션 확인\n        if ! grep -i \"version.*\\\".*\\\"\" \"$named_conf\" >/dev/null 2>&1; then\n            VULNERABLE=1\n            VULN_REASONS=\"${VULN_REASONS}- BIND 버전 정보 숨김 설정 없음\\n\"\n        fi\n    fi\n\n    # 최종 결과 출력\n    if [ $VULNERABLE -eq 1 ]; then\n        echo \"U-33 최종 결과: 취약\" >> $resultfile 2>&1\n        printf \"%b\" \"$VULN_REASONS\" >> $resultfile 2>&1\n    else\n        echo \"U-33 최종 결과: 양호\" >> $resultfile 2>&1\n    fi\n\n    return $VULNERABLE\n}"
      },
      {
        "id": "section_50",
        "name": "u_34",
        "description": "u_34 함수 실행",
        "content": "u_34() {\n    echo \"U-34: DNS zone transfer 설정\" >> $resultfile 2>&1\n    VULNERABLE=0\n    VULN_REASONS=\"\"\n\n    # BIND(named) 설치 여부 확인\n    if ! command -v named >/dev/null 2>&1 && ! dpkg -l bind9 >/dev/null 2>&1; then\n        echo \"U-34 최종 결과: 양호\" >> $resultfile 2>&1\n        return 0\n    fi\n\n    # named.conf 파일 찾기\n    named_conf=\"/etc/bind/named.conf\"\n    if [ ! -f \"$named_conf\" ]; then\n        named_conf=\"/etc/named.conf\"\n    fi\n\n    if [ -f \"$named_conf\" ]; then\n        # allow-transfer 설정 확인\n        if grep -i \"allow-transfer\" \"$named_conf\" >/dev/null 2>&1; then\n            # any 또는 전체 허용 설정 확인\n            if grep -i \"allow-transfer.*any\" \"$named_conf\" >/dev/null 2>&1; then\n                VULNERABLE=1\n                VULN_REASONS=\"${VULN_REASONS}- zone transfer가 모든 호스트에 허용됨 (any)\\n\"\n            fi\n        else\n            # allow-transfer 설정이 없는 경우 (기본적으로 허용)\n            VULNERABLE=1\n            VULN_REASONS=\"${VULN_REASONS}- zone transfer 제한 설정이 없음\\n\"\n        fi\n\n        # 개별 zone 설정 확인\n        zone_files=$(grep -i \"zone.*{\" \"$named_conf\" | wc -l)\n        if [ \"$zone_files\" -gt 0 ]; then\n            # zone 블록에서 allow-transfer 확인\n            if ! grep -A 10 -i \"zone.*{\" \"$named_conf\" | grep -i \"allow-transfer\" >/dev/null 2>&1; then\n                VULNERABLE=1\n                VULN_REASONS=\"${VULN_REASONS}- zone별 transfer 제한 설정이 없음\\n\"\n            fi\n        fi\n    fi\n\n    # 최종 결과 출력\n    if [ $VULNERABLE -eq 1 ]; then\n        echo \"U-34 최종 결과: 취약\" >> $resultfile 2>&1\n        printf \"%b\" \"$VULN_REASONS\" >> $resultfile 2>&1\n    else\n        echo \"U-34 최종 결과: 양호\" >> $resultfile 2>&1\n    fi\n\n    return $VULNERABLE\n}"
      },
      {
        "id": "section_51",
        "name": "u_35",
        "description": "u_35 함수 실행",
        "content": "u_35() {\n    echo \"U-35: 웹 서비스 디렉토리 리스팅 제거\" >> $resultfile 2>&1\n    VULNERABLE=0\n    VULN_REASONS=\"\"\n\n    # Apache 설정 확인\n    apache_configs=(\"/etc/apache2/apache2.conf\" \"/etc/httpd/conf/httpd.conf\" \"/etc/apache2/sites-enabled/000-default.conf\")\n    apache_found=0\n\n    for apache_conf in \"${apache_configs[@]}\"; do\n        if [ -f \"$apache_conf\" ]; then\n            apache_found=1\n            # Indexes 옵션 확인\n            if grep -i \"Options.*Indexes\" \"$apache_conf\" >/dev/null 2>&1; then\n                VULNERABLE=1\n                VULN_REASONS=\"${VULN_REASONS}- Apache에서 디렉토리 리스팅 허용됨 ($apache_conf)\\n\"\n            fi\n        fi\n    done\n\n    # Apache sites-enabled 전체 확인\n    if [ -d \"/etc/apache2/sites-enabled\" ]; then\n        apache_found=1\n        if grep -r -i \"Options.*Indexes\" /etc/apache2/sites-enabled/ >/dev/null 2>&1; then\n            VULNERABLE=1\n            VULN_REASONS=\"${VULN_REASONS}- Apache sites-enabled에서 디렉토리 리스팅 허용됨\\n\"\n        fi\n    fi\n\n    # Nginx 설정 확인\n    nginx_configs=(\"/etc/nginx/nginx.conf\" \"/etc/nginx/sites-enabled/default\")\n    nginx_found=0\n\n    for nginx_conf in \"${nginx_configs[@]}\"; do\n        if [ -f \"$nginx_conf\" ]; then\n            nginx_found=1\n            # autoindex 옵션 확인\n            if grep -i \"autoindex.*on\" \"$nginx_conf\" >/dev/null 2>&1; then\n                VULNERABLE=1\n                VULN_REASONS=\"${VULN_REASONS}- Nginx에서 디렉토리 리스팅 허용됨 ($nginx_conf)\\n\"\n            fi\n        fi\n    done\n\n    # Nginx sites-enabled 전체 확인\n    if [ -d \"/etc/nginx/sites-enabled\" ]; then\n        nginx_found=1\n        if grep -r -i \"autoindex.*on\" /etc/nginx/sites-enabled/ >/dev/null 2>&1; then\n            VULNERABLE=1\n            VULN_REASONS=\"${VULN_REASONS}- Nginx sites-enabled에서 디렉토리 리스팅 허용됨\\n\"\n        fi\n    fi\n\n    # 웹 서버가 없는 경우\n    if [ $apache_found -eq 0 ] && [ $nginx_found -eq 0 ]; then\n        echo \"U-35 최종 결과: 양호\" >> $resultfile 2>&1\n        return 0\n    fi\n\n    # 최종 결과 출력\n    if [ $VULNERABLE -eq 1 ]; then\n        echo \"U-35 최종 결과: 취약\" >> $resultfile 2>&1\n        printf \"%b\" \"$VULN_REASONS\" >> $resultfile 2>&1\n    else\n        echo \"U-35 최종 결과: 양호\" >> $resultfile 2>&1\n    fi\n\n    return $VULNERABLE\n}"
      },
      {
        "id": "section_52",
        "name": "u_36",
        "description": "u_36 함수 실행",
        "content": "u_36() {\n    echo \"U-36: 웹서비스 웹 프로세스 권한 제한\" >> $resultfile 2>&1\n    VULNERABLE=0\n    VULN_REASONS=\"\"\n\n    # Apache 프로세스 확인\n    if ps aux | grep -E \"(apache2|httpd)\" | grep -v grep >/dev/null; then\n        # Apache 프로세스가 root로 실행되는지 확인\n        if ps aux | grep -E \"(apache2|httpd)\" | grep -v grep | grep \"^root\" >/dev/null; then\n            root_processes=$(ps aux | grep -E \"(apache2|httpd)\" | grep -v grep | grep \"^root\" | wc -l)\n            worker_processes=$(ps aux | grep -E \"(apache2|httpd)\" | grep -v grep | grep -v \"^root\" | wc -l)\n            \n            # 모든 프로세스가 root인 경우 취약\n            if [ \"$worker_processes\" -eq 0 ]; then\n                VULNERABLE=1\n                VULN_REASONS=\"${VULN_REASONS}- Apache 모든 프로세스가 root 권한으로 실행됨\\n\"\n            fi\n        fi\n    fi\n\n    # Nginx 프로세스 확인\n    if ps aux | grep nginx | grep -v grep >/dev/null; then\n        # Nginx worker 프로세스가 root로 실행되는지 확인\n        if ps aux | grep \"nginx: worker\" | grep -v grep | grep \"^root\" >/dev/null; then\n            VULNERABLE=1\n            VULN_REASONS=\"${VULN_REASONS}- Nginx worker 프로세스가 root 권한으로 실행됨\\n\"\n        fi\n    fi\n\n    # 웹 서버가 없는 경우\n    if ! ps aux | grep -E \"(apache2|httpd|nginx)\" | grep -v grep >/dev/null; then\n        echo \"U-36 최종 결과: 양호\" >> $resultfile 2>&1\n        return 0\n    fi\n\n    # 최종 결과 출력\n    if [ $VULNERABLE -eq 1 ]; then\n        echo \"U-36 최종 결과: 취약\" >> $resultfile 2>&1\n        printf \"%b\" \"$VULN_REASONS\" >> $resultfile 2>&1\n    else\n        echo \"U-36 최종 결과: 양호\" >> $resultfile 2>&1\n    fi\n\n    return $VULNERABLE\n}"
      },
      {
        "id": "section_53",
        "name": "u_37",
        "description": "u_37 함수 실행",
        "content": "u_37() {\n    echo \"U-37: 웹서비스 상위 디렉토리 접근 금지\" >> $resultfile 2>&1\n    VULNERABLE=0\n    VULN_REASONS=\"\"\n\n    # Apache 설정 확인\n    apache_configs=(\"/etc/apache2/apache2.conf\" \"/etc/httpd/conf/httpd.conf\")\n    apache_found=0\n    \n    for apache_conf in \"${apache_configs[@]}\"; do\n        if [ -f \"$apache_conf\" ]; then\n            apache_found=1\n            # AllowOverride 설정 확인\n            if grep -i \"AllowOverride.*All\" \"$apache_conf\" >/dev/null 2>&1; then\n                VULNERABLE=1\n                VULN_REASONS=\"${VULN_REASONS}- Apache AllowOverride All 설정으로 상위 디렉토리 접근 가능\\n\"\n            fi\n            \n            # FollowSymLinks 설정 확인\n            if grep -i \"Options.*FollowSymLinks\" \"$apache_conf\" >/dev/null 2>&1; then\n                VULNERABLE=1\n                VULN_REASONS=\"${VULN_REASONS}- Apache FollowSymLinks 허용으로 심볼릭 링크 접근 가능\\n\"\n            fi\n            \n            # DocumentRoot 외부 Directory 접근 설정 확인\n            if grep -E \"<Directory.*\\/>\" \"$apache_conf\" >/dev/null 2>&1; then\n                VULNERABLE=1\n                VULN_REASONS=\"${VULN_REASONS}- Apache 루트 디렉토리 접근 허용 설정 발견\\n\"\n            fi\n        fi\n    done\n\n    # Apache sites-enabled 설정 확인\n    if [ -d \"/etc/apache2/sites-enabled\" ]; then\n        apache_found=1\n        if grep -r -i \"AllowOverride.*All\" /etc/apache2/sites-enabled/ >/dev/null 2>&1; then\n            VULNERABLE=1\n            VULN_REASONS=\"${VULN_REASONS}- Apache sites에서 AllowOverride All 설정 발견\\n\"\n        fi\n    fi\n\n    # Nginx 설정 확인\n    nginx_configs=(\"/etc/nginx/nginx.conf\")\n    nginx_found=0\n    \n    for nginx_conf in \"${nginx_configs[@]}\"; do\n        if [ -f \"$nginx_conf\" ]; then\n            nginx_found=1\n            # alias 설정에서 상위 디렉토리 참조 확인\n            if grep -i \"alias.*\\.\\.\" \"$nginx_conf\" >/dev/null 2>&1; then\n                VULNERABLE=1\n                VULN_REASONS=\"${VULN_REASONS}- Nginx alias에서 상위 디렉토리 참조 발견\\n\"\n            fi\n        fi\n    done\n\n    # Nginx sites-enabled 확인\n    if [ -d \"/etc/nginx/sites-enabled\" ]; then\n        nginx_found=1\n        if grep -r -i \"alias.*\\.\\.\" /etc/nginx/sites-enabled/ >/dev/null 2>&1; then\n            VULNERABLE=1\n            VULN_REASONS=\"${VULN_REASONS}- Nginx sites에서 상위 디렉토리 alias 설정 발견\\n\"\n        fi\n    fi\n\n    # 웹 서버 설정이 없는 경우\n    if [ $apache_found -eq 0 ] && [ $nginx_found -eq 0 ]; then\n        echo \"U-37 최종 결과: 양호\" >> $resultfile 2>&1\n        return 0\n    fi\n\n    # 최종 결과 출력\n    if [ $VULNERABLE -eq 1 ]; then\n        echo \"U-37 최종 결과: 취약\" >> $resultfile 2>&1\n        printf \"%b\" \"$VULN_REASONS\" >> $resultfile 2>&1\n    else\n        echo \"U-37 최종 결과: 양호\" >> $resultfile 2>&1\n    fi\n\n    return $VULNERABLE\n}"
      },
      {
        "id": "section_54",
        "name": "u_38",
        "description": "u_38 함수 실행",
        "content": "u_38() {\n    echo \"U-38: 웹서비스 불필요한 파일 제거\" >> $resultfile 2>&1\n    VULNERABLE=0\n    VULN_REASONS=\"\"\n\n    # Apache2 설치 여부 확인\n    if [ ! -d \"/etc/apache2\" ]; then\n        echo \"U-38 최종 결과: 양호\" >> $resultfile 2>&1\n        return 0\n    fi\n\n    # Apache2 기본 생성 불필요 파일/디렉토리 확인\n    echo \"Apache2 설정 디렉토리 내용:\" >> $resultfile 2>&1\n    ls -al /etc/apache2/* >> $resultfile 2>&1\n\n    # 기본 사이트 설정 파일 (샘플/데모 파일들)\n    if [ -f \"/etc/apache2/sites-available/000-default.conf\" ]; then\n        # 기본 설정이 수정되지 않았는지 확인\n        if grep -i \"It works!\" /var/www/html/index.html >/dev/null 2>&1; then\n            VULNERABLE=1\n            VULN_REASONS=\"${VULN_REASONS}- Apache2 기본 index.html 파일이 존재함\\n\"\n        fi\n    fi\n\n    # 불필요한 모듈 설정 파일들 확인\n    unnecessary_mods=(\"autoindex\" \"userdir\" \"status\" \"info\")\n    for mod in \"${unnecessary_mods[@]}\"; do\n        if [ -f \"/etc/apache2/mods-enabled/${mod}.conf\" ] || [ -f \"/etc/apache2/mods-enabled/${mod}.load\" ]; then\n            VULNERABLE=1\n            VULN_REASONS=\"${VULN_REASONS}- 불필요한 Apache2 모듈 활성화됨: ${mod}\\n\"\n        fi\n    done\n\n    # 기본 웹 루트의 불필요한 파일들 확인\n    if [ -d \"/var/www/html\" ]; then\n        # 기본 Apache2 인덱스 파일\n        if [ -f \"/var/www/html/index.html\" ]; then\n            if grep -i \"Apache2 Default Page\" \"/var/www/html/index.html\" >/dev/null 2>&1; then\n                VULNERABLE=1\n                VULN_REASONS=\"${VULN_REASONS}- Apache2 기본 페이지가 존재함\\n\"\n            fi\n        fi\n\n        # README, 매뉴얼 등 불필요한 파일들\n        unnecessary_files=$(find /var/www/html -type f \\( -name \"README*\" -o -name \"INSTALL*\" -o -name \"CHANGELOG*\" -o -name \"COPYING*\" \\) 2>/dev/null | wc -l)\n        if [ \"$unnecessary_files\" -gt 0 ]; then\n            VULNERABLE=1\n            VULN_REASONS=\"${VULN_REASONS}- 웹 루트에 설치 관련 문서 파일 존재 (${unnecessary_files}개)\\n\"\n        fi\n\n        # 테스트/샘플 디렉토리들\n        test_dirs=$(find /var/www/html -type d \\( -name \"manual\" -o -name \"doc\" -o -name \"test\" -o -name \"sample\" -o -name \"example\" \\) 2>/dev/null | wc -l)\n        if [ \"$test_dirs\" -gt 0 ]; then\n            VULNERABLE=1\n            VULN_REASONS=\"${VULN_REASONS}- 웹 루트에 테스트/샘플 디렉토리 존재 (${test_dirs}개)\\n\"\n        fi\n    fi\n\n    # Apache2 conf-enabled에서 불필요한 설정들\n    if [ -d \"/etc/apache2/conf-enabled\" ]; then\n        # 서버 정보 노출 관련 설정들\n        if [ -f \"/etc/apache2/conf-enabled/security.conf\" ]; then\n            if ! grep -E \"^ServerTokens.*Prod\" /etc/apache2/conf-enabled/security.conf >/dev/null 2>&1; then\n                VULNERABLE=1\n                VULN_REASONS=\"${VULN_REASONS}- Apache2 서버 정보 노출 설정이 안전하지 않음\\n\"\n            fi\n        fi\n    fi\n\n    # 최종 결과 출력\n    if [ $VULNERABLE -eq 1 ]; then\n        echo \"U-38 최종 결과: 취약\" >> $resultfile 2>&1\n        printf \"%b\" \"$VULN_REASONS\" >> $resultfile 2>&1\n    else\n        echo \"U-38 최종 결과: 양호\" >> $resultfile 2>&1\n    fi\n\n    return $VULNERABLE\n}"
      },
      {
        "id": "section_55",
        "name": "u_39",
        "description": "u_39 함수 실행",
        "content": "u_39() {\n    echo \"U-39: 웹서비스 링크 사용 금지\" >> $resultfile 2>&1\n    VULNERABLE=0\n    VULN_REASONS=\"\"\n\n    # Apache 설정에서 FollowSymLinks 확인\n    apache_configs=(\"/etc/apache2/apache2.conf\" \"/etc/httpd/conf/httpd.conf\")\n    apache_found=0\n    \n    for apache_conf in \"${apache_configs[@]}\"; do\n        if [ -f \"$apache_conf\" ]; then\n            apache_found=1\n            # FollowSymLinks 옵션 확인\n            if grep -i \"Options.*FollowSymLinks\" \"$apache_conf\" >/dev/null 2>&1; then\n                # SymLinksIfOwnerMatch가 함께 있지 않은 경우만 취약\n                if ! grep -i \"Options.*SymLinksIfOwnerMatch\" \"$apache_conf\" >/dev/null 2>&1; then\n                    VULNERABLE=1\n                    VULN_REASONS=\"${VULN_REASONS}- Apache에서 FollowSymLinks 허용됨\\n\"\n                fi\n            fi\n        fi\n    done\n\n    # Apache sites-enabled 설정 확인\n    if [ -d \"/etc/apache2/sites-enabled\" ]; then\n        apache_found=1\n        if grep -r -i \"Options.*FollowSymLinks\" /etc/apache2/sites-enabled/ >/dev/null 2>&1; then\n            if ! grep -r -i \"Options.*SymLinksIfOwnerMatch\" /etc/apache2/sites-enabled/ >/dev/null 2>&1; then\n                VULNERABLE=1\n                VULN_REASONS=\"${VULN_REASONS}- Apache sites에서 FollowSymLinks 허용됨\\n\"\n            fi\n        fi\n    fi\n\n    # 웹 루트에서 실제 심볼릭 링크 확인\n    web_roots=(\"/var/www/html\" \"/var/www\" \"/usr/share/nginx/html\" \"/srv/www\")\n    web_found=0\n\n    for web_root in \"${web_roots[@]}\"; do\n        if [ -d \"$web_root\" ]; then\n            web_found=1\n            \n            # 심볼릭 링크 파일 확인\n            symlink_count=$(find \"$web_root\" -type l 2>/dev/null | wc -l)\n            if [ \"$symlink_count\" -gt 0 ]; then\n                # 위험한 심볼릭 링크 확인 (상위 디렉토리 참조)\n                dangerous_symlinks=$(find \"$web_root\" -type l -exec readlink {} \\; 2>/dev/null | grep -E \"\\.\\./|^/\" | wc -l)\n                if [ \"$dangerous_symlinks\" -gt 0 ]; then\n                    VULNERABLE=1\n                    VULN_REASONS=\"${VULN_REASONS}- 웹 루트에 위험한 심볼릭 링크 존재 (${dangerous_symlinks}개)\\n\"\n                fi\n            fi\n        fi\n    done\n\n    # 웹 서버 설정이 없는 경우\n    if [ $apache_found -eq 0 ] && [ $web_found -eq 0 ]; then\n        echo \"U-39 최종 결과: 양호\" >> $resultfile 2>&1\n        return 0\n    fi\n\n    # 최종 결과 출력\n    if [ $VULNERABLE -eq 1 ]; then\n        echo \"U-39 최종 결과: 취약\" >> $resultfile 2>&1\n        printf \"%b\" \"$VULN_REASONS\" >> $resultfile 2>&1\n    else\n        echo \"U-39 최종 결과: 양호\" >> $resultfile 2>&1\n    fi\n\n    return $VULNERABLE\n}"
      },
      {
        "id": "section_56",
        "name": "u_40",
        "description": "u_40 함수 실행",
        "content": "u_40() {\n    echo \"U-40: 웹서비스 파일 업로드 및 다운로드 제한\" >> $resultfile 2>&1\n    VULNERABLE=0\n    VULN_REASONS=\"\"\n\n    # Apache 설치 여부 확인\n    if [ ! -d \"/etc/apache2\" ]; then\n        echo \"U-40 최종 결과: 양호\" >> $resultfile 2>&1\n        return 0\n    fi\n\n    # Apache 메인 설정 파일에서 LimitRequestBody 확인\n    echo \"Apache 메인 설정 파일 점검:\" >> $resultfile 2>&1\n    if [ -f \"/etc/apache2/apache2.conf\" ]; then\n        limit_result=$(cat /etc/apache2/apache2.conf | grep \"LimitRequestBody\")\n        if [ -n \"$limit_result\" ]; then\n            echo \"LimitRequestBody 설정 발견: $limit_result\" >> $resultfile 2>&1\n        else\n            echo \"LimitRequestBody 설정 없음\" >> $resultfile 2>&1\n            VULNERABLE=1\n            VULN_REASONS=\"${VULN_REASONS}- apache2.conf에 LimitRequestBody 설정 없음\\n\"\n        fi\n    fi\n\n    # sites-available 설정 파일들 확인\n    echo \"\" >> $resultfile 2>&1\n    echo \"Sites-available 설정 파일 점검:\" >> $resultfile 2>&1\n    \n    if [ -d \"/etc/apache2/sites-available\" ]; then\n        sites_with_limit=0\n        total_sites=0\n        \n        for site_file in /etc/apache2/sites-available/*.conf; do\n            if [ -f \"$site_file\" ]; then\n                total_sites=$((total_sites + 1))\n                site_name=$(basename \"$site_file\")\n                echo \"점검 파일: $site_name\" >> $resultfile 2>&1\n                \n                limit_result=$(cat \"$site_file\" | grep \"LimitRequestBody\")\n                if [ -n \"$limit_result\" ]; then\n                    echo \"  LimitRequestBody 설정: $limit_result\" >> $resultfile 2>&1\n                    sites_with_limit=$((sites_with_limit + 1))\n                else\n                    echo \"  LimitRequestBody 설정 없음\" >> $resultfile 2>&1\n                fi\n            fi\n        done\n        \n        # 모든 사이트에 LimitRequestBody 설정이 없는 경우\n        if [ $sites_with_limit -eq 0 ] && [ $total_sites -gt 0 ]; then\n            VULNERABLE=1\n            VULN_REASONS=\"${VULN_REASONS}- sites-available의 모든 설정 파일에 LimitRequestBody 설정 없음\\n\"\n        fi\n    fi\n\n    # sites-enabled 설정 파일들도 확인\n    echo \"\" >> $resultfile 2>&1\n    echo \"Sites-enabled 설정 파일 점검:\" >> $resultfile 2>&1\n    \n    if [ -d \"/etc/apache2/sites-enabled\" ]; then\n        enabled_sites_with_limit=0\n        total_enabled_sites=0\n        \n        for site_file in /etc/apache2/sites-enabled/*.conf; do\n            if [ -f \"$site_file\" ]; then\n                total_enabled_sites=$((total_enabled_sites + 1))\n                site_name=$(basename \"$site_file\")\n                echo \"활성화된 파일: $site_name\" >> $resultfile 2>&1\n                \n                limit_result=$(cat \"$site_file\" | grep \"LimitRequestBody\")\n                if [ -n \"$limit_result\" ]; then\n                    echo \"  LimitRequestBody 설정: $limit_result\" >> $resultfile 2>&1\n                    enabled_sites_with_limit=$((enabled_sites_with_limit + 1))\n                else\n                    echo \"  LimitRequestBody 설정 없음\" >> $resultfile 2>&1\n                fi\n            fi\n        done\n        \n        # 활성화된 사이트에 LimitRequestBody 설정이 없는 경우\n        if [ $enabled_sites_with_limit -eq 0 ] && [ $total_enabled_sites -gt 0 ]; then\n            VULNERABLE=1\n            VULN_REASONS=\"${VULN_REASONS}- 활성화된 사이트에 LimitRequestBody 설정 없음\\n\"\n        fi\n    fi\n\n    # 최종 결과 출력\n    if [ $VULNERABLE -eq 1 ]; then\n        echo \"U-40 최종 결과: 취약\" >> $resultfile 2>&1\n        printf \"%b\" \"$VULN_REASONS\" >> $resultfile 2>&1\n    else\n        echo \"U-40 최종 결과: 양호\" >> $resultfile 2>&1\n    fi\n\n    return $VULNERABLE\n}"
      },
      {
        "id": "section_57",
        "name": "u_41",
        "description": "u_41 함수 실행",
        "content": "u_41() {\n    echo \"U-41: 웹서비스 영역의 분리\" >> $resultfile 2>&1\n    VULNERABLE=0\n    VULN_REASONS=\"\"\n\n    # 웹 서버 프로세스 사용자 확인\n    web_processes=$(ps aux | grep -E \"(apache2|httpd|nginx)\" | grep -v grep | grep -v \"^root\")\n    \n    if [ -n \"$web_processes\" ]; then\n        # 웹 서버 전용 사용자 확인\n        web_users=$(echo \"$web_processes\" | awk '{print $1}' | sort -u)\n        \n        for web_user in $web_users; do\n            # 시스템 사용자인지 확인 (UID < 1000)\n            user_uid=$(id -u \"$web_user\" 2>/dev/null)\n            if [ -n \"$user_uid\" ] && [ \"$user_uid\" -lt 1000 ]; then\n                # 홈 디렉토리 확인\n                user_home=$(eval echo \"~$web_user\" 2>/dev/null)\n                if [ \"$user_home\" = \"/\" ] || [ \"$user_home\" = \"/root\" ]; then\n                    VULNERABLE=1\n                    VULN_REASONS=\"${VULN_REASONS}- 웹 서버 사용자($web_user)가 시스템 루트 홈 디렉토리 사용\\n\"\n                fi\n                \n                # 쉘 확인\n                user_shell=$(getent passwd \"$web_user\" | cut -d: -f7)\n                if [ \"$user_shell\" != \"/usr/sbin/nologin\" ] && [ \"$user_shell\" != \"/bin/false\" ] && [ \"$user_shell\" != \"/sbin/nologin\" ]; then\n                    VULNERABLE=1\n                    VULN_REASONS=\"${VULN_REASONS}- 웹 서버 사용자($web_user)에 로그인 쉘 허용: $user_shell\\n\"\n                fi\n            fi\n        done\n    fi\n\n    # 웹 루트 디렉토리 권한 확인\n    web_roots=(\"/var/www/html\" \"/var/www\" \"/usr/share/nginx/html\" \"/srv/www\")\n    \n    for web_root in \"${web_roots[@]}\"; do\n        if [ -d \"$web_root\" ]; then\n            # 웹 루트 소유자 확인\n            root_owner=$(stat -c \"%U\" \"$web_root\" 2>/dev/null)\n            if [ \"$root_owner\" = \"root\" ]; then\n                # 웹 서버 프로세스 사용자와 다른 경우 확인\n                web_user=$(echo \"$web_processes\" | head -1 | awk '{print $1}')\n                if [ -n \"$web_user\" ] && [ \"$web_user\" != \"$root_owner\" ]; then\n                    # 그룹 권한 확인\n                    root_perm=$(stat -c \"%a\" \"$web_root\" 2>/dev/null)\n                    if [ \"${root_perm:1:1}\" -ge \"7\" ]; then\n                        VULNERABLE=1\n                        VULN_REASONS=\"${VULN_REASONS}- 웹 루트 디렉토리에 과도한 그룹 권한: $root_perm\\n\"\n                    fi\n                fi\n            fi\n        fi\n    done\n\n    # chroot 환경 확인\n    apache_configs=(\"/etc/apache2/apache2.conf\" \"/etc/httpd/conf/httpd.conf\")\n    \n    for apache_conf in \"${apache_configs[@]}\"; do\n        if [ -f \"$apache_conf\" ]; then\n            # ChrootDir 설정 확인\n            if ! grep -i \"ChrootDir\" \"$apache_conf\" >/dev/null 2>&1; then\n                VULNERABLE=1\n                VULN_REASONS=\"${VULN_REASONS}- Apache chroot 환경 설정 없음\\n\"\n            fi\n        fi\n    done\n\n    # 웹 서버가 없는 경우\n    if [ -z \"$web_processes\" ]; then\n        echo \"U-41 최종 결과: 양호\" >> $resultfile 2>&1\n        return 0\n    fi\n\n    # 최종 결과 출력\n    if [ $VULNERABLE -eq 1 ]; then\n        echo \"U-41 최종 결과: 취약\" >> $resultfile 2>&1\n        printf \"%b\" \"$VULN_REASONS\" >> $resultfile 2>&1\n    else\n        echo \"U-41 최종 결과: 양호\" >> $resultfile 2>&1\n    fi\n\n    return $VULNERABLE\n}"
      },
      {
        "id": "section_58",
        "name": "u_60",
        "description": "u_60 함수 실행",
        "content": "u_60() {\n    echo \"U-60: SSH 원격접속 허용\" >> $resultfile 2>&1\n    VULNERABLE=0\n    VULN_REASONS=\"\"\n\n    # SSH 서비스 활성화 확인\n    if ! systemctl is-active ssh >/dev/null 2>&1 && ! systemctl is-active sshd >/dev/null 2>&1; then\n        VULNERABLE=1\n        VULN_REASONS=\"${VULN_REASONS}- SSH 서비스가 비활성화됨\\n\"\n    fi\n\n    # SSH 설정 파일 확인\n    sshd_config=\"/etc/ssh/sshd_config\"\n    if [ -f \"$sshd_config\" ]; then\n        # PermitRootLogin 확인\n        if grep -E \"^PermitRootLogin.*yes\" \"$sshd_config\" >/dev/null 2>&1; then\n            VULNERABLE=1\n            VULN_REASONS=\"${VULN_REASONS}- SSH root 로그인이 허용됨\\n\"\n        fi\n\n        # PasswordAuthentication 확인\n        if grep -E \"^PasswordAuthentication.*no\" \"$sshd_config\" >/dev/null 2>&1; then\n            VULNERABLE=1\n            VULN_REASONS=\"${VULN_REASONS}- SSH 패스워드 인증이 비활성화됨\\n\"\n        fi\n\n        # Port 확인 (기본 포트 22 사용시 취약)\n        if ! grep -E \"^Port\" \"$sshd_config\" >/dev/null 2>&1; then\n            VULNERABLE=1\n            VULN_REASONS=\"${VULN_REASONS}- SSH 기본 포트(22) 사용 중\\n\"\n        fi\n\n        # Protocol 확인\n        if grep -E \"^Protocol.*1\" \"$sshd_config\" >/dev/null 2>&1; then\n            VULNERABLE=1\n            VULN_REASONS=\"${VULN_REASONS}- SSH Protocol 1 사용 (취약)\\n\"\n        fi\n    fi\n\n    # telnet 설치 여부 확인 (SSH와 동시 설치시 취약)\n    if command -v telnet >/dev/null 2>&1 || dpkg -l telnet >/dev/null 2>&1 || rpm -q telnet >/dev/null 2>&1; then\n        VULNERABLE=1\n        VULN_REASONS=\"${VULN_REASONS}- telnet이 설치되어 있음 (암호화되지 않은 프로토콜)\\n\"\n    fi\n\n    # telnet 서비스 활성화 확인\n    if systemctl is-active telnet >/dev/null 2>&1 || systemctl is-active telnet.socket >/dev/null 2>&1; then\n        VULNERABLE=1\n        VULN_REASONS=\"${VULN_REASONS}- telnet 서비스가 활성화됨\\n\"\n    fi\n\n    # 최종 결과 출력\n    if [ $VULNERABLE -eq 1 ]; then\n        echo \"U-60 최종 결과: 취약\" >> $resultfile 2>&1\n        printf \"%b\" \"$VULN_REASONS\" >> $resultfile 2>&1\n    else\n        echo \"U-60 최종 결과: 양호\" >> $resultfile 2>&1\n    fi\n\n    return $VULNERABLE\n}"
      },
      {
        "id": "section_59",
        "name": "u_61",
        "description": "u_61 함수 실행",
        "content": "u_61() {\n    echo \"U-61: FTP 서비스 확인\" >> $resultfile 2>&1\n    VULNERABLE=0\n    VULN_REASONS=\"\"\n\n    # FTP 서비스 활성화 확인\n    ftp_services=(\"vsftpd\" \"proftpd\" \"pure-ftpd\" \"wu-ftpd\")\n\n    for service in \"${ftp_services[@]}\"; do\n        if systemctl is-active \"$service\" >/dev/null 2>&1; then\n            VULNERABLE=1\n            VULN_REASONS=\"${VULN_REASONS}- ${service} 서비스가 활성화됨\\n\"\n        fi\n    done\n\n    # FTP 포트 리스닝 확인\n    if netstat -tlnp 2>/dev/null | grep \":21 \" >/dev/null; then\n        VULNERABLE=1\n        VULN_REASONS=\"${VULN_REASONS}- FTP 포트(21)가 리스닝 상태임\\n\"\n    fi\n\n    # FTP 프로세스 확인\n    if ps aux | grep -E \"(vsftpd|proftpd|pure-ftpd|wu-ftpd)\" | grep -v grep >/dev/null; then\n        VULNERABLE=1\n        VULN_REASONS=\"${VULN_REASONS}- FTP 데몬 프로세스가 실행 중\\n\"\n    fi\n\n    # 최종 결과 출력\n    if [ $VULNERABLE -eq 1 ]; then\n        echo \"U-61 최종 결과: 취약\" >> $resultfile 2>&1\n        printf \"%b\" \"$VULN_REASONS\" >> $resultfile 2>&1\n    else\n        echo \"U-61 최종 결과: 양호\" >> $resultfile 2>&1\n    fi\n\n    return $VULNERABLE\n}"
      },
      {
        "id": "section_60",
        "name": "u_62",
        "description": "u_62 함수 실행",
        "content": "u_62() {\n    echo \"U-62: FTP 계정 shell 제한\" >> $resultfile 2>&1\n    VULNERABLE=0\n    VULN_REASONS=\"\"\n\n    # FTP 서비스가 실행 중인지 확인\n    ftp_running=0\n    ftp_services=(\"vsftpd\" \"proftpd\" \"pure-ftpd\" \"wu-ftpd\")\n    \n    for service in \"${ftp_services[@]}\"; do\n        if systemctl is-active \"$service\" >/dev/null 2>&1; then\n            ftp_running=1\n            break\n        fi\n    done\n\n    # FTP 서비스가 없으면 양호\n    if [ $ftp_running -eq 0 ]; then\n        echo \"U-62 최종 결과: 양호\" >> $resultfile 2>&1\n        return 0\n    fi\n\n    # FTP 전용 사용자 확인\n    # /etc/passwd에서 FTP 관련 사용자 찾기\n    ftp_users=$(grep -E \"ftp|ftpuser\" /etc/passwd | cut -d: -f1)\n    \n    for ftp_user in $ftp_users; do\n        user_shell=$(getent passwd \"$ftp_user\" | cut -d: -f7)\n        \n        # 유효한 쉘이 할당된 경우 취약\n        if [ \"$user_shell\" != \"/usr/sbin/nologin\" ] && [ \"$user_shell\" != \"/bin/false\" ] && [ \"$user_shell\" != \"/sbin/nologin\" ]; then\n            VULNERABLE=1\n            VULN_REASONS=\"${VULN_REASONS}- FTP 사용자($ftp_user)에 쉘 접근 허용: $user_shell\\n\"\n        fi\n    done\n\n    # vsftpd 설정 확인\n    if [ -f \"/etc/vsftpd.conf\" ]; then\n        # chroot 설정 확인\n        if ! grep -E \"^chroot_local_user=YES\" /etc/vsftpd.conf >/dev/null 2>&1; then\n            VULNERABLE=1\n            VULN_REASONS=\"${VULN_REASONS}- vsftpd에서 chroot 설정이 활성화되지 않음\\n\"\n        fi\n        \n        # 로컬 사용자 로그인 확인\n        if grep -E \"^local_enable=YES\" /etc/vsftpd.conf >/dev/null 2>&1; then\n            # 쉘 사용자 리스트 확인\n            if [ -f \"/etc/ftpusers\" ]; then\n                shell_users=$(grep -E \"(bash|sh|zsh|csh)\" /etc/passwd | cut -d: -f1)\n                for shell_user in $shell_users; do\n                    if ! grep \"^$shell_user$\" /etc/ftpusers >/dev/null 2>&1; then\n                        VULNERABLE=1\n                        VULN_REASONS=\"${VULN_REASONS}- 쉘 사용자($shell_user)가 FTP 접근 차단 목록에 없음\\n\"\n                        break\n                    fi\n                done\n            fi\n        fi\n    fi\n\n    # proftpd 설정 확인\n    if [ -f \"/etc/proftpd/proftpd.conf\" ]; then\n        if ! grep -i \"RequireValidShell.*off\" /etc/proftpd/proftpd.conf >/dev/null 2>&1; then\n            VULNERABLE=1\n            VULN_REASONS=\"${VULN_REASONS}- proftpd에서 유효한 쉘 요구사항이 비활성화되지 않음\\n\"\n        fi\n    fi\n\n    # 최종 결과 출력\n    if [ $VULNERABLE -eq 1 ]; then\n        echo \"U-62 최종 결과: 취약\" >> $resultfile 2>&1\n        printf \"%b\" \"$VULN_REASONS\" >> $resultfile 2>&1\n    else\n        echo \"U-62 최종 결과: 양호\" >> $resultfile 2>&1\n    fi\n\n    return $VULNERABLE\n}"
      },
      {
        "id": "section_61",
        "name": "u_63",
        "description": "u_63 함수 실행",
        "content": "u_63() {\n    echo \"U-63: Ftpusers 파일 소유자 및 권한 설정\" >> $resultfile 2>&1\n    VULNERABLE=0\n    VULN_REASONS=\"\"\n\n    # ftpusers 파일 경로들\n    ftpusers_files=(\"/etc/ftpusers\" \"/etc/vsftpd/ftpusers\" \"/etc/vsftpd.ftpusers\")\n    ftpusers_found=0\n\n    for ftpusers_file in \"${ftpusers_files[@]}\"; do\n        if [ -f \"$ftpusers_file\" ]; then\n            ftpusers_found=1\n            echo \"점검 대상: $ftpusers_file\" >> $resultfile 2>&1\n            \n            # 파일 소유자 확인\n            owner=$(stat -c \"%U\" \"$ftpusers_file\" 2>/dev/null)\n            if [ \"$owner\" != \"root\" ]; then\n                VULNERABLE=1\n                VULN_REASONS=\"${VULN_REASONS}- $ftpusers_file 소유자가 root가 아님: $owner\\n\"\n            else\n                echo \"  소유자: $owner (양호)\" >> $resultfile 2>&1\n            fi\n            \n            # 파일 권한 확인 (640 이하)\n            permission=$(stat -c \"%a\" \"$ftpusers_file\" 2>/dev/null)\n            echo \"  권한: $permission\" >> $resultfile 2>&1\n            \n            if [ \"$permission\" -gt 640 ]; then\n                VULNERABLE=1\n                VULN_REASONS=\"${VULN_REASONS}- $ftpusers_file 권한이 과도함: $permission (640 이하 권장)\\n\"\n            fi\n            \n            # 다른 사용자 쓰기 권한 확인\n            other_write=${permission:2:1}\n            if [ \"$other_write\" -ge 2 ]; then\n                VULNERABLE=1\n                VULN_REASONS=\"${VULN_REASONS}- $ftpusers_file에 다른 사용자 쓰기 권한 있음\\n\"\n            fi\n        fi\n    done\n\n    # ftpusers 파일이 없는 경우\n    if [ $ftpusers_found -eq 0 ]; then\n        echo \"ftpusers 파일을 찾을 수 없음\" >> $resultfile 2>&1\n        echo \"U-63 최종 결과: 양호\" >> $resultfile 2>&1\n        return 0\n    fi\n\n    # 최종 결과 출력\n    if [ $VULNERABLE -eq 1 ]; then\n        echo \"U-63 최종 결과: 취약\" >> $resultfile 2>&1\n        printf \"%b\" \"$VULN_REASONS\" >> $resultfile 2>&1\n    else\n        echo \"U-63 최종 결과: 양호\" >> $resultfile 2>&1\n    fi\n\n    return $VULNERABLE\n}\n# Ubuntu 보안 점검 스크립트 - 서비스 관리, 패치 관리, 로그 관리"
      },
      {
        "id": "section_62",
        "name": "u_63",
        "description": "u_63 함수 실행",
        "content": "u_63() {\n    echo \"U-63: Ftpusers 파일 소유자 및 권한 설정\" >> $resultfile 2>&1\n    VULNERABLE=0\n    VULN_REASONS=\"\"\n    \n    # ftpusers 파일 경로들\n    ftpusers_files=(\"/etc/ftpusers\" \"/etc/vsftpd/ftpusers\" \"/etc/vsftpd.ftpusers\")\n    \n    for ftpusers_file in \"${ftpusers_files[@]}\"; do\n        if [ -f \"$ftpusers_file\" ]; then\n            # 소유자 확인 (root여야 함)\n            owner=$(stat -c \"%U\" \"$ftpusers_file\" 2>/dev/null)\n            if [ \"$owner\" != \"root\" ]; then\n                VULNERABLE=1\n                VULN_REASONS=\"$VULN_REASONS- $ftpusers_file 소유자가 root가 아님 (현재: $owner)\\n\"\n            fi\n            \n            # 권한 확인 (600, 640, 644 권장)\n            perms=$(stat -c \"%a\" \"$ftpusers_file\" 2>/dev/null)\n            if [ \"$perms\" != \"600\" ] && [ \"$perms\" != \"640\" ] && [ \"$perms\" != \"644\" ]; then\n                VULNERABLE=1\n                VULN_REASONS=\"$VULN_REASONS- $ftpusers_file 권한이 부적절함 (현재: $perms, 권장: 600, 640, 644)\\n\"\n            fi\n        fi\n    done\n    \n    if [ $VULNERABLE -eq 1 ]; then\n        echo \"U-63 최종 결과: 취약\" >> $resultfile 2>&1\n        echo \"취약 이유:\" >> $resultfile 2>&1\n        echo -e \"$VULN_REASONS\" >> $resultfile 2>&1\n    else\n        echo \"U-63 최종 결과: 양호\" >> $resultfile 2>&1\n    fi\n    \n    return $VULNERABLE\n}"
      },
      {
        "id": "section_63",
        "name": "u_64",
        "description": "u_64 함수 실행",
        "content": "u_64() {\n    echo \"U-64: Ftpusers 파일 설정\" >> $resultfile 2>&1\n    VULNERABLE=0\n    VULN_REASONS=\"\"\n    \n    # ftpusers 파일 경로들\n    ftpusers_files=(\"/etc/ftpusers\" \"/etc/vsftpd/ftpusers\" \"/etc/vsftpd.ftpusers\")\n    \n    for ftpusers_file in \"${ftpusers_files[@]}\"; do\n        if [ -f \"$ftpusers_file\" ]; then\n            # root 계정이 차단되어 있는지 확인\n            if ! grep -q \"^root$\" \"$ftpusers_file\"; then\n                VULNERABLE=1\n                VULN_REASONS=\"$VULN_REASONS- $ftpusers_file에 root 계정이 차단되지 않음\\n\"\n            fi\n            \n            # 파일이 비어있는지 확인\n            if [ ! -s \"$ftpusers_file\" ]; then\n                VULNERABLE=1\n                VULN_REASONS=\"$VULN_REASONS- $ftpusers_file 파일이 비어있음\\n\"\n            fi\n        fi\n    done\n    \n    if [ $VULNERABLE -eq 1 ]; then\n        echo \"U-64 최종 결과: 취약\" >> $resultfile 2>&1\n        echo \"취약 이유:\" >> $resultfile 2>&1\n        echo -e \"$VULN_REASONS\" >> $resultfile 2>&1\n    else\n        echo \"U-64 최종 결과: 양호\" >> $resultfile 2>&1\n    fi\n    \n    return $VULNERABLE\n}"
      },
      {
        "id": "section_64",
        "name": "u_65",
        "description": "u_65 함수 실행",
        "content": "u_65() {\n    echo \"U-65: at 파일 소유자 및 권한 설정\" >> $resultfile 2>&1\n    VULNERABLE=0\n    VULN_REASONS=\"\"\n    \n    # at 관련 파일들\n    at_files=(\"/etc/at.allow\" \"/etc/at.deny\")\n    \n    for at_file in \"${at_files[@]}\"; do\n        if [ -f \"$at_file\" ]; then\n            # 소유자 확인 (root여야 함)\n            owner=$(stat -c \"%U\" \"$at_file\" 2>/dev/null)\n            if [ \"$owner\" != \"root\" ]; then\n                VULNERABLE=1\n                VULN_REASONS=\"$VULN_REASONS- $at_file 소유자가 root가 아님 (현재: $owner)\\n\"\n            fi\n            \n            # 권한 확인 (600, 640 권장)\n            perms=$(stat -c \"%a\" \"$at_file\" 2>/dev/null)\n            if [ \"$perms\" != \"640\" ] && [ \"$perms\" != \"600\" ]; then\n                VULNERABLE=1\n                VULN_REASONS=\"$VULN_REASONS- $at_file 권한이 부적절함 (현재: $perms, 권장: 600, 640)\\n\"\n            fi\n        fi\n    done\n    \n    # at.allow와 at.deny 모두 없는 경우\n    if [ ! -f \"/etc/at.allow\" ] && [ ! -f \"/etc/at.deny\" ]; then\n        VULNERABLE=1\n        VULN_REASONS=\"$VULN_REASONS- at.allow 또는 at.deny 파일이 존재하지 않음\\n\"\n    fi\n    \n    # at 서비스 상태 확인\n    if systemctl is-active --quiet atd.service 2>/dev/null; then\n        # at.allow가 있으면 더 안전함\n        if [ -f \"/etc/at.allow\" ]; then\n            # at.allow 존재 (권장 설정)\n            :\n        elif [ -f \"/etc/at.deny\" ]; then\n            # at.deny에 root가 포함되어 있으면 문제\n            if ! grep -q \"^root$\" \"/etc/at.deny\"; then\n                VULNERABLE=1\n                VULN_REASONS=\"$VULN_REASONS- at.deny에 root 계정이 차단되지 않음\\n\"\n            fi\n        fi\n    fi\n    \n    if [ $VULNERABLE -eq 1 ]; then\n        echo \"U-65 최종 결과: 취약\" >> $resultfile 2>&1\n        echo \"취약 이유:\" >> $resultfile 2>&1\n        echo -e \"$VULN_REASONS\" >> $resultfile 2>&1\n    else\n        echo \"U-65 최종 결과: 양호\" >> $resultfile 2>&1\n    fi\n    \n    return $VULNERABLE\n}"
      },
      {
        "id": "section_65",
        "name": "u_66",
        "description": "u_66 함수 실행",
        "content": "u_66() {\n    echo \"U-66: SNMP 서비스 구동 점검\" >> $resultfile 2>&1\n    VULNERABLE=0\n    VULN_REASONS=\"\"\n    \n    # SNMP 패키지 설치 확인\n    if dpkg -l 2>/dev/null | grep -iq snmp; then\n        # SNMP 서비스 실행 상태 확인\n        if systemctl is-active --quiet snmpd.service 2>/dev/null; then\n            VULNERABLE=1\n            VULN_REASONS=\"$VULN_REASONS- SNMP 서비스가 실행 중임\\n\"\n        fi\n        \n        # SNMP 설정 파일 확인\n        if [ -f \"/etc/snmp/snmpd.conf\" ]; then\n            # 기본 커뮤니티 스트링 확인\n            if grep -E \"^\\s*(community|com2sec)\" /etc/snmp/snmpd.conf | grep -iq \"public\\|private\"; then\n                VULNERABLE=1\n                VULN_REASONS=\"$VULN_REASONS- 기본 커뮤니티 스트링(public/private) 사용\\n\"\n            fi\n        fi\n    fi\n    \n    if [ $VULNERABLE -eq 1 ]; then\n        echo \"U-66 최종 결과: 취약\" >> $resultfile 2>&1\n        echo \"취약 이유:\" >> $resultfile 2>&1\n        echo -e \"$VULN_REASONS\" >> $resultfile 2>&1\n    else\n        echo \"U-66 최종 결과: 양호\" >> $resultfile 2>&1\n    fi\n    \n    return $VULNERABLE\n}"
      },
      {
        "id": "section_66",
        "name": "u_67",
        "description": "u_67 함수 실행",
        "content": "u_67() {\n    echo \"U-67: SNMP 서비스 커뮤니티스트링의 복잡성 설정\" >> $resultfile 2>&1\n    VULNERABLE=0\n    VULN_REASONS=\"\"\n    \n    if [ -f \"/etc/snmp/snmpd.conf\" ]; then\n        # 기본 커뮤니티 스트링(public, private) 사용 확인\n        if grep -E \"^\\s*(community|com2sec)\" /etc/snmp/snmpd.conf | grep -v \"^#\" | grep -iq \"public\\|private\"; then\n            VULNERABLE=1\n            VULN_REASONS=\"$VULN_REASONS- 기본 커뮤니티 스트링(public/private) 사용\\n\"\n        fi\n    fi\n    \n    if [ $VULNERABLE -eq 1 ]; then\n        echo \"U-67 최종 결과: 취약\" >> $resultfile 2>&1\n        echo \"취약 이유:\" >> $resultfile 2>&1\n        echo -e \"$VULN_REASONS\" >> $resultfile 2>&1\n    else\n        echo \"U-67 최종 결과: 양호\" >> $resultfile 2>&1\n    fi\n    \n    return $VULNERABLE\n}"
      },
      {
        "id": "section_67",
        "name": "u_68",
        "description": "u_68 함수 실행",
        "content": "u_68() {\n    echo \"U-68: 로그온 시 경고 메시지 제공\" >> $resultfile 2>&1\n    VULNERABLE=0\n    VULN_REASONS=\"\"\n    \n    # /etc/issue 파일 확인 (콘솔 로그인)\n    if [ -f \"/etc/issue\" ]; then\n        if [ ! -s \"/etc/issue\" ] || grep -q \"Ubuntu\\|Kernel\\|Welcome\" /etc/issue; then\n            VULNERABLE=1\n            VULN_REASONS=\"$VULN_REASONS- /etc/issue에 보안 경고 메시지가 없음\\n\"\n        fi\n    else\n        VULNERABLE=1\n        VULN_REASONS=\"$VULN_REASONS- /etc/issue 파일이 존재하지 않음\\n\"\n    fi\n    \n    # /etc/issue.net 파일 확인 (네트워크 로그인)\n    if [ -f \"/etc/issue.net\" ]; then\n        if [ ! -s \"/etc/issue.net\" ] || grep -q \"Ubuntu\\|Kernel\\|Welcome\" /etc/issue.net; then\n            VULNERABLE=1\n            VULN_REASONS=\"$VULN_REASONS- /etc/issue.net에 보안 경고 메시지가 없음\\n\"\n        fi\n    else\n        VULNERABLE=1\n        VULN_REASONS=\"$VULN_REASONS- /etc/issue.net 파일이 존재하지 않음\\n\"\n    fi\n    \n    # SSH 배너 설정 확인\n    if [ -f \"/etc/ssh/sshd_config\" ]; then\n        if ! grep -q \"^Banner\" /etc/ssh/sshd_config; then\n            VULNERABLE=1\n            VULN_REASONS=\"$VULN_REASONS- SSH 배너 설정이 없음\\n\"\n        fi\n    fi\n    \n    if [ $VULNERABLE -eq 1 ]; then\n        echo \"U-68 최종 결과: 취약\" >> $resultfile 2>&1\n        echo \"취약 이유:\" >> $resultfile 2>&1\n        echo -e \"$VULN_REASONS\" >> $resultfile 2>&1\n        echo \"권장 조치: 로그인 시 보안 경고 메시지 설정\" >> $resultfile 2>&1\n    else\n        echo \"U-68 최종 결과: 양호\" >> $resultfile 2>&1\n    fi\n    \n    return $VULNERABLE\n}"
      },
      {
        "id": "section_68",
        "name": "u_69",
        "description": "u_69 함수 실행",
        "content": "u_69() {\n    echo \"U-69: NFS 설정파일 접근 제한\" >> $resultfile 2>&1\n    VULNERABLE=0\n    VULN_REASONS=\"\"\n    \n    # NFS 설정 파일들 확인\n    nfs_files=(\"/etc/exports\" \"/etc/nfs.conf\" \"/etc/nfsmount.conf\")\n    \n    for nfs_file in \"${nfs_files[@]}\"; do\n        if [ -f \"$nfs_file\" ]; then\n            # 소유자 확인 (root여야 함)\n            owner=$(stat -c \"%U\" \"$nfs_file\" 2>/dev/null)\n            if [ \"$owner\" != \"root\" ]; then\n                VULNERABLE=1\n                VULN_REASONS=\"$VULN_REASONS- $nfs_file 소유자가 root가 아님 (현재: $owner)\\n\"\n            fi\n            \n            # 권한 확인 (644 이하 권장)\n            perms=$(stat -c \"%a\" \"$nfs_file\" 2>/dev/null)\n            if [ \"$perms\" -gt 644 ]; then\n                VULNERABLE=1\n                VULN_REASONS=\"$VULN_REASONS- $nfs_file 권한이 과도함 (현재: $perms, 권장: 644 이하)\\n\"\n            fi\n            \n            # /etc/exports 보안 설정 확인\n            if [ \"$nfs_file\" = \"/etc/exports\" ]; then\n                # no_root_squash 확인 (보안상 위험)\n                if grep -v \"^#\" \"$nfs_file\" | grep -q \"no_root_squash\"; then\n                    VULNERABLE=1\n                    VULN_REASONS=\"$VULN_REASONS- /etc/exports에 no_root_squash 설정 발견 (보안 위험)\\n\"\n                fi\n                \n                # 모든 호스트 허용 확인 (*)\n                if grep -v \"^#\" \"$nfs_file\" | grep -E \"\\s+\\*\\s*\\(\"; then\n                    VULNERABLE=1\n                    VULN_REASONS=\"$VULN_REASONS- /etc/exports에서 모든 호스트(*) 허용 설정 발견\\n\"\n                fi\n            fi\n        fi\n    done\n    \n    if [ $VULNERABLE -eq 1 ]; then\n        echo \"U-69 최종 결과: 취약\" >> $resultfile 2>&1\n        echo \"취약 이유:\" >> $resultfile 2>&1\n        echo -e \"$VULN_REASONS\" >> $resultfile 2>&1\n    else\n        echo \"U-69 최종 결과: 양호\" >> $resultfile 2>&1\n    fi\n    \n    return $VULNERABLE\n}"
      },
      {
        "id": "section_69",
        "name": "u_70",
        "description": "u_70 함수 실행",
        "content": "u_70() {\n    echo \"U-70: expn, vrfy 명령어 제한\" >> $resultfile 2>&1\n    VULNERABLE=0\n    VULN_REASONS=\"\"\n    \n    # SMTP 서비스 실행 상태 확인\n    smtp_running=0\n    mail_services=(\"sendmail\" \"postfix\" \"exim4\")\n    \n    for service in \"${mail_services[@]}\"; do\n        if systemctl is-active --quiet \"${service}.service\" 2>/dev/null; then\n            smtp_running=1\n            break\n        fi\n    done\n    \n    # SMTP 서비스가 실행되지 않으면 양호\n    if [ $smtp_running -eq 0 ]; then\n        echo \"U-70 최종 결과: 양호\" >> $resultfile 2>&1\n        return 0\n    fi\n    \n    # SMTP 서비스가 실행 중이면 보안 설정 확인\n    # Sendmail 설정 확인\n    if [ -f \"/etc/mail/sendmail.cf\" ]; then\n        if ! grep -q \"O PrivacyOptions.*noexpn\" /etc/mail/sendmail.cf; then\n            VULNERABLE=1\n            VULN_REASONS=\"$VULN_REASONS- Sendmail에서 expn 명령어가 제한되지 않음\\n\"\n        fi\n        \n        if ! grep -q \"O PrivacyOptions.*novrfy\" /etc/mail/sendmail.cf; then\n            VULNERABLE=1\n            VULN_REASONS=\"$VULN_REASONS- Sendmail에서 vrfy 명령어가 제한되지 않음\\n\"\n        fi\n    fi\n    \n    if [ $VULNERABLE -eq 1 ]; then\n        echo \"U-70 최종 결과: 취약\" >> $resultfile 2>&1\n        echo \"취약 이유:\" >> $resultfile 2>&1\n        echo -e \"$VULN_REASONS\" >> $resultfile 2>&1\n    else\n        echo \"U-70 최종 결과: 양호\" >> $resultfile 2>&1\n    fi\n    \n    return $VULNERABLE\n}"
      },
      {
        "id": "section_70",
        "name": "u_71",
        "description": "u_71 함수 실행",
        "content": "u_71() {\n    echo \"U-71: Apache 웹 서비스 정보 숨김\" >> $resultfile 2>&1\n    VULNERABLE=0\n    VULN_REASONS=\"\"\n    \n    # Apache 설정 파일들\n    apache_configs=(\"/etc/apache2/apache2.conf\" \"/etc/apache2/conf-available/security.conf\" \"/etc/httpd/conf/httpd.conf\")\n    \n    apache_installed=0\n    for config in \"${apache_configs[@]}\"; do\n        if [ -f \"$config\" ]; then\n            apache_installed=1\n            \n            # ServerTokens 설정 확인\n            servertokens=$(grep -E \"^\\s*ServerTokens\" \"$config\" | tail -1 | awk '{print $2}')\n            if [ -z \"$servertokens\" ] || [ \"$servertokens\" != \"Prod\" ]; then\n                VULNERABLE=1\n                VULN_REASONS=\"$VULN_REASONS- ServerTokens가 Prod로 설정되지 않음 (현재: $servertokens)\\n\"\n            fi\n            \n            # ServerSignature 설정 확인\n            serversignature=$(grep -E \"^\\s*ServerSignature\" \"$config\" | tail -1 | awk '{print $2}')\n            if [ -z \"$serversignature\" ] || [ \"$serversignature\" != \"Off\" ]; then\n                VULNERABLE=1\n                VULN_REASONS=\"$VULN_REASONS- ServerSignature가 Off로 설정되지 않음 (현재: $serversignature)\\n\"\n            fi\n        fi\n    done\n    \n    # Apache 서비스 상태 확인\n    if systemctl is-active --quiet apache2.service 2>/dev/null || systemctl is-active --quiet httpd.service 2>/dev/null; then\n        # HTTP 응답 헤더 확인 (curl이 설치된 경우)\n        if command -v curl >/dev/null 2>&1; then\n            server_header=$(curl -Is http://localhost 2>/dev/null | grep -i \"^server:\" | head -1)\n            if echo \"$server_header\" | grep -iq \"apache.*ubuntu\\|apache.*[0-9]\\|apache.*mod_\"; then\n                VULNERABLE=1\n                VULN_REASONS=\"$VULN_REASONS- HTTP 응답 헤더에 상세한 Apache 정보 노출\\n\"\n            fi\n        fi\n    fi\n    \n    if [ $VULNERABLE -eq 1 ]; then\n        echo \"U-71 최종 결과: 취약\" >> $resultfile 2>&1\n        echo \"취약 이유:\" >> $resultfile 2>&1\n        echo -e \"$VULN_REASONS\" >> $resultfile 2>&1\n    else\n        echo \"U-71 최종 결과: 양호\" >> $resultfile 2>&1\n    fi\n    \n    return $VULNERABLE\n}\n# task 패치관리 | 최신화가 되어 있는지"
      },
      {
        "id": "section_71",
        "name": "u_42",
        "description": "u_42 함수 실행",
        "content": "u_42() {\n\n    echo \"U-42: 최신 보안패치 및 벤더 권고사항 적용\" >> $resultfile 2>&1\n    VULNERABLE=0\n    VULN_REASONS=\"\"\n    \n    # apt 업데이트 목록 갱신 (에러 무시)\n    apt update >/dev/null 2>&1\n    \n    # 업그레이드 가능한 패키지 수 확인\n    upgradable=$(apt list --upgradable 2>/dev/null | grep -c \"upgradable from\")\n    if [ \"$upgradable\" -gt 0 ]; then\n        VULNERABLE=1\n        VULN_REASONS=\"$VULN_REASONS- 업그레이드 가능한 패키지가 $upgradable 개 있음\\n\"\n    fi\n    \n    # 보안 업데이트 확인\n    security_updates=$(apt list --upgradable 2>/dev/null | grep -c \"security\")\n    if [ \"$security_updates\" -gt 0 ]; then\n        VULNERABLE=1\n        VULN_REASONS=\"$VULN_REASONS- 보안 업데이트가 $security_updates 개 있음\\n\"\n    fi\n    \n    # 마지막 업데이트 시기 확인\n    if [ -f \"/var/log/apt/history.log\" ]; then\n        last_update=$(grep \"Start-Date:\" /var/log/apt/history.log | tail -1 | cut -d' ' -f2)\n        if [ -n \"$last_update\" ]; then\n            # 30일 이상 업데이트하지 않은 경우\n            if [ $(date -d \"$last_update\" +%s) -lt $(date -d \"30 days ago\" +%s) ]; then\n                VULNERABLE=1\n                VULN_REASONS=\"$VULN_REASONS- 30일 이상 시스템 업데이트를 하지 않음\\n\"\n            fi\n        fi\n    fi\n    \n    # unattended-upgrades 설정 확인 (자동 보안 업데이트)\n    if [ -f \"/etc/apt/apt.conf.d/50unattended-upgrades\" ]; then\n        if ! grep -q \"security\" /etc/apt/apt.conf.d/50unattended-upgrades || \\\n           grep -q \"^//.*security\" /etc/apt/apt.conf.d/50unattended-upgrades; then\n            VULNERABLE=1\n            VULN_REASONS=\"$VULN_REASONS- 자동 보안 업데이트가 비활성화됨\\n\"\n        fi\n    else\n        VULNERABLE=1\n        VULN_REASONS=\"$VULN_REASONS- unattended-upgrades가 설정되지 않음\\n\"\n    fi\n    \n    if [ $VULNERABLE -eq 1 ]; then\n        echo \"U-42 최종 결과: 취약\" >> $resultfile 2>&1\n        echo \"취약 이유:\" >> $resultfile 2>&1\n        echo -e \"$VULN_REASONS\" >> $resultfile 2>&1\n    else\n        echo \"U-42 최종 결과: 양호\" >> $resultfile 2>&1\n    fi\n    \n    return $VULNERABLE\n}\n# task 로그 관리 | 로그에 대한 보고서등"
      },
      {
        "id": "section_72",
        "name": "u_43",
        "description": "u_43 함수 실행",
        "content": "u_43() {\n\n    echo \"U-43: 로그의 정기적 검토 및 보고\" >> $resultfile 2>&1\n    VULNERABLE=0\n    VULN_REASONS=\"\"\n    \n    # 시스템 로그 파일들 확인\n    log_files=(\"/var/log/syslog\" \"/var/log/auth.log\" \"/var/log/kern.log\" \"/var/log/daemon.log\")\n    \n    for log_file in \"${log_files[@]}\"; do\n        if [ -f \"$log_file\" ]; then\n            # 로그 파일 크기 확인\n            size=$(stat -c%s \"$log_file\" 2>/dev/null)\n            if [ \"$size\" -eq 0 ]; then\n                VULNERABLE=1\n                VULN_REASONS=\"$VULN_REASONS- $log_file 파일이 비어있음\\n\"\n            fi\n            \n            # 최근 로그 기록 확인 (24시간 이내)\n            if [ -z \"$(find \"$log_file\" -mtime -1 2>/dev/null)\" ]; then\n                VULNERABLE=1\n                VULN_REASONS=\"$VULN_REASONS- $log_file: 24시간 내 기록이 없음\\n\"\n            fi\n        else\n            VULNERABLE=1\n            VULN_REASONS=\"$VULN_REASONS- $log_file 파일이 존재하지 않음\\n\"\n        fi\n    done\n    \n    # rsyslog 서비스 확인\n    if ! systemctl is-active --quiet rsyslog.service 2>/dev/null; then\n        VULNERABLE=1\n        VULN_REASONS=\"$VULN_REASONS- rsyslog 서비스가 실행되지 않음\\n\"\n    fi\n    \n    # logrotate 설정 확인\n    if [ -f \"/etc/logrotate.conf\" ]; then\n        # 로그 순환 주기 확인\n        if ! grep -q \"daily\\|weekly\\|monthly\" /etc/logrotate.conf; then\n            VULNERABLE=1\n            VULN_REASONS=\"$VULN_REASONS- logrotate 순환 주기가 설정되지 않음\\n\"\n        fi\n    else\n        VULNERABLE=1\n        VULN_REASONS=\"$VULN_REASONS- logrotate 설정 파일이 존재하지 않음\\n\"\n    fi\n    \n    # 로그 모니터링 도구 확인\n    monitoring_tools=(\"logwatch\" \"fail2ban\" \"logcheck\")\n    tools_installed=0\n    for tool in \"${monitoring_tools[@]}\"; do\n        if dpkg -l 2>/dev/null | grep -q \"^ii.*$tool\"; then\n            tools_installed=1\n        fi\n    done\n    \n    if [ $tools_installed -eq 0 ]; then\n        VULNERABLE=1\n        VULN_REASONS=\"$VULN_REASONS- 로그 모니터링 도구가 설치되지 않음\\n\"\n    fi\n    \n    if [ $VULNERABLE -eq 1 ]; then\n        echo \"U-43 최종 결과: 취약\" >> $resultfile 2>&1\n        echo \"취약 이유:\" >> $resultfile 2>&1\n        echo -e \"$VULN_REASONS\" >> $resultfile 2>&1\n    else\n        echo \"U-43 최종 결과: 양호\" >> $resultfile 2>&1\n    fi\n    \n    return $VULNERABLE\n}"
      },
      {
        "id": "section_73",
        "name": "u_72",
        "description": "u_72 함수 실행",
        "content": "u_72() {\n    echo \"U-72: 정책에 따른 시스템 로그 설정\" >> $resultfile 2>&1\n    VULNERABLE=0\n    VULN_REASONS=\"\"\n    \n    # rsyslog 설정 파일 확인\n    if [ -f \"/etc/rsyslog.conf\" ]; then\n        # 주요 로그 유형별 설정 확인\n        log_types=(\"auth\" \"authpriv\" \"cron\" \"daemon\" \"kern\" \"mail\" \"user\" \"syslog\")\n        \n        for log_type in \"${log_types[@]}\"; do\n            if ! grep -q \"^[^#]*$log_type\\.\" /etc/rsyslog.conf; then\n                VULNERABLE=1\n                VULN_REASONS=\"$VULN_REASONS- $log_type 로그 설정이 없음\\n\"\n            fi\n        done\n        \n        # 로그 파일별 설정 확인\n        required_logs=(\"auth.log\" \"syslog\" \"kern.log\" \"daemon.log\")\n        for log in \"${required_logs[@]}\"; do\n            if ! grep -q \"/var/log/$log\" /etc/rsyslog.conf; then\n                VULNERABLE=1\n                VULN_REASONS=\"$VULN_REASONS- /var/log/$log 설정이 없음\\n\"\n            fi\n        done\n        \n    else\n        VULNERABLE=1\n        VULN_REASONS=\"$VULN_REASONS- rsyslog 설정 파일이 존재하지 않음\\n\"\n    fi\n    \n    # 로그 디렉토리 권한 확인\n    if [ -d \"/var/log\" ]; then\n        log_perms=$(stat -c \"%a\" \"/var/log\" 2>/dev/null)\n        if [ \"$log_perms\" != \"755\" ]; then\n            VULNERABLE=1\n            VULN_REASONS=\"$VULN_REASONS- /var/log 디렉토리 권한이 부적절함 (현재: $log_perms, 권장: 755)\\n\"\n        fi\n    fi\n    \n    # 주요 로그 파일 권한 확인\n    log_files=(\"/var/log/auth.log\" \"/var/log/syslog\" \"/var/log/kern.log\")\n    for log_file in \"${log_files[@]}\"; do\n        if [ -f \"$log_file\" ]; then\n            perms=$(stat -c \"%a\" \"$log_file\" 2>/dev/null)\n            if [ \"$perms\" -gt 640 ]; then\n                VULNERABLE=1\n                VULN_REASONS=\"$VULN_REASONS- $log_file 권한이 과도함 (현재: $perms, 권장: 640 이하)\\n\"\n            fi\n            \n            owner=$(stat -c \"%U\" \"$log_file\" 2>/dev/null)\n            if [ \"$owner\" != \"root\" ] && [ \"$owner\" != \"syslog\" ]; then\n                VULNERABLE=1\n                VULN_REASONS=\"$VULN_REASONS- $log_file 소유자가 부적절함 (현재: $owner)\\n\"\n            fi\n        fi\n    done\n    \n    # systemd journal 설정 확인\n    if [ -f \"/etc/systemd/journald.conf\" ]; then\n        # Storage 설정 확인\n        storage=$(grep \"^Storage=\" /etc/systemd/journald.conf 2>/dev/null | cut -d= -f2)\n        if [ \"$storage\" = \"none\" ]; then\n            VULNERABLE=1\n            VULN_REASONS=\"$VULN_REASONS- systemd journal Storage가 none으로 설정됨\\n\"\n        fi\n    fi\n    \n    if [ $VULNERABLE -eq 1 ]; then\n        echo \"U-72 최종 결과: 취약\" >> $resultfile 2>&1\n        echo \"취약 이유:\" >> $resultfile 2>&1\n        echo -e \"$VULN_REASONS\" >> $resultfile 2>&1\n    else\n        echo \"U-72 최종 결과: 양호\" >> $resultfile 2>&1\n    fi\n    \n    return $VULNERABLE\n}\nu_01\nu_02\nu_03\nu_04\nu_44\nu_45\nu_46\nu_47\nu_48\nu_49\nu_50\nu_51\nu_52\nu_53\nu_54\nu_05\nu_06 \nu_07\nu_08\nu_09\nu_10\nu_11\nu_12\nu_13\nu_14\nu_15\nu_16\nu_17\nu_18\nu_55\nu_56\nu_57\nu_58\nu_59\nu_19\nu_20\nu_21\nu_22\nu_23\nu_24\nu_25\nu_26\nu_27\nu_28\nu_29\nu_30\nu_31\nu_32\nu_33\nu_34\nu_35\nu_36\nu_37\nu_38\nu_39\nu_60\nu_61\nu_62\nu_63\nu_64\nu_65\nu_66\nu_67\nu_68\nu_69\nu_70\nu_71\nu_42\nu_43\nu_72\n\n\necho \"결과 파일 생성: $resultfile\"\nls -la *.csv"
      }
    ],
    "type": "shell"
  },
  {
    "id": 3,
    "name": "2222",
    "description": "2222222",
    "lastRun": "실행 안됨",
    "status": "대기중",
    "tasks": 1,
    "filename": "3_우분투.sh",
    "sections": [
      {
        "id": "section_1",
        "name": "전체 스크립트",
        "description": "전체 스크립트 실행",
        "content": "#!/usr/bin/env python3\n\nimport subprocess\nimport csv\nimport os\nimport re\nimport stat\nimport glob\nimport platform\nimport datetime\nimport shutil\nimport pwd\n\nresults = []\n\ndef run_command(command):\n    try:\n        result = subprocess.run(command, shell=True, check=False, stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True)\n        if result.returncode == 0:\n            return result.stdout.strip()\n        elif result.returncode == 1:\n            return \"\"\n        else:\n            return f\"[Error] {command}{result.stderr.strip()}\"\n    except subprocess.CalledProcessError as e:\n        return f\"[Error] {e.stderr.strip()}\"\n\ndef print_table_header():\n    print(f\"{'항목':<40} | {'결과':<6} | 상세\")\n    print(\"-\" * 80)\n\ndef print_table_row(item, result, detail):\n    result_map = {\n        \"GOOD\": \"양호\",\n        \"BAD\": \"취약\",\n        \"N/A\": \"해당 없음\"\n    }\n    result_display = result_map.get(result, result)\n    print(f\"{item:<40} | {result_display:<6} | {detail}\")\n    results.append([item, result_display, detail])\n\ndef check_remote_service():\n    item = \"[U-01] root 계정 원격접속제한\"\n    state = \"GOOD\"\n    reasons = []\n    telnet_services = run_command(\"systemctl list-unit-files | grep -i telnet\")\n    if telnet_services:\n        state = \"BAD\"\n        reasons.append(\"Telnet 서비스가 등록되어 있음\")\n    telnet_packages = run_command(\"dpkg -l | grep -i telnet\")\n    if telnet_packages:\n        state = \"BAD\"\n        reasons.append(\"Telnet 패키지가 설치되어 있음\")\n    if subprocess.run(\"grep -Eq '^\\\\s*#\\\\s*PermitRootLogin' /etc/ssh/sshd_config\", shell=True).returncode == 0:\n        pass\n    elif subprocess.run(\"grep -Eq '^\\\\s*PermitRootLogin\\\\s+yes\\\\b' /etc/ssh/sshd_config\", shell=True).returncode == 0:\n        state = \"BAD\"\n        reasons.append(\"SSH PermitRootLogin yes로 설정됨\")\n    else:\n        pass\n    detail = \"; \".join(reasons) if state != \"GOOD\" else \"원격 접속 보안 설정이 적절히 구성됨\"\n    print_table_row(item, state, detail)\n\ndef check_password_complexity():\n    item = \"[U-02] 패스워드 복잡성 설정\"\n    state = \"GOOD\"\n    reasons = []\n    params = [\"lcredit\", \"ucredit\", \"dcredit\", \"ocredit\", \"minlen\", \"difok\"]\n    filepath = \"/etc/security/pwquality.conf\"\n    try:\n        with open(filepath, \"r\") as f:\n            lines = f.readlines()\n        conf = {k: None for k in params}\n        for line in lines:\n            line = line.strip()\n            if not line or line.startswith(\"#\"):\n                continue\n            for p in params:\n                if line.startswith(p):\n                    parts = line.split(\"=\")\n                    if len(parts) == 2:\n                        conf[p] = parts[1].strip()\n        for p in params:\n            v = conf[p]\n            if v is None:\n                state = \"BAD\"\n                reasons.append(f\"{p} 미설정\")\n            elif p in [\"lcredit\", \"ucredit\", \"dcredit\", \"ocredit\"]:\n                try:\n                    if int(v) < -1:\n                        state = \"BAD\"\n                        reasons.append(f\"{p}={v} (약한 정책)\")\n                except:\n                    state = \"BAD\"\n                    reasons.append(f\"{p} 값 오류\")\n            elif p == \"minlen\":\n                try:\n                    if int(v) < 9:\n                        state = \"BAD\"\n                        reasons.append(f\"minlen={v} (9 미만)\")\n                except:\n                    state = \"BAD\"\n                    reasons.append(\"minlen 값 오류\")\n            elif p == \"difok\":\n                if v.strip().upper() != \"N\":\n                    state = \"BAD\"\n                    reasons.append(f\"difok={v} (비권장)\")\n    except FileNotFoundError:\n        state = \"N/A\"\n        reasons.append(\"pwquality.conf 파일 없음\")\n    detail = \"; \".join(reasons) if state != \"GOOD\" else \"모든 설정이 기준 충족됨\"\n    print_table_row(item, state, detail)\n\ndef check_common_auth():\n    item = \"[U-03] 계정 잠금 임계값 설정\"\n    state = \"GOOD\"\n    reasons = []\n    filepath = \"/etc/pam.d/common-auth\"\n    found = False\n    try:\n        with open(filepath, \"r\") as f:\n            for line in f:\n                line = line.strip()\n                if \"pam_tally2.so\" in line or \"pam_faillock.so\" in line:\n                    found = True\n                    parts = line.split()\n                    for part in parts:\n                        if part.startswith(\"deny=\"):\n                            try:\n                                deny_val = int(part.split(\"=\")[1])\n                                if deny_val > 10:\n                                    state = \"BAD\"\n                                    reasons.append(f\"deny={deny_val} (10회 초과)\")\n                                break\n                            except:\n                                state = \"BAD\"\n                                reasons.append(\"deny 값 오류\")\n                    else:\n                        state = \"BAD\"\n                        reasons.append(\"deny 설정 없음\")\n                    break\n        if not found:\n            state = \"N/A\"\n            reasons.append(\"pam_tally2/faillock 관련 설정 없음\")\n    except FileNotFoundError:\n        state = \"N/A\"\n        reasons.append(\"common-auth 파일 없음\")\n    detail = \"; \".join(reasons) if state != \"GOOD\" else \"계정 잠금 임계값이 적절히 설정됨\"\n    print_table_row(item, state, detail)\n\ndef protect_hash_pwd_file():\n    item = \"[U-04] 패스워드 파일 보호\"\n    state = \"GOOD\"\n    reasons = []\n    try:\n        with open(\"/etc/passwd\", \"r\") as f:\n            for line in f:\n                if line.startswith(\"#\") or not line.strip():\n                    continue\n                parts = line.strip().split(\":\")\n                if len(parts) > 1 and parts[1] != \"x\":\n                    state = \"BAD\"\n                    reasons.append(f\"{parts[0]} 계정 패스워드 필드에 암호 저장\")\n    except Exception as e:\n        state = \"N/A\"\n        reasons.append(f\"/etc/passwd 읽기 오류: {e}\")\n    try:\n        with open(\"/etc/shadow\", \"r\") as f:\n            for line in f:\n                if line.startswith(\"#\") or not line.strip():\n                    continue\n                parts = line.strip().split(\":\")\n                if len(parts) > 1:\n                    password_hash = parts[1]\n                    if password_hash not in [\"*\", \"!\", \"!!\"] and not password_hash.startswith(\"$\"):\n                        state = \"BAD\"\n                        reasons.append(f\"{parts[0]} 계정 해시 이상\")\n    except Exception as e:\n        state = \"N/A\"\n        reasons.append(f\"/etc/shadow 읽기 오류: {e}\")\n    detail = \"; \".join(reasons) if state != \"GOOD\" else \"보안 조치 완료: 패스워드가 shadow 파일에 안전하게 저장됨, 모든 계정 해시가 적절한 형식으로 저장됨\"\n    print_table_row(item, state, detail)\n\ndef only_root_uid():\n    item = \"[U-44] root 이외의 UID가 '0' 금지\"\n    state = \"GOOD\"\n    reasons = []\n    try:\n        with open(\"/etc/passwd\", \"r\") as f:\n            for line in f:\n                if line.startswith(\"#\") or not line.strip():\n                    continue\n                parts = line.strip().split(\":\")\n                if len(parts) > 2 and parts[2] == \"0\" and parts[0] != \"root\":\n                    state = \"BAD\"\n                    reasons.append(f\"{parts[0]} 계정이 UID 0\")\n    except Exception as e:\n        state = \"N/A\"\n        reasons.append(f\"읽기 오류: {e}\")\n    detail = \"; \".join(reasons) if state != \"GOOD\" else \"root 외 UID 0 계정이 없음\"\n    print_table_row(item, state, detail)\n\ndef check_su_restriction():\n    item = \"[U-45] root 계정 su 제한\"\n    state = \"GOOD\"\n    reasons = []\n    \n    # 1. pam_wheel.so 설정 검사\n    pam_file = \"/etc/pam.d/su\"\n    try:\n        with open(pam_file, 'r') as f:\n            pam_found = False\n            for line in f:\n                line = line.strip()\n                if \"pam_wheel.so\" in line and not line.startswith(\"#\"):\n                    pam_found = True\n                    if \"use_uid\" not in line:\n                        reasons.append(f\"{pam_file}: use_uid 옵션 누락\")\n                    break\n            \n            if not pam_found:\n                reasons.append(f\"{pam_file}: pam_wheel.so 미설정\")\n\n    except Exception as e:\n        state = \"ERROR\"\n        reasons.append(f\"{pam_file} 읽기 실패: {str(e)}\")\n    \n    # 2. sudo/wheel 그룹 검사\n    group_file = \"/etc/group\"\n    try:\n        sudo_group = None\n        wheel_group = None\n        \n        with open(group_file, 'r') as f:\n            for line in f:\n                if line.startswith('sudo:'):\n                    sudo_group = line.strip()\n                elif line.startswith('wheel:'):\n                    wheel_group = line.strip()\n        \n        # 그룹 존재 여부 확인\n        if not sudo_group and not wheel_group:\n            reasons.append(\"sudo/wheel 그룹 미존재\")\n        else:\n            # 사용자 존재 여부 확인\n            for group in [sudo_group, wheel_group]:\n                if group:\n                    users = group.split(':')[-1]\n                    if not users:\n                        reasons.append(f\"{group.split(':')[0]} 그룹에 사용자 없음\")\n\n    except Exception as e:\n        state = \"ERROR\"\n        reasons.append(f\"{group_file} 읽기 실패: {str(e)}\")\n    \n    # 최종 결과 판정\n    if reasons:\n        state = \"BAD\" if state != \"ERROR\" else state\n        detail = \"; \".join(reasons)\n    else:\n        detail = \"보안 조치 완료: pam_wheel.so 모듈 적절히 설정됨, sudo/wheel 그룹으로 권한 관리\"  # GOOD 상태 시 상세 설명 생략\n    \n    print_table_row(item, state, detail)\n\ndef check_pwd_length():\n    item = \"[U-46] 패스워드 최소 길이 설정\"\n    state = \"GOOD\"\n    reasons = []\n    filepath = \"/etc/security/pwquality.conf\"\n    try:\n        with open(filepath, \"r\") as f:\n            for line in f:\n                if line.startswith(\"#\") or not line.strip():\n                    continue\n                if \"minlen\" in line:\n                    parts = line.split(\"=\")\n                    if len(parts) == 2 and parts[0].strip() == \"minlen\":\n                        try:\n                            minlen_value = int(parts[1].strip())\n                            if minlen_value < 8:\n                                state = \"BAD\"\n                                reasons.append(f\"minlen={minlen_value} (8 미만)\")\n                        except:\n                            state = \"BAD\"\n                            reasons.append(\"minlen 값 오류\")\n                        break\n        if state == \"GOOD\" and not reasons:\n            pass\n        elif not reasons:\n            state = \"BAD\"\n            reasons.append(\"minlen 설정 없음\")\n    except FileNotFoundError:\n        state = \"N/A\"\n        reasons.append(\"pwquality.conf 파일 없음\")\n    detail = \"; \".join(reasons) if state != \"GOOD\" else \"패스워드 최소 길이가 적절히 설정됨\"\n    print_table_row(item, state, detail)\n\ndef check_pwd_maxdays():\n    item = \"[U-47] 패스워드 최대 사용기간 설정\"\n    state = \"GOOD\"\n    reasons = []\n    filepath = \"/etc/login.defs\"\n    found = False\n    try:\n        with open(filepath, \"r\") as f:\n            for line in f:\n                l = line.strip()\n                if l.startswith(\"#\") or not l:\n                    continue\n                if \"PASS_MAX_DAYS\" in l:\n                    found = True\n                    if \"=\" in l:\n                        parts = l.split(\"=\")\n                    else:\n                        parts = l.split()\n                    if len(parts) >= 2 and parts[0].strip() == \"PASS_MAX_DAYS\":\n                        try:\n                            max_value = int(parts[1].strip())\n                            if max_value < 90:\n                                state = \"BAD\"\n                                reasons.append(f\"PASS_MAX_DAYS={max_value} (90 미만)\")\n                        except:\n                            state = \"BAD\"\n                            reasons.append(\"PASS_MAX_DAYS 값 오류\")\n                        break\n        if not found:\n            state = \"BAD\"\n            reasons.append(\"PASS_MAX_DAYS 설정 없음\")\n    except FileNotFoundError:\n        state = \"N/A\"\n        reasons.append(\"login.defs 파일 없음\")\n    detail = \"; \".join(reasons) if state != \"GOOD\" else \"패스워드 최대 사용기간이 적절히 설정됨\"\n    print_table_row(item, state, detail)\n\ndef check_pwd_mindays():\n    item = \"[U-48] 패스워드 최소 사용기간 설정\"\n    state = \"GOOD\"\n    reasons = []\n    filepath = \"/etc/login.defs\"\n    found = False\n    try:\n        with open(filepath, \"r\") as f:\n            for line in f:\n                l = line.strip()\n                if l.startswith(\"#\") or not l:\n                    continue\n                if \"PASS_MIN_DAYS\" in l:\n                    found = True\n                    if \"=\" in l:\n                        parts = l.split(\"=\")\n                    else:\n                        parts = l.split()\n                    if len(parts) >= 2 and parts[0].strip() == \"PASS_MIN_DAYS\":\n                        try:\n                            min_value = int(parts[1].strip())\n                            if min_value > 1:\n                                state = \"BAD\"\n                                reasons.append(f\"PASS_MIN_DAYS={min_value} (1 초과)\")\n                        except:\n                            state = \"BAD\"\n                            reasons.append(\"PASS_MIN_DAYS 값 오류\")\n                        break\n        if not found:\n            state = \"BAD\"\n            reasons.append(\"PASS_MIN_DAYS 설정 없음\")\n    except FileNotFoundError:\n        state = \"N/A\"\n        reasons.append(\"login.defs 파일 없음\")\n    detail = \"; \".join(reasons) if state != \"GOOD\" else \"패스워드 최소 사용기간이 적절히 설정됨\"\n    print_table_row(item, state, detail)\n\ndef useless_user():\n    item = \"[U-49] 불필요한 계정 제거\"\n    state = \"GOOD\"\n    reasons = []\n    try:\n        with open(\"/etc/passwd\", \"r\") as f:\n            for line in f:\n                if line.startswith(\"#\") or not line.strip():\n                    continue\n                parts = line.strip().split(\":\")\n                if len(parts) >= 6:\n                    try:\n                        uid = int(parts[2])\n                    except:\n                        continue\n                    home_dir = parts[5]\n                    if uid >= 1000 and (not home_dir or not home_dir.startswith(\"/home/\")):\n                        state = \"BAD\"\n                        reasons.append(f\"{parts[0]}: 홈디렉토리({home_dir or '(없음)'})\")\n    except Exception as e:\n        state = \"N/A\"\n        reasons.append(f\"읽기 오류: {e}\")\n    detail = \"; \".join(reasons) if state != \"GOOD\" else \"\"\n    print_table_row(item, state, detail)\n\ndef check_admin_groups():\n    item = \"[U-50] 관리자 그룹에 최소한의 계정포함\"\n    state = \"GOOD\"\n    reasons = []\n    groups_to_check = [\"wheel\", \"sudo\"]\n    try:\n        with open(\"/etc/group\", \"r\") as f:\n            for line in f:\n                for group in groups_to_check:\n                    if line.startswith(f\"{group}:\"):\n                        parts = line.strip().split(\":\")\n                        if len(parts) >= 4 and parts[3]:\n                            members = [m for m in parts[3].split(\",\") if m]\n                            if members:\n                                state = \"BAD\"\n                                reasons.append(f\"{group} 그룹: {', '.join(members)}\")\n    except Exception as e:\n        state = \"N/A\"\n        reasons.append(f\"읽기 오류: {e}\")\n    detail = \"; \".join(reasons) if state != \"GOOD\" else \"관리자 그룹에 허용된 사용자만 포함됨\"\n    print_table_row(item, state, detail)\n\ndef check_useless_groups():\n    item = \"[U-51] 계정이 존재하지 않는 GID 금지\"\n    state = \"GOOD\"\n    reasons = []\n    group_file = \"/etc/group\"\n    gshadow_file = \"/etc/gshadow\"\n    try:\n        group_members = {}\n        gshadow_members = {}\n        with open(group_file, \"r\") as f:\n            for line in f:\n                parts = line.strip().split(\":\")\n                if len(parts) >= 4:\n                    groupname = parts[0]\n                    members = parts[3].split(\",\") if parts[3] else []\n                    group_members[groupname] = sorted([m for m in members if m])\n        with open(gshadow_file, \"r\") as f:\n            for line in f:\n                parts = line.strip().split(\":\")\n                if len(parts) >= 4:\n                    groupname = parts[0]\n                    members = parts[3].split(\",\") if parts[3] else []\n                    gshadow_members[groupname] = sorted([m for m in members if m])\n        for group in group_members:\n            if group in gshadow_members:\n                if group_members[group] != gshadow_members[group]:\n                    state = \"BAD\"\n                    reasons.append(f\"{group}: /etc/group({','.join(group_members[group])}) != /etc/gshadow({','.join(gshadow_members[group])})\")\n    except Exception as e:\n        state = \"N/A\"\n        reasons.append(f\"읽기 오류: {e}\")\n    detail = \"; \".join(reasons) if state != \"GOOD\" else \"모든 그룹이 일관되게 관리됨\"\n    print_table_row(item, state, detail)\n\ndef no_same_uid():\n    item = \"[U-52] 동일한 UID 금지\"\n    state = \"GOOD\"\n    reasons = []\n    try:\n        uid_map = {}\n        with open(\"/etc/passwd\", \"r\") as f:\n            for line in f:\n                if line.startswith(\"#\") or not line.strip():\n                    continue\n                parts = line.strip().split(\":\")\n                if len(parts) >= 3:\n                    username = parts[0]\n                    uid = parts[2]\n                    if uid not in uid_map:\n                        uid_map[uid] = []\n                    uid_map[uid].append(username)\n        for uid, users in uid_map.items():\n            if len(users) > 1:\n                state = \"BAD\"\n                reasons.append(f\"UID {uid}: {', '.join(users)}\")\n    except Exception as e:\n        state = \"N/A\"\n        reasons.append(f\"읽기 오류: {e}\")\n    detail = \"; \".join(reasons) if state != \"GOOD\" else \"모든 계정이 고유한 UID를 가짐\"\n    print_table_row(item, state, detail)\n\ndef check_user_shell():\n    item = \"[U-53] 사용자 Shell 점검\"\n    state = \"GOOD\"\n    reasons = []\n    try:\n        with open(\"/etc/passwd\", \"r\") as f:\n            for line in f:\n                if line.startswith(\"#\") or not line.strip():\n                    continue\n                parts = line.strip().split(\":\")\n                if len(parts) < 7:\n                    continue\n                username = parts[0]\n                try:\n                    uid = int(parts[2])\n                except:\n                    continue\n                shell = parts[6]\n                if 0 < uid < 1000 and shell not in [\"/usr/sbin/nologin\", \"/bin/false\"]:\n                    state = \"BAD\"\n                    reasons.append(f\"{username}(UID:{uid}) shell:{shell}\")\n    except Exception as e:\n        state = \"N/A\"\n        reasons.append(f\"읽기 오류: {e}\")\n    detail = \"; \".join(reasons) if state != \"GOOD\" else \"모든 시스템 계정이 안전한 쉘 사용\"\n    print_table_row(item, state, detail)\n\ndef session_timeout():\n    item = \"[U-54] Session Timeout 설정\"\n    state = \"GOOD\"\n    reasons = []\n    filepath = \"/etc/profile\"\n    tmout_value = None\n    try:\n        with open(filepath, \"r\") as f:\n            for line in f:\n                line = line.strip()\n                if line.startswith(\"#\") or not line:\n                    continue\n                if \"TMOUT\" in line:\n                    parts = line.split(\"=\")\n                    if len(parts) == 2:\n                        right = parts[1].strip()\n                        num_str = \"\"\n                        for ch in right:\n                            if ch.isdigit():\n                                num_str += ch\n                            else:\n                                break\n                        if num_str.isdigit():\n                            tmout_value = int(num_str)\n                            break\n        if tmout_value is None:\n            state = \"BAD\"\n            reasons.append(\"TMOUT 설정 없음\")\n        elif tmout_value < 600:\n            state = \"BAD\"\n            reasons.append(f\"TMOUT={tmout_value} (600 미만)\")\n    except Exception as e:\n        state = \"N/A\"\n        reasons.append(f\"읽기 오류: {e}\")\n    detail = \"; \".join(reasons) if state != \"GOOD\" else \"세션 타임아웃이 적절히 설정됨\"\n    print_table_row(item, state, detail)\n\ndef check_path():\n    item = \"[U-05] root 홈, 패스 디렉토리 권한 및 패스 설정\"\n    state = \"GOOD\"\n    reasons = []\n    filepath = \"/etc/environment\"\n    try:\n        with open(filepath, \"r\") as f:\n            for line in f:\n                line = line.strip()\n                if line.startswith(\"#\") or not line:\n                    continue\n                if \"PATH\" in line:\n                    parts = line.split(\"=\")\n                    if len(parts) != 2:\n                        continue\n                    path_value = parts[1].strip().strip('\"')\n                    if \".:\" in path_value or \"::\" in path_value:\n                        state = \"BAD\"\n                        reasons.append(\"'.:' 또는 '::' 포함\")\n                    break\n        if state == \"GOOD\" and not reasons:\n            pass\n        elif not reasons:\n            state = \"BAD\"\n            reasons.append(\"PATH 설정 없음\")\n    except Exception as e:\n        state = \"N/A\"\n        reasons.append(f\"읽기 오류: {e}\")\n    detail = \"; \".join(reasons) if state != \"GOOD\" else \"안전한 PATH 설정 적용됨\"\n    print_table_row(item, state, detail)\n\ndef check_owner_fd():\n    item = \"[U-06] 파일 및 디렉토리 소유자 설정\"\n    state = \"GOOD\"\n    reasons = []\n    bad_files = []\n\n    try:\n        nouser_result = subprocess.run([\"find\", \"/\", \"-nouser\"],\n                                       stdout=subprocess.PIPE,\n                                       stderr=subprocess.DEVNULL,\n                                       universal_newlines=True)\n        nogroup_result = subprocess.run([\"find\", \"/\", \"-nogroup\"],\n                                        stdout=subprocess.PIPE,\n                                        stderr=subprocess.DEVNULL,\n                                        universal_newlines=True)\n\n        nouser_files = nouser_result.stdout.strip().splitlines()\n        nogroup_files = nogroup_result.stdout.strip().splitlines()\n\n        bad_files.extend(nouser_files)\n        bad_files.extend(nogroup_files)\n\n        if bad_files:\n            state = \"BAD\"\n            reasons.append(f\"소유자/그룹 없는 파일 {len(bad_files)}개 존재\")\n    except Exception as e:\n        state = \"N/A\"\n        reasons.append(f\"점검 중 오류: {e}\")\n\n    detail = \"; \".join(reasons) if state != \"GOOD\" else \"모든 파일이 적절한 소유자/그룹을 가짐\"\n    print_table_row(item, state, detail)\n\ndef check_fowner_auth():\n    item = \"[U-07] /etc/passwd 파일 소유자 및 권한 설정\"\n    state = \"GOOD\"\n    reasons = []\n    filepath = \"/etc/passwd\"\n\n    try:            \n        owner = subprocess.run([\"stat\", \"-c\", \"%U\", filepath], stdout=subprocess.PIPE, stderr=subprocess.DEVNULL, universal_newlines=True).stdout.strip()\n        group = subprocess.run([\"stat\", \"-c\", \"%G\", filepath], stdout=subprocess.PIPE, stderr=subprocess.DEVNULL, universal_newlines=True).stdout.strip()\n        perm = subprocess.run([\"stat\", \"-c\", \"%a\", filepath], stdout=subprocess.PIPE, stderr=subprocess.DEVNULL, universal_newlines=True).stdout.strip()\n\n        if owner != \"root\":\n            state = \"BAD\"\n            reasons.append(f\"owner: {owner}\")\n        if group != \"root\":\n            state = \"BAD\"\n            reasons.append(f\"group: {group}\")\n        if perm != \"644\":\n            state = \"BAD\"\n            reasons.append(f\"permission: {perm}\")\n    except Exception as e:\n        state = \"N/A\"\n        reasons.append(f\"점검 중 오류: {e}\")\n\n    detail = \"; \".join(reasons) if state != \"GOOD\" else \"모든 설정이 기준에 부합함\"\n    print_table_row(item, state, detail)\n\ndef check_shaowner_auth():\n    item = \"[U-08] /etc/shadow 파일 소유자 및 권한 설정\"\n    state = \"GOOD\"\n    reasons = []\n    filepath = \"/etc/shadow\"\n\n    try:\n        owner = subprocess.run([\"stat\", \"-c\", \"%U\", filepath], stdout=subprocess.PIPE, stderr=subprocess.DEVNULL, universal_newlines=True).stdout.strip()\n        group = subprocess.run([\"stat\", \"-c\", \"%G\", filepath], stdout=subprocess.PIPE, stderr=subprocess.DEVNULL, universal_newlines=True).stdout.strip()\n        perm = subprocess.run([\"stat\", \"-c\", \"%a\", filepath], stdout=subprocess.PIPE, stderr=subprocess.DEVNULL, universal_newlines=True).stdout.strip()\n\n        if owner != \"root\":\n            state = \"BAD\"\n            reasons.append(f\"owner: {owner}\")\n        if group != \"root\":\n            state = \"BAD\"\n            reasons.append(f\"group: {group}\")\n        if perm != \"400\":\n            state = \"BAD\"\n            reasons.append(f\"permission: {perm}\")\n    except Exception as e:\n        state = \"N/A\"\n        reasons.append(f\"점검 중 오류: {e}\")\n\n    detail = \"; \".join(reasons) if state != \"GOOD\" else \"모든 설정이 기준에 부합함\"\n    print_table_row(item, state, detail)\n\ndef check_hostsowner_auth():\n    item = \"[U-09] /etc/hosts 파일 소유자 및 권한 설정\"\n    state = \"GOOD\"\n    reasons = []\n    filepath = \"/etc/hosts\"\n\n    try:            \n        owner = subprocess.run([\"stat\", \"-c\", \"%U\", filepath], stdout=subprocess.PIPE, stderr=subprocess.DEVNULL, universal_newlines=True).stdout.strip()\n        group = subprocess.run([\"stat\", \"-c\", \"%G\", filepath], stdout=subprocess.PIPE, stderr=subprocess.DEVNULL, universal_newlines=True).stdout.strip()\n        perm = subprocess.run([\"stat\", \"-c\", \"%a\", filepath], stdout=subprocess.PIPE, stderr=subprocess.DEVNULL, universal_newlines=True).stdout.strip()\n\n        if owner != \"root\":\n            state = \"BAD\"\n            reasons.append(f\"owner: {owner}\")\n        if group != \"root\":\n            state = \"BAD\"\n            reasons.append(f\"group: {group}\")\n        if perm != \"644\":\n            state = \"BAD\"\n            reasons.append(f\"permission: {perm}\")\n    except Exception as e:\n        state = \"N/A\"\n        reasons.append(f\"점검 중 오류: {e}\")\n\n    detail = \"; \".join(reasons) if state != \"GOOD\" else \"모든 설정이 기준에 부합함\"\n    print_table_row(item, state, detail)\n\ndef inetd_owner_auth():\n    item = \"[U-10] /etc/(x)inetd.conf 파일 소유자 및 권한 설정\"\n    state = \"GOOD\"\n    reasons = []\n    filepath = \"/etc/inetd.conf\"\n    result = subprocess.run(\n        [\"ls\", filepath],\n        stdout=subprocess.PIPE,\n        stderr=subprocess.PIPE,\n        universal_newlines=True\n    )\n\n    if result.returncode == 0:\n        try:\n            owner = subprocess.run(\n                [\"stat\", \"-c\", \"%U\", filepath],\n                stdout=subprocess.PIPE,\n                stderr=subprocess.DEVNULL,\n                universal_newlines=True\n            ).stdout.strip()\n            perm = subprocess.run(\n                [\"stat\", \"-c\", \"%a\", filepath],\n                stdout=subprocess.PIPE,\n                stderr=subprocess.DEVNULL,\n                universal_newlines=True\n            ).stdout.strip()\n\n            if owner != \"root\":\n                state = \"BAD\"\n                reasons.append(f\"owner: {owner}\")\n            if not (perm.startswith('6') or perm.startswith('4')):\n                state = \"BAD\"\n                reasons.append(f\"permission: {perm}\")\n        except Exception as e:\n            state = \"N/A\"\n            reasons.append(f\"점검 중 오류: {e}\")\n    else:\n        state = \"N/A\"\n        reasons.append(f\"{filepath} 미설치\")\n\n    detail = \"; \".join(reasons) if state != \"GOOD\" else \"모든 설정이 기준에 부합함\"\n    print_table_row(item, state, detail)\n\ndef check_owner_perm(paths):\n    item = \"[U-11] /etc/syslog.conf 파일 소유자 및 권한 설정\"\n    state = \"GOOD\"\n    reasons = []\n    for path in paths:\n        result = subprocess.run([\"ls\", path], stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True)\n        if result.returncode != 0:\n            state = \"BAD\"\n            reasons.append(f\"{path} 없음\")\n            continue\n        try:\n            owner = subprocess.run([\"stat\", \"-c\", \"%U\", path], stdout=subprocess.PIPE, stderr=subprocess.DEVNULL, universal_newlines=True).stdout.strip()\n            perm = subprocess.run([\"stat\", \"-c\", \"%a\", path], stdout=subprocess.PIPE, stderr=subprocess.DEVNULL, universal_newlines=True).stdout.strip()\n            if owner != \"root\":\n                state = \"BAD\"\n                reasons.append(f\"{path} owner: {owner}\")\n            if perm != \"644\":\n                state = \"BAD\"\n                reasons.append(f\"{path} permission: {perm}\")\n        except Exception as e:\n            state = \"N/A\"\n            reasons.append(f\"{path} 점검 오류: {e}\")\n    detail = \"; \".join(reasons) if state != \"GOOD\" else \"모든 설정이 기준에 부합함\"\n    print_table_row(item, state, detail)\n\ndef check_servicesowner_auth():\n    item = \"[U-12] /etc/services 파일 소유자 및 권한 설정\"\n    state = \"GOOD\"\n    reasons = []\n    filepath = \"/etc/services\"\n    try:\n        owner = subprocess.run([\"stat\", \"-c\", \"%U\", filepath], stdout=subprocess.PIPE, stderr=subprocess.DEVNULL, universal_newlines=True).stdout.strip()\n        group = subprocess.run([\"stat\", \"-c\", \"%G\", filepath], stdout=subprocess.PIPE, stderr=subprocess.DEVNULL, universal_newlines=True).stdout.strip()\n        perm = subprocess.run([\"stat\", \"-c\", \"%a\", filepath], stdout=subprocess.PIPE, stderr=subprocess.DEVNULL, universal_newlines=True).stdout.strip()\n        if owner != \"root\":\n            state = \"BAD\"\n            reasons.append(f\"owner: {owner}\")\n        if group != \"root\":\n            state = \"BAD\"\n            reasons.append(f\"group: {group}\")\n        if perm != \"644\":\n            state = \"BAD\"\n            reasons.append(f\"permission: {perm}\")\n    except Exception as e:\n        state = \"N/A\"\n        reasons.append(f\"점검 오류: {e}\")\n    detail = \"; \".join(reasons) if state != \"GOOD\" else \"모든 설정이 기준에 부합함\"\n    print_table_row(item, state, detail)\n\ndef check_suid_sgid():\n    item = \"[U-13] SUID, SGID, 설정 파일 점검\"\n    state = \"GOOD\"\n    reasons = []\n    try:\n        suid_result = subprocess.run(\n            [\"find\", \"/\", \"-perm\", \"/4000\"],\n            stdout=subprocess.PIPE,\n            stderr=subprocess.DEVNULL,\n            universal_newlines=True\n        )\n        suid_files = suid_result.stdout.strip().splitlines()\n        sgid_result = subprocess.run(\n            [\"find\", \"/\", \"-perm\", \"/2000\"],\n            stdout=subprocess.PIPE,\n            stderr=subprocess.DEVNULL,\n            universal_newlines=True\n        )\n        sgid_files = sgid_result.stdout.strip().splitlines()\n        def is_unusual_path(path):\n            return not (\n                path.startswith(\"/usr\") or\n                path.startswith(\"/snap\") or\n                path.startswith(\"/bin\") or\n                path.startswith(\"/sbin\") or\n                path.startswith(\"/lib\")\n            )\n        flagged_files = [f for f in suid_files + sgid_files if is_unusual_path(f)]\n        if flagged_files:\n            state = \"BAD\"\n            reasons.append(f\"비정상 경로 SUID/SGID 파일 {len(flagged_files)}개\")\n    except Exception as e:\n        state = \"N/A\"\n        reasons.append(f\"점검 오류: {e}\")\n    detail = \"; \".join(reasons) if state != \"GOOD\" else \"모든 SUID/SGID 파일이 정상 경로에 존재\"\n    print_table_row(item, state, detail)\n\ndef check_startsetting_auth():\n    item = \"[U-14] 사용자, 시스템 시작파일 및 환경파일 소유자 및 권한설정\"\n    state = \"GOOD\"\n    reasons = []\n    files_to_check = [\".bashrc\", \".bash_logout\", \".profile\"]\n    try:\n        result = subprocess.run([\"ls\", \"/home\"], stdout=subprocess.PIPE, stderr=subprocess.DEVNULL, universal_newlines=True)\n        users = result.stdout.strip().splitlines()\n        for user in users:\n            home_dir = f\"/home/{user}\"\n            for filename in files_to_check:\n                filepath = f\"{home_dir}/{filename}\"\n                if subprocess.run([\"test\", \"-e\", filepath]).returncode != 0:\n                    continue\n                owner = subprocess.run([\"stat\", \"-c\", \"%U\", filepath], stdout=subprocess.PIPE, stderr=subprocess.DEVNULL, universal_newlines=True).stdout.strip()\n                perm = subprocess.run([\"stat\", \"-c\", \"%a\", filepath], stdout=subprocess.PIPE, stderr=subprocess.DEVNULL, universal_newlines=True).stdout.strip()\n                if owner not in [user, \"root\"]:\n                    state = \"BAD\"\n                    reasons.append(f\"{filepath} owner: {owner}\")\n                if not perm.startswith(\"6\") or perm[1] != \"4\" or perm[2] != \"4\":\n                    state = \"BAD\"\n                    reasons.append(f\"{filepath} perm: {perm}\")\n    except Exception as e:\n        state = \"N/A\"\n        reasons.append(f\"점검 오류: {e}\")\n    detail = \"; \".join(reasons) if state != \"GOOD\" else \"모든 시작 파일이 적절한 소유자와 권한을 가짐\"\n    print_table_row(item, state, detail)\n\ndef check_world_writable():\n    item = \"[U-15] world writable 파일 점검\"\n    state = \"GOOD\"\n    reasons = []\n    try:\n        result = subprocess.run(\n            [\"find\", \"/\", \"-type\", \"f\", \"-perm\", \"-0002\", \"!\", \"-path\", \"/proc/*\", \"!\", \"-path\", \"/sys/*\"],\n            stdout=subprocess.PIPE,\n            stderr=subprocess.DEVNULL,\n            universal_newlines=True\n        )\n        files = result.stdout.strip().splitlines()\n        def is_unusual_path(path):\n            return not (\n                path.startswith(\"/proc\") or\n                path.startswith(\"/sys\") or\n                path.startswith(\"/usr\") or\n                path.startswith(\"/snap\") or\n                path.startswith(\"/bin\") or\n                path.startswith(\"/lib\") or\n                path.startswith(\"/sbin\")\n            )\n        flagged_files = [f for f in files if is_unusual_path(f)]\n        if flagged_files:\n            state = \"BAD\"\n            reasons.append(f\"world-writable 파일 {len(flagged_files)}개\")\n    except Exception as e:\n        state = \"N/A\"\n        reasons.append(f\"점검 오류: {e}\")\n    detail = \"; \".join(reasons) if state != \"GOOD\" else \"비정상 World Writable 파일 없음\"\n    print_table_row(item, state, detail)\n\ndef check_device_dev():\n    item = \"[U-16] /dev에 존재하지 않는 device 파일 점검\"\n    state = \"GOOD\"\n    reasons = []\n    try:\n        result = subprocess.run(\n            [\"find\", \"/dev\", \"-type\", \"f\"],\n            stdout=subprocess.PIPE,\n            stderr=subprocess.DEVNULL,\n            universal_newlines=True\n        )\n        files = result.stdout.strip().splitlines()\n        bad_files = []\n        for file in files:\n            ls_result = subprocess.run(\n                [\"ls\", \"-l\", file],\n                stdout=subprocess.PIPE,\n                stderr=subprocess.DEVNULL,\n                universal_newlines=True\n            )\n            output = ls_result.stdout.strip()\n            if output and not (output.startswith('c') or output.startswith('b')):\n                bad_files.append(file)\n        if bad_files:\n            state = \"BAD\"\n            reasons.append(f\"/dev 내 일반파일 {len(bad_files)}개\")\n    except Exception as e:\n        state = \"N/A\"\n        reasons.append(f\"점검 오류: {e}\")\n    detail = \"; \".join(reasons) if state != \"GOOD\" else \"모든 파일이 device 파일 또는 심볼릭 링크입니다.\"\n    print_table_row(item, state, detail)\n\ndef check_hosts_notuse():\n    item = \"[U-17] $HOME/.rhosts, hosts.equiv 사용 금지\"\n    state = \"GOOD\"\n    reasons = []\n    files_to_check = [\"/etc/hosts.equiv\"]\n    try:\n        result = subprocess.run([\"ls\", \"/home\"], stdout=subprocess.PIPE, stderr=subprocess.DEVNULL, universal_newlines=True)\n        users = result.stdout.strip().splitlines()\n        for user in users:\n            files_to_check.append(f\"/home/{user}/.rhosts\")\n        found_any = False\n        for filepath in files_to_check:\n            if subprocess.run([\"test\", \"-e\", filepath]).returncode != 0:\n                continue\n            found_any = True\n            owner = subprocess.run([\"stat\", \"-c\", \"%U\", filepath], stdout=subprocess.PIPE, stderr=subprocess.DEVNULL, universal_newlines=True).stdout.strip()\n            perm = subprocess.run([\"stat\", \"-c\", \"%a\", filepath], stdout=subprocess.PIPE, stderr=subprocess.DEVNULL, universal_newlines=True).stdout.strip()\n            if owner != \"root\":\n                state = \"BAD\"\n                reasons.append(f\"{filepath} owner: {owner}\")\n            if not perm.startswith(\"6\") or perm[1] != \"4\" or perm[2] != \"4\":\n                state = \"BAD\"\n                reasons.append(f\"{filepath} perm: {perm}\")\n            with open(filepath, \"r\", encoding=\"utf-8\", errors=\"ignore\") as f:\n                for line in f:\n                    if \"+\" in line.strip():\n                        state = \"BAD\"\n                        reasons.append(f\"{filepath}에 '+' 포함\")\n                        break\n        if not found_any:\n            state = \"N/A\"\n            reasons.append(\"점검 대상 파일 없음\")\n    except Exception as e:\n        state = \"N/A\"\n        reasons.append(f\"점검 오류: {e}\")\n    detail = \"; \".join(reasons) if state != \"GOOD\" else \"관련 파일이 존재하지 않음\"\n    print_table_row(item, state, detail)\n\n# ------------------------- TCP Wrapper Check -------------------------\ndef parse_tcpwrapper_file(filepath):\n    \"\"\"Return list of non-comment, non-empty lines.\"\"\"\n    rules = []\n    if os.path.isfile(filepath):\n        with open(filepath, 'r') as f:\n            for line in f:\n                line = line.strip()\n                if line and not line.startswith('#'):\n                    rules.append(line)\n    return rules\n\ndef has_strict_allow_rule(rules):\n    for rule in rules:\n        parts = rule.split(':', 1)\n        if len(parts) != 2:\n            continue\n        service, client = parts\n        client = client.strip()\n        if client and client not in ('ALL', 'localhost', '127.0.0.1'):\n            if re.search(r'(\\d+\\.\\d+\\.\\d+\\.\\d+|\\d+\\.\\d+\\.\\d+\\.|[a-zA-Z0-9_\\-\\.]+)', client):\n                return True\n    return False\n\ndef has_deny_all_rule(rules):\n    for rule in rules:\n        if rule.replace(' ', '') == 'ALL:ALL':\n            return True\n    return False\n\ndef check_tcp_wrappers():\n    allow_path = \"/etc/hosts.allow\"\n    deny_path = \"/etc/hosts.deny\"\n    allow_rules = parse_tcpwrapper_file(allow_path)\n    deny_rules = parse_tcpwrapper_file(deny_path)\n    return has_strict_allow_rule(allow_rules) and has_deny_all_rule(deny_rules)\n\n# ------------------------- iptables Check -------------------------\ndef check_iptables_rules():\n    try:\n        result = subprocess.run(\n            ['sudo', 'iptables', '-L', '--line-numbers'],\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n            universal_newlines=True\n        )\n        if result.returncode != 0:\n            return False\n        \n        output = result.stdout\n        for line in output.split('\\n'):\n            parts = line.split()\n            if len(parts) < 7:\n                continue\n            source = parts[4]\n            options = parts[6:]\n            # IP 제한 확인 (0.0.0.0/0이 아닌 경우)\n            if source not in ('0.0.0.0/0', '::/0'):\n                return True\n            # 포트 제한 확인 (dpt:포트번호 포함)\n            if any(re.search(r'dpt:\\d+', opt) for opt in options):\n                return True\n        return False\n    except:\n        return False\n\ndef run_ip_port_restriction_check():\n    item = \"[U-18] 접속 IP 및 포트 제한\"\n    state = \"GOOD\"\n    reasons = []\n\n    # TCP Wrapper 점검\n    tcp_secure = check_tcp_wrappers()\n    if not tcp_secure:\n        state = \"BAD\"\n        reasons.append(\"TCP Wrapper 설정 미흡\")\n\n    # iptables 점검\n    iptables_secure = check_iptables_rules()\n    if not iptables_secure:\n        state = \"BAD\"\n        reasons.append(\"iptables 설정 미흡\")\n\n    # 상세 사유 정리\n    detail = \"; \".join(reasons) if reasons else \"모든 접근 제어 설정이 적절히 구성되어 있음\"\n\n    print_table_row(item, state, detail)\n\ndef check_finger_service():\n    item = \"[U-19] Finger 서비스 비활성화\"\n    state = \"GOOD\"\n    reasons = []\n    inetd_conf_path = \"/etc/inetd.conf\"\n    inetd_d_path = \"/etc/inetd.d\"\n\n    # 1. /etc/inetd.conf 검사\n    if os.path.isfile(inetd_conf_path):\n        try:\n            with open(inetd_conf_path, 'r', encoding='utf-8', errors='ignore') as f:\n                for line in f:\n                    line_clean = line.strip()\n                    if line_clean and not line_clean.startswith('#') and 'finger' in line_clean.lower():\n                        reasons.append(\"inetd.conf에 finger 서비스 활성화됨\")\n                        state = \"BAD\"\n        except Exception as e:\n            reasons.append(f\"inetd.conf 읽기 오류: {str(e)}\")\n            state = \"ERROR\"\n\n    # 2. /etc/inetd.d/* 검사\n    if os.path.isdir(inetd_d_path):\n        try:\n            for filename in os.listdir(inetd_d_path):\n                file_path = os.path.join(inetd_d_path, filename)\n                if os.path.isfile(file_path):\n                    try:\n                        with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:\n                            for line in f:\n                                line_clean = line.strip()\n                                if line_clean and not line_clean.startswith('#') and 'finger' in line_clean.lower():\n                                    reasons.append(f\"{filename} 파일에 finger 서비스 활성화됨\")\n                                    state = \"BAD\"\n                    except:\n                        reasons.append(f\"{filename} 파일 읽기 실패\")\n                        state = \"ERROR\"\n        except Exception as e:\n            reasons.append(f\"inetd.d 디렉토리 접근 오류: {str(e)}\")\n            state = \"ERROR\"\n\n    # 결과 출력\n    detail = \"; \".join(reasons) if reasons else \"모든 설정이 기준에 부합함\"\n    print_table_row(item, state, detail)\n    return state == \"GOOD\"\n\n\ndef check_ftp_anonymous():\n    item = \"[U-20] Anonymous FTP 비활성화\"\n    state = \"GOOD\"\n    reasons = []\n\n    # 1. FTP 관련 패키지 설치 여부\n    ftp_packages = subprocess.run(\n        [\"dpkg\", \"-l\"], stdout=subprocess.PIPE, universal_newlines=True\n    ).stdout\n    installed = any(pkg in ftp_packages for pkg in [\"ftp\", \"vsftpd\", \"proftpd\"])\n    if installed:\n        reasons.append(\"FTP 관련 패키지 설치됨\")\n\n    # 2. FTP 서비스 실행 여부\n    vsftpd_active = subprocess.run(\n        [\"systemctl\", \"is-active\", \"vsftpd\"], stdout=subprocess.PIPE, universal_newlines=True\n    ).stdout.strip() == \"active\"\n    proftpd_active = subprocess.run(\n        [\"systemctl\", \"is-active\", \"proftpd\"], stdout=subprocess.PIPE, universal_newlines=True\n    ).stdout.strip() == \"active\"\n    if vsftpd_active or proftpd_active:\n        reasons.append(\"FTP 서비스 실행 중\")\n\n    # 3. 설정 파일에서 anonymous 허용 여부\n    vsftpd_secure = False\n    if os.path.isfile(\"/etc/vsftpd.conf\"):\n        with open(\"/etc/vsftpd.conf\") as f:\n            vsftpd_secure = \"anonymous_enable=NO\" in f.read()\n        if not vsftpd_secure:\n            reasons.append(\"vsftpd.conf에서 anonymous_enable=NO 아님\")\n\n    proftpd_secure = False\n    if os.path.isfile(\"/etc/proftpd/proftpd.conf\"):\n        with open(\"/etc/proftpd/proftpd.conf\") as f:\n            proftpd_secure = \"<Anonymous ~ftp>\" not in f.read()\n        if not proftpd_secure:\n            reasons.append(\"proftpd.conf에 <Anonymous ~ftp> 블록 존재\")\n\n    # 4. ftpusers 파일에 'ftp' 또는 'anonymous' 계정 차단 여부\n    ftpusers_entries = []\n    ftpusers_path = \"/etc/ftpd/ftpusers\"\n    if os.path.isfile(ftpusers_path):\n        with open(ftpusers_path) as f:\n            ftpusers_entries = [line.strip() for line in f if \"ftp\" in line or \"anonymous\" in line]\n        if not ftpusers_entries:\n            reasons.append(\"ftpusers 파일에 ftp/anonymous 계정 미차단\")\n\n    # 최종 판정\n    if not installed and not vsftpd_active and not proftpd_active:\n        state = \"GOOD\"\n        detail = \"FTP 서비스 미설치\"\n    elif (vsftpd_secure or proftpd_secure) and ftpusers_entries:\n        state = \"GOOD\"\n        detail = \"Anonymous FTP 접근 비활성화\"\n    else:\n        state = \"BAD\"\n        detail = \"; \".join(reasons) if reasons else \"Anonymous FTP 접근 허용됨\"\n\n    print_table_row(item, state, detail)\n    return state == \"GOOD\"\n\n\ndef run_r_commands_check():\n    item = \"[U-21] r 계열 서비스 비활성화\"\n    state = \"GOOD\"\n    reasons = []\n    \n    inetd_conf = \"/etc/inetd.conf\"\n    target_keywords = [\"shell\", \"login\", \"exec\"]\n    vulnerable_lines = []\n\n    # 1. inetd.conf 파일 존재 여부 확인\n    if not os.path.exists(inetd_conf):\n        print_table_row(item, \"N/A\", \"inetd.conf 파일 없음\")\n        return\n\n    # 2. 활성화된 서비스 검사\n    with open(inetd_conf, \"r\") as f:\n        for line in f:\n            stripped = line.strip()\n            if stripped.startswith(\"#\"):\n                continue\n            for keyword in target_keywords:\n                if keyword in stripped:\n                    vulnerable_lines.append(stripped)\n                    reasons.append(f\"{keyword} 서비스 활성화됨\")\n\n    # 3. 결과 판정\n    if vulnerable_lines:\n        state = \"BAD\"\n        detail = \"; \".join(reasons)\n        print_table_row(item, state, detail)\n    else:\n        detail = \"활성화된 r-command 서비스 없음\"\n        print_table_row(item, state, detail)\n\n\ndef check_permission(filepath, max_mode):\n    \"\"\"파일 권한 검사 (상세 사유 반환)\"\"\"\n    try:\n        st = os.stat(filepath)\n        mode = stat.S_IMODE(st.st_mode)\n        if mode > max_mode:\n            return False, f\"{filepath} 권한 부적절 ({oct(mode)[-3:]})\"\n        return True, \"\"\n    except FileNotFoundError:\n        return True, \"\"  # 파일 없으면 문제 없음\n    except Exception as e:\n        return False, f\"{filepath} 접근 오류: {str(e)}\"\n\ndef check_crontab_binary():\n    \"\"\"crontab 바이너리 검사\"\"\"\n    path = \"/usr/bin/crontab\"\n    state = \"GOOD\"\n    reasons = []\n\n    if not os.path.exists(path):\n        return state, [\"crontab 바이너리 없음\"]\n    \n    try:\n        st = os.stat(path)\n        mode = stat.S_IMODE(st.st_mode)\n        \n        # others 실행 권한 확인\n        if mode & 0o001:\n            state = \"BAD\"\n            reasons.append(f\"others 실행 권한 있음 ({oct(mode)[-3:]})\")\n        \n        # 권한 값 검사 (750 이하 허용)\n        if mode > 0o750:\n            state = \"BAD\"\n            reasons.append(f\"과도한 권한 ({oct(mode)[-3:]})\")\n    \n    except Exception as e:\n        state = \"ERROR\"\n        reasons.append(f\"파일 검사 오류: {str(e)}\")\n    \n    return state, reasons\n\ndef check_cron_dirs():\n    \"\"\"cron 디렉토리 파일 검사\"\"\"\n    paths = [\"/etc/cron.hourly\", \"/etc/cron.daily\", \n            \"/etc/cron.weekly\", \"/etc/cron.monthly\", \"/etc/cron.d\"]\n    state = \"GOOD\"\n    reasons = []\n    \n    for dir_path in paths:\n        if not os.path.exists(dir_path):\n            continue\n            \n        for f in os.listdir(dir_path):\n            full_path = os.path.join(dir_path, f)\n            if os.path.isfile(full_path):\n                is_secure, reason = check_permission(full_path, 0o640)\n                if not is_secure:\n                    state = \"BAD\"\n                    reasons.append(reason)\n                    \n    return state, reasons\n\ndef run_cron_permission_check():\n    item = \"[U-22] crond 파일 소유자 및 권한 설정\"\n    state = \"GOOD\"\n    all_reasons = []\n    \n    # 1. crontab 바이너리 검사\n    crontab_state, crontab_reasons = check_crontab_binary()\n    all_reasons.extend(crontab_reasons)\n    \n    # 2. cron 디렉토리 파일 검사\n    cron_dirs_state, cron_dirs_reasons = check_cron_dirs()\n    all_reasons.extend(cron_dirs_reasons)\n    \n    # 최종 상태 결정\n    if crontab_state == \"BAD\" or cron_dirs_state == \"BAD\":\n        state = \"BAD\"\n    elif crontab_state == \"ERROR\" or cron_dirs_state == \"ERROR\":\n        state = \"ERROR\"\n    \n    # 결과 출력\n    detail = \"; \".join(all_reasons) if all_reasons else \"모든 권한 적절\"\n    print_table_row(item, state, detail)\n\n\ndef check_dos_services():\n    item = \"[U-23] DoS 공격에 취약한 서비스 비활성화\"\n    state = \"GOOD\"\n    reasons = []\n    \n    conf_path = \"/etc/inetd.conf\"\n    keywords = [\"discard\", \"daytime\", \"snmp\", \"smtp\", \"chargen\", \"ntp\", \"echo\"]\n\n    # 1. 설정 파일 존재 여부 확인\n    if not os.path.exists(conf_path):\n        print_table_row(item, \"N/A\", \"inetd.conf 파일 없음\")\n        return\n\n    # 2. 취약 서비스 검사\n    with open(conf_path, 'r') as f:\n        for line_num, line in enumerate(f, 1):\n            line_clean = line.strip()\n            if line_clean.startswith(\"#\") or not line_clean:\n                continue\n            \n            for keyword in keywords:\n                if keyword in line_clean:\n                    reasons.append(f\"{line_num}번 줄: {keyword} 서비스 활성화\")\n\n    # 3. 결과 판정\n    if reasons:\n        state = \"BAD\"\n        detail = \"; \".join(reasons)\n    else:\n        detail = \"취약 서비스 미활성화 상태\"\n    \n    print_table_row(item, state, detail)\n\n\ndef check_nfs_services():\n    item = \"[U-24] NFS 서비스 비활성화\"\n    state = \"GOOD\"\n    active_services = []\n    \n    services = [\"nfs-server\", \"nfs-lock\", \"nfs-idmapd\", \"rpcbind\"]\n\n    # 서비스 활성화 상태 확인\n    for svc in services:\n        try:\n            result = subprocess.check_output(\n                f\"systemctl is-active {svc}\",\n                shell=True,\n                stderr=subprocess.DEVNULL,\n                universal_newlines=True\n            )\n            if result.strip() == \"active\":\n                active_services.append(svc)\n        except subprocess.CalledProcessError:\n            continue\n\n    # 결과 판정\n    if active_services:\n        state = \"BAD\"\n        detail = \"활성화된 서비스: \" + \", \".join(active_services)\n    else:\n        detail = \"모든 NFS 서비스가 비활성화됨\"\n    \n    print_table_row(item, state, detail)\n\n\ndef check_nfs_access():\n    item = \"[U-25] NFS 접근 통제\"\n    state = \"GOOD\"\n    reasons = []\n    \n    exports_file = \"/etc/exports\"\n    \n    # 1. NFS 설정 파일 존재 여부 확인\n    if not os.path.exists(exports_file):\n        print_table_row(item, \"N/A\", \"NFS 설정 파일 없음\")\n        return\n\n    # 2. 활성 공유 설정 확인\n    with open(exports_file, \"r\") as file:\n        lines = [line.strip() for line in file if line.strip() and not line.startswith(\"#\")]\n\n    if not lines:\n        print_table_row(item, \"GOOD\", \"\")\n        return\n\n    # 3. 보안 설정 검사\n    for line in lines:\n        parts = line.split()\n        if len(parts) < 2:\n            continue\n            \n        # 접근 제어 옵션 분석\n        for option in parts[1:]:\n            if '*' in option:\n                reasons.append(f\"와일드카드 사용: {line}\")\n            elif 'no_root_squash' in option:\n                reasons.append(f\"위험 옵션 사용: {line}\")\n            elif not any(char in option for char in ('.', ':', 'network/')):\n                reasons.append(f\"IP 제한 미적용: {line}\")\n\n    # 4. 결과 판정\n    if reasons:\n        state = \"BAD\"\n        detail = \"; \".join(reasons)\n    else:\n        detail = \"모든 공유가 IP 제한 및 안전 옵션 적용됨\"\n    \n    print_table_row(item, state, detail)\n\n\ndef run_command(cmd):\n    try:\n        result = subprocess.run(\n            cmd, shell=True, check=False,\n            stdout=subprocess.PIPE, stderr=subprocess.STDOUT, universal_newlines=True\n        )\n        return result.stdout\n    except Exception as e:\n        return str(e)\n\ndef check_automountd():\n    item = \"[U-26] automountd 제거\"\n    state = \"GOOD\"\n    reasons = []\n\n    # 1. 서비스 상태 확인\n    systemctl_output = run_command(\"systemctl status autofs automountd 2>&1\")\n    if \"Active: active (running)\" in systemctl_output:\n        reasons.append(\"automountd/autofs 서비스 실행 중\")\n\n    # 2. 프로세스 확인\n    ps_output = run_command(\"ps -ef | grep -E 'autofs|automountd' | grep -v grep\")\n    if ps_output.strip():\n        reasons.append(\"automountd/autofs 프로세스 실행 중\")\n\n    # 3. 결과 판정\n    if reasons:\n        state = \"BAD\"\n        detail = \"; \".join(reasons)\n    else:\n        detail = \"모든 automountd 관련 설정이 비활성화됨\"\n    \n    print_table_row(item, state, detail)\n\n\n\ndef run_command(cmd):\n    try:\n        result = subprocess.run(\n            cmd, shell=True, check=False,\n            stdout=subprocess.PIPE, stderr=subprocess.STDOUT, universal_newlines=True\n        )\n        return result.stdout.strip()\n    except Exception as e:\n        return str(e)\n\ndef check_rpc_services():\n    item = \"[U-27] RPC 서비스 확인\"\n    state = \"GOOD\"\n    reasons = []\n\n    # 1. systemctl로 RPC 관련 서비스 확인\n    rpc_services = run_command(\"systemctl list-units --type=service --no-legend | grep -E 'rpcbind|rpc-statd'\")\n    if rpc_services:\n        reasons.append(\"활성화된 RPC 서비스: \\n\" + rpc_services)\n\n    # 2. rpcinfo로 등록 서비스 확인\n    rpcinfo_output = run_command(\"rpcinfo -p 2>/dev/null\")\n    if rpcinfo_output and \"program vers proto\" not in rpcinfo_output:\n        reasons.append(\"rpcinfo 등록 서비스: \\n\" + rpcinfo_output)\n\n    # 3. 결과 판정\n    if reasons:\n        state = \"BAD\"\n        detail = \"\\n\".join(reasons)\n    else:\n        detail = \"모든 RPC 서비스가 비활성화됨\"\n    \n    print_table_row(item, state, detail)\n\n\ndef run_command(cmd):\n    try:\n        result = subprocess.run(\n            cmd, shell=True, check=False,\n            stdout=subprocess.PIPE, stderr=subprocess.STDOUT, universal_newlines=True\n        )\n        return result.stdout.strip()\n    except Exception as e:\n        return str(e)\n\ndef check_nis_services():\n    item = \"[U-28] NIS, NIS+ 점검\"\n    state = \"GOOD\"\n    detail = \"모든 NIS/NIS+ 서비스가 비활성화됨\"\n    \n    # NIS 관련 프로세스 확인\n    processes = run_command(\"ps -ef | grep -E 'ypserv|ypbind|ypxfrd|rpc.yppasswdd|rpc.ypupdated' | grep -v grep\")\n    \n    if processes:\n        state = \"BAD\"\n        detail = \"실행 중인 NIS 서비스:\\n\" + processes.replace('\\n', '; ')\n    \n    print_table_row(item, state, detail)\n\n\ndef is_service_active(service):\n    result = subprocess.run(\n        [\"systemctl\", \"is-active\", \"--quiet\", service],\n        stdout=subprocess.PIPE,\n        stderr=subprocess.PIPE\n    )\n    return result.returncode == 0\n\ndef check_services():\n    item = \"[U-29] tftp, talk 서비스 비활성화\"\n    state = \"GOOD\"\n    active_services = []\n    \n    target_services = [\"tftp\", \"talk\", \"ntalk\"]\n\n    for service in target_services:\n        if is_service_active(service):\n            active_services.append(service)\n\n    if active_services:\n        state = \"BAD\"\n        detail = \"활성화된 서비스: \" + \", \".join(active_services)\n    else:\n        detail = \"모든 tftp/talk 서비스가 비활성화됨\"\n    \n    print_table_row(item, state, detail)\n\n\ndef check_sendmail_version():\n    item = \"[U-30] Sendmail 버전 점검\"\n    state = \"GOOD\"\n    details = []\n    latest_version = \"8.17.2\"  # 최신 안전 버전 (주기적 업데이트 필요)\n\n    # 1. 서비스 활성화 상태 확인 (멀티 init 시스템 지원)\n    def is_service_active():\n        try:\n            # systemd 체크\n            result = subprocess.run(\n                [\"systemctl\", \"is-active\", \"sendmail\"],\n                stdout=subprocess.PIPE,\n                stderr=subprocess.DEVNULL\n            )\n            if result.returncode == 0:\n                return True\n        except FileNotFoundError:\n            # SysV init 체크\n            result = subprocess.run(\n                [\"service\", \"sendmail\", \"status\"],\n                stdout=subprocess.PIPE,\n                stderr=subprocess.DEVNULL\n            )\n            return result.returncode == 0\n        return False\n\n    # 2. 패키지 관리자 감지\n    def get_package_manager():\n        if os.path.exists('/etc/debian_version'):\n            return 'dpkg'\n        elif os.path.exists('/etc/redhat-release'):\n            return 'rpm'\n        return None\n\n    # 3. 버전 정보 가져오기\n    def get_sendmail_version(pkg_manager):\n        try:\n            if pkg_manager == 'dpkg':\n                result = subprocess.run(\n                    [\"dpkg\", \"-s\", \"sendmail\"],\n                    stdout=subprocess.PIPE,\n                    text=True\n                )\n                match = re.search(r'Version: (\\d+\\.\\d+\\.\\d+)', result.stdout)\n            elif pkg_manager == 'rpm':\n                result = subprocess.run(\n                    [\"rpm\", \"-q\", \"sendmail\"],\n                    stdout=subprocess.PIPE,\n                    text=True\n                )\n                match = re.search(r'sendmail-(\\d+\\.\\d+\\.\\d+)', result.stdout)\n            return match.group(1) if match else None\n        except:\n            return None\n\n    # 4. 네트워크 리스닝 확인\n    def check_network_exposure():\n        try:\n            result = subprocess.run(\n                [\"ss\", \"-ltnp\"],\n                stdout=subprocess.PIPE,\n                text=True\n            )\n            listening = []\n            for line in result.stdout.splitlines():\n                if ':25' in line and 'sendmail' in line:\n                    listening.append(line.strip())\n            return listening\n        except:\n            return []\n\n    # 5. 보안 설정 확인\n    def check_security_config():\n        config_files = [\n            '/etc/mail/sendmail.cf',\n            '/etc/mail/submit.cf'\n        ]\n        security_flags = {\n            'PortOptions=Addr=127.0.0.1': '로컬 호스트만 리스닝',\n            'confPRIVACY_FLAGS=authwarnings': '인증 경고 활성화',\n            'Dj$w.FULLY.QUALIFIED.DOMAIN': '정규화된 도메인 설정'\n        }\n        issues = []\n        for conf_file in config_files:\n            if os.path.exists(conf_file):\n                with open(conf_file, 'r') as f:\n                    content = f.read()\n                    for flag, desc in security_flags.items():\n                        if flag not in content:\n                            issues.append(f\"{conf_file} - {desc} 누락\")\n        return issues\n\n    # 실행 흐름\n    if not is_service_active():\n        details.append(\"Sendmail 서비스 비활성화 상태\")\n    else:\n        details.append(\"Sendmail 서비스 활성화 상태\")\n        state = \"BAD\"\n\n        pkg_manager = get_package_manager()\n        if pkg_manager:\n            current_version = get_sendmail_version(pkg_manager)\n            if current_version:\n                details.append(f\"설치 버전: {current_version}\")\n                # 버전 비교\n                if current_version < latest_version:\n                    details.append(f\"취약 버전: {latest_version} 미만\")\n                else:\n                    details.append(\"최신 버전 사용 중\")\n            else:\n                details.append(\"Sendmail 패키지 미설치\")\n                state = \"WARN\"\n\n        # 네트워크 노출 확인\n        listening = check_network_exposure()\n        if listening:\n            details.append(\"네트워크 리스닝 중:\\n\" + \"\\n\".join(listening))\n            state = \"BAD\"\n\n        # 보안 설정 확인\n        config_issues = check_security_config()\n        if config_issues:\n            details.append(\"보안 설정 문제:\\n\" + \"\\n\".join(config_issues))\n            state = \"BAD\"\n\n    # 결과 출력\n    if state == \"GOOD\":\n        details.insert(0, \"모든 검사 항목 통과\")\n    elif state == \"WARN\":\n        details.insert(0, \"부분 검사 실패\")\n\n    print_table_row(item, state, \"\\n- \".join(details))\n    return state == \"GOOD\"\n\n    print_table_row(item, state, detail)\n\ndef check_mail_relay_restriction():\n    item = \"[U-31] 스팸 메일 릴레이 제한\"\n    state = \"GOOD\"\n    detail = \"\"\n    \n    sendmail_cf = \"/etc/mail/sendmail.cf\"\n\n    # 1. 설정 파일 존재 여부 확인\n    if not os.path.isfile(sendmail_cf):\n        print_table_row(item, \"N/A\", \"Sendmail 설정 파일 없음 (서비스 미사용)\")\n        return\n\n    # 2. 릴레이 제한 설정 검사\n    try:\n        with open(sendmail_cf, 'r', encoding='utf-8', errors='ignore') as f:\n            relay_denied = False\n            for line in f:\n                line_clean = line.strip()\n                if line_clean.startswith('#'):\n                    continue\n                if re.search(r'R\\$\\*', line_clean) and 'relaying denied' in line_clean.lower():\n                    relay_rule_found = line_clean\n                    break\n            \n            if relay_rule_found:\n                detail = \"릴레이 제한 설정 확인: {relay_rule_found}\"\n            else:\n                state = \"BAD\"\n                detail = \"릴레이 제한 미설정 (스팸 메일 릴레이 가능)\"\n                \n    except Exception as e:\n        state = \"ERROR\"\n        detail = f\"파일 읽기 오류: {str(e)}\"\n    \n    print_table_row(item, state, detail)\n\n\ndef check_sendmail_restrictqrun():\n    item = \"[U-32] 일반사용자의 Sendmail 실행 방지\"\n    state = \"GOOD\"\n    detail = \"\"\n    \n    sendmail_cf = \"/etc/mail/sendmail.cf\"\n\n    # 1. 설정 파일 존재 여부 확인\n    if not os.path.isfile(sendmail_cf):\n        print_table_row(item, \"N/A\", \"Sendmail 설정 파일 없음 (서비스 미사용)\")\n        return\n\n    # 2. restrictqrun 옵션 검사\n    try:\n        with open(sendmail_cf, 'r', encoding='utf-8', errors='ignore') as f:\n            privacy_line = None\n            for line in f:\n                original_line = line.strip()  # 원본 라인 유지\n                line_clean = original_line.lower()  # 검색용 소문자 변환\n                \n                # 주석 처리된 라인 스킵\n                if line_clean.startswith('#'):\n                    continue\n                \n                # PrivacyOptions 설정 라인에서 restrictqrun 검색\n                if 'privacyoptions' in line_clean and 'restrictqrun' in line_clean:\n                    privacy_line = original_line  # 원본 설정 라인 저장\n                    break\n\n            if privacy_line:\n                detail = f\"restrictqrun 옵션 설정 확인: {privacy_line}\"\n            else:\n                state = \"BAD\"\n                detail = \"restrictqrun 옵션 미설정 (일반 사용자 Sendmail 실행 가능)\"\n                \n    except Exception as e:\n        state = \"ERROR\"\n        detail = f\"파일 읽기 오류: {str(e)}\"\n    \n    print_table_row(item, state, detail)\n\n\n\ndef check_dns_version_and_status():\n    item = \"[U-33] DNS 보안 버전 패치\"\n    state = \"GOOD\"\n    detail = \"\"\n\n    # 1. DNS 서비스 설치 여부 확인\n    if not shutil.which(\"named\"):\n        print_table_row(item, \"N/A\", \"DNS 서비스(named) 미설치\")\n        return\n\n    # 2. 버전 정보 추출\n    version_result = subprocess.run(\n        [\"named\", \"-v\"],\n        stdout=subprocess.PIPE,\n        stderr=subprocess.STDOUT,\n        universal_newlines=True\n    )\n    version = version_result.stdout.strip() or \"버전 확인 불가\"\n\n    # 3. 서비스 실행 상태 확인\n    service_status = subprocess.run(\n        [\"systemctl\", \"is-active\", \"bind9.service\"],\n        stdout=subprocess.DEVNULL,\n        stderr=subprocess.DEVNULL\n    )\n\n    if service_status.returncode == 0:  # 서비스 활성화 상태\n        state = \"BAD\"\n        detail = f\"DNS 서비스 실행 중 ({version}), 보안 패치 수동 확인 필요\"\n    else:\n        detail = f\"DNS 서비스 비활성화 ({version})\"\n\n    print_table_row(item, state, detail)\n\ndef check_zone_transfer():\n    item = \"[U-34] DNS Zone Transfer 설정\"\n    state = \"GOOD\"\n    detail = \"\"\n    \n    named_conf = \"/etc/bind/named.conf\"\n\n    # 1. 설정 파일 존재 여부 확인\n    if not os.path.isfile(named_conf):\n        print_table_row(item, \"N/A\", \"DNS 설정 파일 없음 (서비스 미사용)\")\n        return\n\n    # 2. Zone Transfer 설정 분석\n    try:\n        with open(named_conf, 'r', encoding='utf-8', errors='ignore') as f:\n            transfers = []\n            open_transfer = []\n            \n            for line in f:\n                line_clean = line.strip()\n                if line_clean.startswith(('#', '//')):\n                    continue\n                \n                # allow-transfer 검출\n                if 'allow-transfer' in line_clean.lower():\n                    transfers.append(line_clean)\n                    # 위험 설정 검사\n                    if re.search(r'\\b(any|0\\.0\\.0\\.0|::/0)\\b', line_clean, re.IGNORECASE):\n                        open_transfer.append(line_clean)\n\n            # 3. 결과 판정\n            if not transfers:\n                detail = \"\"\n            elif open_transfer:\n                state = \"BAD\"\n                detail = \"위험 설정 발견: \" + \"; \".join(open_transfer)\n            else:\n                detail = \"안전한 IP 제한 적용: \" + \"; \".join(transfers)\n                \n    except Exception as e:\n        state = \"ERROR\"\n        detail = f\"파일 읽기 오류: {str(e)}\"\n    \n    print_table_row(item, state, detail)\n\n\ndef check_directory_listing():\n    item = \"[U-35] 웹서비스 디렉토리 리스팅 제거\"\n    state = \"GOOD\"\n    detail = []\n    config_files = [\n        \"/etc/apache2/apache2.conf\",\n        \"/etc/apache2/sites-available/000-default.conf\",\n        \"/etc/apache2/sites-available/default-ssl.conf\"\n    ]\n    pattern = re.compile(r'^Options\\s+.*Indexes', re.IGNORECASE)\n    file_found = False\n\n    for conf_file in config_files:\n        if not os.path.isfile(conf_file):\n            continue\n        file_found = True\n        \n        try:\n            with open(conf_file, 'r') as f:\n                for line_num, line in enumerate(f, 1):\n                    line_clean = line.strip()\n                    if line_clean.startswith('#'):\n                        continue\n                    if pattern.search(line_clean):\n                        detail.append(f\"{conf_file} {line_num}번 줄: {line_clean}\")\n                        state = \"BAD\"\n        except Exception as e:\n            detail.append(f\"{conf_file} 읽기 오류: {str(e)}\")\n            state = \"ERROR\"\n\n    if not file_found:\n        state = \"N/A\"\n        detail.append(\"Apache 설정 파일을 찾을 수 없음\")\n    elif state == \"GOOD\":\n        detail.append(\"모든 설정에서 Indexes 옵션 비활성화됨\")\n\n    print_table_row(item, state, \"; \".join(detail))\n\n\ndef check_apache_user_group():\n    item = \"[U-36] 웹서비스 웹 프로세스 권한 제한\"\n    state = \"GOOD\"\n    detail = \"\"\n    config_file = \"/etc/apache2/apache2.conf\"\n\n    # 1. 설정 파일 존재 여부 확인\n    if not os.path.isfile(config_file):\n        print_table_row(item, \"N/A\", \"Apache 설정 파일 없음\")\n        return\n\n    user = group = None\n    \n    try:\n        with open(config_file, 'r') as f:\n            for line in f:\n                line_clean = line.strip()\n                if line_clean.startswith('#'):\n                    continue\n\n                # User/Group 지시어 추출\n                if re.match(r'^User\\s+', line_clean, re.IGNORECASE):\n                    user = line_clean.split()[1].split('#')[0].strip()\n                elif re.match(r'^Group\\s+', line_clean, re.IGNORECASE):\n                    group = line_clean.split()[1].split('#')[0].strip()\n\n                if user and group:\n                    break\n\n        # 2. 결과 판정\n        if not user or not group:\n            state = \"BAD\"\n            detail = \"User/Group 지시어 누락\"\n        elif user.lower() == \"root\" or group.lower() == \"root\":\n            state = \"BAD\"\n            detail = f\"권한 문제 (User={user}, Group={group})\"\n        else:\n            detail = f\"적절한 권한 설정 확인 (User={user}, Group={group})\"\n\n    except Exception as e:\n        state = \"ERROR\"\n        detail = f\"파일 읽기 오류: {str(e)}\"\n    \n    print_table_row(item, state, detail)\n\n\ndef check_allowoverride():\n    item = \"[U-37] 웹서비스 상위 디렉토리 접근 금지\"\n    state = \"BAD\"\n    detail = []\n    config_files = [\n        \"/etc/apache2/apache2.conf\",\n        \"/etc/apache2/sites-available/000-default.conf\",\n        \"/etc/apache2/sites-available/default-ssl.conf\"\n    ]\n    allowed_values = {\"none\", \"limit\", \"fileinfo\"}\n    pattern = re.compile(r'^AllowOverride\\s+(\\S+)', re.IGNORECASE)\n    file_found = False\n\n    for conf_file in config_files:\n        if not os.path.isfile(conf_file):\n            continue\n        file_found = True\n        \n        try:\n            with open(conf_file, 'r') as f:\n                for line_num, line in enumerate(f, 1):\n                    line_clean = line.strip()\n                    if line_clean.startswith('#'):\n                        continue\n                    match = pattern.search(line_clean)\n                    if match:\n                        value = match.group(1).lower()\n                        if value in allowed_values:\n                            state = \"GOOD\"\n                        else:\n                            detail.append(f\"{conf_file} {line_num}번 줄: 위험 설정({value})\")\n        except Exception as e:\n            detail.append(f\"{conf_file} 읽기 오류: {str(e)}\")\n            state = \"ERROR\"\n\n    if not file_found:\n        state = \"N/A\"\n        detail.append(\"Apache 설정 파일을 찾을 수 없음\")\n    elif state == \"GOOD\" and not any(\"위험 설정\" in d for d in detail):\n        detail.insert(0, f\"안전 설정 확인\")\n    elif state == \"BAD\":\n        detail.insert(0, \"위험한 AllowOverride 설정 발견\")\n\n    print_table_row(item, state, \"; \".join(detail))\n\n\ndef check_unnecessary_apache_files():\n    item = \"[U-38] 웹서비스 불필요한 파일 제거\"\n    state = \"GOOD\"\n    detail = []\n    \n    base_dir = \"/etc/apache2\"\n    unnecessary_items = [\n        \"README\",\n        \"conf-enabled/serve-cgi-bin.conf\",\n        \"conf-available/serve-cgi-bin.conf\",\n        \"sites-available/default.conf\",\n        \"sites-available/example.conf\",\n        \"sites-enabled/000-default.conf~\",\n        \"sites-enabled/default\"\n    ]\n\n    # 1. 아파치 설정 디렉토리 존재 여부 확인\n    if not os.path.isdir(base_dir):\n        print_table_row(item, \"N/A\", \"Apache 설치되지 않음\")\n        return\n\n    # 2. 불필요 파일 검사\n    for item_path in unnecessary_items:\n        full_path = os.path.join(base_dir, item_path)\n        if os.path.exists(full_path):\n            detail.append(full_path)\n    \n    # 3. 결과 판정\n    if detail:\n        state = \"BAD\"\n        print_table_row(item, state, \"; \".join(detail))\n    else:\n        print_table_row(item, state, \"불필요 파일 미검출\")\n\n\ndef check_followsymlinks():\n    item = \"[U-39] 웹서비스 링크 사용금지\"\n    state = \"GOOD\"\n    detail = []\n    config_files = [\n        \"/etc/apache2/apache2.conf\",\n        \"/etc/apache2/sites-available/000-default.conf\",\n        \"/etc/apache2/sites-available/default-ssl.conf\"\n    ]\n    pattern = re.compile(r'^Options\\s+.*FollowSymLinks\\b', re.IGNORECASE)\n    file_found = False\n\n    for conf_file in config_files:\n        if not os.path.isfile(conf_file):\n            continue\n        file_found = True\n        \n        try:\n            with open(conf_file, 'r') as f:\n                for line_num, line in enumerate(f, 1):\n                    line_clean = line.strip()\n                    if line_clean.startswith('#'):\n                        continue\n                    if pattern.search(line_clean):\n                        state = \"BAD\"\n                        detail.append(f\"{conf_file} {line_num}번 줄: FollowSymLinks 사용\")\n        except Exception as e:\n            detail.append(f\"{conf_file} 읽기 오류: {str(e)}\")\n            state = \"ERROR\"\n\n    if not file_found:\n        state = \"N/A\"\n        detail.append(\"Apache 설정 파일을 찾을 수 없음\")\n    elif state == \"GOOD\":\n        detail.append(\"모든 설정에서 FollowSymLinks 미사용\")\n\n    print_table_row(item, state, \"; \".join(detail))\n\n\ndef check_limit_request_body():\n    item = \"[U-40] 웹서비스 파일 업로드 및 다운로드 제한\"\n    state = \"BAD\"\n    detail = []\n    config_files = [\n        \"/etc/apache2/apache2.conf\",\n        \"/etc/apache2/sites-available/000-default.conf\",\n        \"/etc/apache2/sites-available/default-ssl.conf\"\n    ]\n    pattern = re.compile(r'^LimitRequestBody\\s+(\\d+)', re.IGNORECASE)\n    file_exists = False\n\n    for conf_file in config_files:\n        if not os.path.isfile(conf_file):\n            continue\n        file_exists = True\n        \n        try:\n            with open(conf_file, 'r') as f:\n                for line_num, line in enumerate(f, 1):\n                    line_clean = line.strip()\n                    if line_clean.startswith('#'):\n                        continue\n                    match = pattern.search(line_clean)\n                    if match:\n                        state = \"GOOD\"\n                        detail.append(f\"{conf_file} {line_num}번 줄: {match.group(0)}\")\n        except Exception as e:\n            detail.append(f\"{conf_file} 읽기 오류: {str(e)}\")\n            state = \"ERROR\"\n\n    if not file_exists:\n        state = \"N/A\"\n        detail.append(\"Apache 설정 파일 없음\")\n    elif state == \"BAD\" and file_exists:\n        detail.insert(0, \"파일 크기 제한 설정 미적용\")\n\n    print_table_row(item, state, \"; \".join(detail))\n\ndef check_document_root():\n    item = \"[U-41] 웹서비스 영역의 분리\"\n    state = \"GOOD\"\n    detail = \"\"\n    config_file = \"/etc/apache2/sites-available/000-default.conf\"\n    default_paths = [\"/var/www/html\", \"/var/www\"]\n\n    # 1. 설정 파일 존재 여부 확인\n    if not os.path.isfile(config_file):\n        print_table_row(item, \"N/A\", \"Apache 설정 파일 없음\")\n        return\n\n    # 2. DocumentRoot 설정 추출\n    try:\n        with open(config_file, 'r') as f:\n            doc_root = None\n            pattern = re.compile(r'^DocumentRoot\\s+\"?(.+?)\"?(\\s+#.*)?$', re.IGNORECASE)\n            \n            for line in f:\n                line_clean = line.strip()\n                if line_clean.startswith('#'):\n                    continue\n                match = pattern.match(line_clean)\n                if match:\n                    doc_root = match.group(1).strip()\n                    break\n\n            # 3. 결과 판정\n            if not doc_root:\n                state = \"BAD\"\n                detail = \"DocumentRoot 설정 누락\"\n            elif doc_root in default_paths:\n                state = \"BAD\"\n                detail = f\"기본 디렉토리 사용 ({doc_root})\"\n            else:\n                detail = f\"사용자 정의 디렉토리 사용 ({doc_root})\"\n                \n    except Exception as e:\n        state = \"ERROR\"\n        detail = f\"파일 읽기 오류: {str(e)}\"\n    \n    print_table_row(item, state, detail)\n\ndef check_hosts_lpd():\n    item = \"[U-55] hosts.lpd 파일 소유자 및 권한 설정\"\n    state = \"GOOD\"\n    detail = \"\"\n    file_path = \"/etc/hosts.lpd\"\n\n    try:\n        if not os.path.exists(file_path):\n            detail = \"hosts.lpd 파일이 존재하지 않음 (보안 권장 상태)\"\n            print_table_row(item, state, detail)\n            return True\n\n        st = os.stat(file_path)\n        owner_uid = st.st_uid\n        owner_name = pwd.getpwuid(owner_uid).pw_name\n        perm = stat.S_IMODE(st.st_mode)\n\n        if owner_name == \"root\" and perm == 0o600:\n            detail = f\"소유자: {owner_name}, 권한: {oct(perm)[-3:]} (적정)\"\n        else:\n            state = \"BAD\"\n            detail = f\"소유자: {owner_name}(부적절), 권한: {oct(perm)[-3:]}(부적절)\"\n\n    except Exception as e:\n        state = \"ERROR\"\n        detail = f\"파일 검사 오류: {str(e)}\"\n    \n    print_table_row(item, state, detail)\n    return state == \"GOOD\"\n\ndef get_current_umask():\n    \"\"\"현재 umask 값을 안전하게 가져오는 함수\"\"\"\n    current_umask = os.umask(0)\n    os.umask(current_umask)\n    return current_umask\n\ndef check_umask():\n    item = \"[U-56] UMASK 설정 관리\"\n    state = \"GOOD\"\n    bad_reasons = []  # 문제가 있는 설정만 저장\n    good_reasons = []  # 안전한 설정 저장\n    error_flag = False\n\n    # 1. /etc/login.defs 검사\n    login_defs_path = '/etc/login.defs'\n    umask_pattern = re.compile(r'^\\s*UMASK\\s+(\\d+)', re.IGNORECASE)\n    if os.path.exists(login_defs_path):\n        try:\n            with open(login_defs_path, 'r') as f:\n                for line_num, line in enumerate(f, 1):\n                    match = umask_pattern.match(line.strip())\n                    if match:\n                        umask_str = match.group(1)\n                        try:\n                            umask_val = int(umask_str, 8)\n                            if umask_val < 0o22:\n                                bad_reasons.append(f\"{login_defs_path} {line_num}번 줄: UMASK {oct(umask_val)} (위험)\")\n                                state = \"BAD\"\n                            else:\n                                good_reasons.append(f\"{login_defs_path} {line_num}번 줄: UMASK {oct(umask_val)} (안전)\")\n                        except ValueError:\n                            error_flag = True\n                            bad_reasons.append(f\"{login_defs_path} {line_num}번 줄: 잘못된 UMASK 값 ({umask_str})\")\n        except Exception as e:\n            error_flag = True\n            bad_reasons.append(f\"{login_defs_path} 파일 읽기 실패: {str(e)}\")\n\n    # 2. 글로벌 설정 파일 검사\n    global_configs = ['/etc/profile', '/etc/bash.bashrc']\n    for config in global_configs:\n        if os.path.exists(config):\n            try:\n                with open(config, 'r') as f:\n                    for line_num, line in enumerate(f, 1):\n                        if re.match(r'^\\s*umask\\s+\\d+', line):\n                            umask_str = line.split()[-1]\n                            try:\n                                umask_val = int(umask_str, 8)\n                                if umask_val < 0o22:\n                                    bad_reasons.append(f\"{config} {line_num}번 줄: umask {oct(umask_val)} (위험)\")\n                                    state = \"BAD\"\n                                else:\n                                    good_reasons.append(f\"{config} {line_num}번 줄: umask {oct(umask_val)} (안전)\")\n                            except ValueError:\n                                error_flag = True\n                                bad_reasons.append(f\"{config} {line_num}번 줄: 잘못된 umask 값 ({umask_str})\")\n            except Exception as e:\n                error_flag = True\n                bad_reasons.append(f\"{config} 파일 읽기 실패: {str(e)}\")\n\n    # 3. 사용자 셸 설정 검사\n    home_dir = os.path.expanduser('~')\n    user_configs = ['.bashrc', '.profile', '.bash_profile']\n    for config in user_configs:\n        config_path = os.path.join(home_dir, config)\n        if os.path.exists(config_path):\n            try:\n                with open(config_path, 'r') as f:\n                    for line_num, line in enumerate(f, 1):\n                        if re.match(r'^\\s*umask\\s+\\d+', line):\n                            umask_str = line.split()[-1]\n                            try:\n                                umask_val = int(umask_str, 8)\n                                if umask_val < 0o22:\n                                    bad_reasons.append(f\"{config_path} {line_num}번 줄: umask {oct(umask_val)} (위험)\")\n                                    state = \"BAD\"\n                                else:\n                                    good_reasons.append(f\"{config_path} {line_num}번 줄: umask {oct(umask_val)} (안전)\")\n                            except ValueError:\n                                error_flag = True\n                                bad_reasons.append(f\"{config_path} {line_num}번 줄: 잘못된 umask 값 ({umask_str})\")\n            except Exception as e:\n                error_flag = True\n                bad_reasons.append(f\"{config_path} 파일 읽기 실패: {str(e)}\")\n\n    # 4. 현재 umask 값 검사\n    try:\n        current_umask = get_current_umask()\n        if current_umask < 0o22:\n            bad_reasons.append(f\"현재 세션 umask: {oct(current_umask)} (위험)\")\n            state = \"BAD\"\n        else:\n            good_reasons.append(f\"현재 세션 umask: {oct(current_umask)} (안전)\")\n    except Exception as e:\n        error_flag = True\n        bad_reasons.append(f\"현재 umask 확인 실패: {str(e)}\")\n\n    # 결과 판정\n    if error_flag:\n        state = \"ERROR\"\n\n    # 결과 메시지 구성\n    if bad_reasons:\n        detail = \"; \".join(bad_reasons)\n    elif good_reasons:\n        detail = \"모든 UMASK 설정이 022 이상으로 안전함\"\n    else:\n        detail = \"UMASK 설정 없음 (시스템 기본값 사용)\"\n\n    print_table_row(item, state, detail)\n\ndef check_home_permissions():\n    item = \"[U-57] 홈디렉토리 소유자 및 권한 설정\"\n    state = \"GOOD\"\n    reasons = []\n    passwd_path = \"/etc/passwd\"\n    # 시스템 계정 홈디렉토리 경로는 검사에서 제외\n    system_dirs = [\n        '/bin', '/sbin', '/usr', '/usr/bin', '/usr/sbin', '/lib', '/lib64', '/etc',\n        '/dev', '/proc', '/sys', '/root', '/var', '/run'\n    ]\n    \n    try:\n        with open(passwd_path, 'r') as f:\n            for line in f:\n                line = line.strip()\n                if not line or line.startswith('#'):\n                    continue\n                fields = line.split(':')\n                if len(fields) < 7:\n                    continue\n                username = fields[0]\n                uid = int(fields[2])\n                home_dir = fields[5]\n\n                # Skip non-existent home directories\n                if not os.path.isdir(home_dir):\n                    continue\n\n                # Skip system directories and root directory\n                if home_dir == '/' or any(home_dir == sd or home_dir.startswith(sd + '/') for sd in system_dirs):\n                    continue\n\n                try:\n                    stat_info = os.stat(home_dir)\n                    owner_uid = stat_info.st_uid\n                    mode = stat.S_IMODE(stat_info.st_mode)\n                except Exception as e:\n                    reasons.append(f\"{home_dir} 접근 불가: {str(e)}\")\n                    state = \"BAD\"\n                    continue\n\n                # Check 1: 소유자 일치 여부\n                if owner_uid != uid:\n                    owner_name = pwd.getpwuid(owner_uid).pw_name\n                    reasons.append(f\"{home_dir} 소유자 불일치 ({username} != {owner_name})\")\n                    state = \"BAD\"\n                \n                # Check 2: Others 쓰기 권한 확인\n                if mode & 0o0002:\n                    reasons.append(f\"{home_dir} 타인 쓰기 권한 있음 ({oct(mode)})\")\n                    state = \"BAD\"\n\n    except Exception as e:\n        state = \"ERROR\"\n        reasons.append(f\"{passwd_path} 파일 읽기 실패: {str(e)}\")\n    \n    # 결과 출력\n    detail = \"; \".join(reasons) if reasons else \"모든 사용자 홈디렉토리 적합\"\n    print_table_row(item, state, detail)\n\ndef check_home_directories():\n    item = \"[U-58] 홈디렉토리로 지정한 디렉토리의 존재 관리\"\n    state = \"GOOD\"\n    reasons = []\n    passwd_file = \"/etc/passwd\"\n    \n    try:\n        with open(passwd_file, 'r') as f:\n            for line_num, line in enumerate(f, 1):\n                line = line.strip()\n                if not line or line.startswith('#'):\n                    continue\n                fields = line.split(':')\n                if len(fields) < 6:\n                    continue\n                username = fields[0]\n                home_dir = fields[5]\n\n                # 1. 홈 디렉토리 유효성 검사\n                if home_dir == \"/\":\n                    reasons.append(f\"{username} 계정 홈디렉토리: / (루트 디렉토리)\")\n                    state = \"BAD\"\n                elif not os.path.isdir(home_dir):\n                    reasons.append(f\"{username} 계정 홈디렉토리: {home_dir} (존재하지 않음)\")\n                    state = \"BAD\"\n\n    except Exception as e:\n        state = \"ERROR\"\n        reasons.append(f\"{passwd_file} 파일 읽기 실패: {str(e)}\")\n    \n    # 결과 출력\n    detail = \"; \".join(reasons) if reasons else \"모든 계정에 유효한 홈디렉토리 존재\"\n    print_table_row(item, state, detail)\n\ndef find_hidden_files_and_dirs():\n    item = \"[U-59] 숨겨진 파일 및 디렉토리 검색 및 제거\"\n    state = \"GOOD\"\n    details = []\n    excluded_dirs = ['/usr', '/sys', '/snap', '/proc', '/dev', '/run', '/var/lib', '/var/run', '/var/snap']\n    \n    try:\n        for root, dirs, files in os.walk('/', topdown=True):\n            # 제외 디렉터리 필터링\n            dirs[:] = [d for d in dirs if not any(\n                os.path.abspath(os.path.join(root, d)).startswith(ex) \n                for ex in excluded_dirs\n            )]\n            \n            # 숨겨진 디렉터리 검출\n            for d in dirs:\n                if d.startswith('.') and d not in ('.', '..'):\n                    full_path = os.path.join(root, d)\n                    details.append(f\"디렉토리: {full_path}\")\n            \n            # 숨겨진 파일 검출\n            for f in files:\n                if f.startswith('.') and f not in ('.', '..'):\n                    full_path = os.path.join(root, f)\n                    details.append(f\"파일: {full_path}\")\n\n    except Exception as e:\n        state = \"ERROR\"\n        details.append(f\"파일 시스템 검사 오류: {str(e)}\")\n    \n    # 결과 판정\n    if details:\n        state = \"BAD\" if state != \"ERROR\" else state\n        detail_str = \"; \".join(details[:10])  # 최대 10개까지 표시\n        if len(details) > 10:\n            detail_str += f\" ... (총 {len(details)}개 발견)\"\n    else:\n        detail_str = \"숨겨진 파일/디렉토리 미검출 (시스템 경로 제외)\"\n    \n    print_table_row(item, state, detail_str)\n\ndef check_remote_services():\n    item = \"[U-60] ssh 원격접속 허용\"\n    state = \"GOOD\"\n    detail = []\n    problem_services = []\n\n    # SSH 상태 및 버전 확인\n    ssh_status = get_service_status('ssh')\n    ssh_active = ssh_status == 'active'\n    ssh_version = get_ssh_version()\n\n    # FTP 관련 정보 확인\n    ftp_service = 'vsftpd'\n    ftp_status = get_service_status(ftp_service)\n    ftp_active = ftp_status == 'active'\n    ftp_exists = service_exists(ftp_service)\n\n    # Telnet 관련 정보 확인\n    telnet_services = ['telnet.socket', 'telnet']\n    telnet_statuses = [get_service_status(svc) for svc in telnet_services]\n    telnet_active = any(status == 'active' for status in telnet_statuses)\n    telnet_exists = any(service_exists(svc) for svc in telnet_services)\n\n    # 문제 식별\n    if not ssh_active:\n        problem_services.append(f\"SSH 비활성화 (현재 상태: {ssh_status})\")\n    if ftp_active:\n        problem_services.append(f\"FTP 활성화 (서비스: {ftp_service})\")\n    if telnet_active:\n        problem_services.append(f\"Telnet 활성화 (서비스: {telnet_services})\")\n\n    # 상태 판정\n    if problem_services:\n        state = \"BAD\"\n        detail = \"문제 항목:\\n- \" + \"\\n- \".join(problem_services)\n    else:\n        # GOOD 상태 상세 정보 구성\n        status_info = [\n            f\"SSH 서비스:\",\n            f\"  - 상태: 활성화 (버전: {ssh_version})\",\n            f\"  - 설정 파일: /etc/ssh/sshd_config\",\n            \"\",\n            f\"FTP 서비스:\",\n            f\"  - 상태: {'미설치' if not ftp_exists else '비활성화'}\",\n            \"\",\n            f\"Telnet 서비스:\",\n            f\"  - 상태: {'미설치' if not telnet_exists else '비활성화'}\"\n        ]\n        detail = \"\\n\".join(status_info)\n\n    print_table_row(item, state, detail)\n\ndef get_ssh_version():\n    \"\"\"SSH 버전 정보 추출\"\"\"\n    try:\n        result = subprocess.run(\n            ['ssh', '-V'],\n            stdout=subprocess.PIPE,\n            stderr=subprocess.STDOUT,\n            universal_newlines=True\n        )\n        version_output = result.stdout.strip()\n        version_match = re.search(r'OpenSSH_(\\d+\\.\\d+[^, ]*)', version_output)\n        return version_match.group(1) if version_match else \"버전 확인 불가\"\n    except Exception as e:\n        return f\"버전 확인 오류: {str(e)}\"\n\ndef service_exists(service):\n    \"\"\"서비스 존재 여부 심층 확인\"\"\"\n    try:\n        check = subprocess.run(\n            ['systemctl', 'list-unit-files', '-t', 'service', '--full', '--no-legend', f\"{service}.service\"],\n            stdout=subprocess.PIPE,\n            stderr=subprocess.DEVNULL,\n            universal_newlines=True\n        )\n        return bool(check.stdout.strip())\n    except:\n        return False\n\ndef check_ftp_service():\n    item = \"[U-61] ftp 서비스 확인\"\n    state = \"GOOD\"\n    reasons = []\n    ftp_services = [\"vsftpd\", \"proftpd\", \"pure-ftpd\"]\n    installed_services = []\n    inactive_services = []\n\n    try:\n        for service in ftp_services:\n            if not service_exists(service):\n                continue\n            \n            installed_services.append(service)\n            \n            # 활성화 상태 확인\n            active_result = subprocess.run(\n                ['systemctl', 'is-active', service],\n                stdout=subprocess.PIPE,\n                stderr=subprocess.PIPE,\n                universal_newlines=True\n            )\n            active_status = active_result.stdout.strip()\n\n            # 자동시작 상태 확인\n            enabled_result = subprocess.run(\n                ['systemctl', 'is-enabled', service],\n                stdout=subprocess.PIPE,\n                stderr=subprocess.PIPE,\n                universal_newlines=True\n            )\n            enabled_status = enabled_result.stdout.strip()\n\n            # 상태 판정\n            if active_status != 'inactive' or enabled_status not in ['disabled', 'static']:\n                reasons.append(f\"{service} 서비스 문제 (실행: {active_status}, 자동시작: {enabled_status})\")\n                state = \"BAD\"\n            else:\n                inactive_services.append(service)\n\n        # GOOD 상태 시 상세 정보 구성\n        if state == \"GOOD\":\n            if installed_services:\n                detail = \"FTP 서비스 설치됨 (비활성화 상태):\\n- \" + \"\\n- \".join(inactive_services)\n            else:\n                detail = \"FTP 서비스 미설치 (vsftpd/proftpd/pure-ftpd)\"\n        else:\n            detail = \"문제 발견:\\n- \" + \"\\n- \".join(reasons)\n\n    except Exception as e:\n        state = \"ERROR\"\n        detail = f\"서비스 검사 오류: {str(e)}\"\n\n    print_table_row(item, state, detail)\n\n\n\ndef check_ftp_shell():\n    item = \"[U-62] ftp 계정 shell 제한\"\n    state = \"GOOD\"\n    detail = \"\"\n    passwd_file = \"/etc/passwd\"\n    ftp_shell = None\n    allowed_shells = [\"/bin/false\", \"/sbin/nologin\", \"/usr/sbin/nologin\"]\n\n    try:\n        with open(passwd_file, 'r') as f:\n            for line in f:\n                if line.startswith('ftp:'):\n                    fields = line.strip().split(':')\n                    if len(fields) >= 7:\n                        ftp_shell = fields[6]\n                    break\n\n        # 결과 판정\n        if ftp_shell is None:\n            detail = \"ftp 계정 미존재 (권장 상태)\"\n        elif ftp_shell in allowed_shells:\n            detail = f\"\"\"적절한 쉘 설정 확인:\n- 계정명: ftp\n- 사용 쉘: {ftp_shell}\n- 권장 쉘: {\", \".join(allowed_shells)}\"\"\"\n        else:\n            state = \"BAD\"\n            detail = f\"\"\"위험한 쉘 설정 발견:\n- 계정명: ftp\n- 현재 설정: {ftp_shell}\n- 권장 설정: {\", \".join(allowed_shells)}\"\"\"\n\n    except FileNotFoundError:\n        state = \"ERROR\"\n        detail = f\"{passwd_file} 파일 없음\"\n    except Exception as e:\n        state = \"ERROR\"\n        detail = f\"파일 읽기 오류: {str(e)}\"\n\n    print_table_row(item, state, detail)\n\n\ndef check_ftpusers_file():\n    item = \"[U-63] ftpusers 파일 소유자 및 권한 설정\"\n    state = \"GOOD\"\n    detail = \"\"\n    file_path = \"/etc/ftpusers\"\n\n    try:\n        if not os.path.isfile(file_path):\n            state = \"BAD\"\n            detail = \"파일 미존재\"\n            print_table_row(item, state, detail)\n            return\n\n        st = os.stat(file_path)\n        owner_uid = st.st_uid\n        perm = stat.S_IMODE(st.st_mode)\n        owner_name = pwd.getpwuid(owner_uid).pw_name\n\n        # 소유자 확인\n        if owner_name != \"root\":\n            state = \"BAD\"\n            detail += f\"소유자: {owner_name}(부적절); \"\n        \n        # 권한 확인 (640 = 0o640)\n        if perm > 0o640:  # 640보다 큰 권한(예: 755, 777)인 경우\n            state = \"BAD\"\n            detail += f\"권한: {oct(perm)[-3:]}(부적절)\"\n        else:\n            detail += f\"권한: {oct(perm)[-3:]}(적정)\" if detail else f\"소유자: root, 권한: {oct(perm)[-3:]}\"\n\n    except Exception as e:\n        state = \"ERROR\"\n        detail = f\"파일 접근 오류: {str(e)}\"\n\n    print_table_row(item, state, detail)\n\ndef check_ftp_root_access():\n    item = \"[U-64] ftpusers 파일 설정(FTP 서비스 root 계정 접근제한)\"\n    state = \"GOOD\"\n    detail = []\n    ftp_service = \"vsftpd\"\n    ftpusers_path = \"/etc/ftpusers\"\n    service_active = False\n    root_blocked = False\n    config_details = []\n\n    try:\n        # 1. FTP 서비스 실행 상태 확인\n        service_status = subprocess.run(\n            [\"systemctl\", \"is-active\", ftp_service],\n            stdout=subprocess.DEVNULL,\n            stderr=subprocess.DEVNULL\n        )\n        service_active = (service_status.returncode == 0)\n\n        if service_active:\n            # 2. ftpusers 파일 존재 여부 확인\n            if not os.path.isfile(ftpusers_path):\n                state = \"BAD\"\n                detail.append(\"ftpusers 파일 미존재\")\n            else:\n                # 3. root 계정 차단 여부 및 상세 정보 수집\n                with open(ftpusers_path, 'r') as f:\n                    for line_num, line in enumerate(f, 1):\n                        cleaned_line = line.strip().lower()\n                        if cleaned_line == \"root\":\n                            root_blocked = True\n                            config_details.append(f\"{ftpusers_path} {line_num}번 줄: '{line.strip()}'\")\n                            break\n\n                if not root_blocked:\n                    state = \"BAD\"\n                    detail.append(\"root 계정 미차단\")\n                else:\n                    config_details.insert(0, f\"FTP 서비스 활성화 ({ftp_service})\")\n\n        # GOOD 상태 시 상세 정보 구성\n        if state == \"GOOD\":\n            if service_active:\n                detail = [\n                    \"적절한 root 계정 차단 설정:\",\n                    *config_details,\n                    f\"설정 파일 경로: {ftpusers_path}\"\n                ]\n            else:\n                detail = [f\"{ftp_service} 서비스 비활성화 (권장 상태)\"]\n\n    except Exception as e:\n        state = \"ERROR\"\n        detail = [f\"검사 오류: {str(e)}\"]\n\n    # 결과 출력 포맷팅\n    print_table_row(item, state, \"\\n- \".join(detail) if detail else \"\")\n\ndef check_at_permissions():\n    item = \"[U-65] at 서비스 권한 설정\"\n    state = \"GOOD\"\n    details = []\n    target_files = [\n        '/usr/bin/at',\n        '/etc/at.allow',\n        '/etc/at.deny'\n    ]\n    \n    try:\n        # 1. at 명령어 설치 여부 확인\n        at_path = shutil.which('at')\n        if not at_path:\n            print_table_row(item, \"GOOD\", \"at 서비스 미설치 (권장 상태)\")\n            return\n\n        # 2. 파일별 권한 검사\n        for file_path in target_files:\n            if not os.path.exists(file_path):\n                details.append(f\"{file_path} 미존재\")\n                continue\n\n            try:\n                st = os.stat(file_path)\n                owner = pwd.getpwuid(st.st_uid).pw_name\n                perm = stat.S_IMODE(st.st_mode)\n\n                # 소유자 및 권한 검사\n                owner_ok = (owner == 'root')\n                perm_ok = (perm <= 0o640)  # 0o640는 8진수 표기\n\n                if owner_ok and perm_ok:\n                    details.append(f\"{file_path}\\n  - 소유자: {owner}\\n  - 권한: {oct(perm)[-3:]}\")\n                else:\n                    details.append(f\"{file_path}\\n  - 소유자: {owner}(부적절)\\n  - 권한: {oct(perm)[-3:]}(부적절)\")\n                    state = \"BAD\"\n\n            except Exception as e:\n                state = \"ERROR\"\n                details.append(f\"{file_path} 검사 실패: {str(e)}\")\n\n        # 3. 결과 메시지 구성\n        if state == \"GOOD\":\n            detail_msg = \"적절한 권한 설정 확인:\\n- \" + \"\\n- \".join(details)\n        elif state == \"BAD\":\n            detail_msg = \"문제 발견:\\n- \" + \"\\n- \".join(details)\n        else:\n            detail_msg = \"\\n\".join(details)\n\n    except Exception as e:\n        state = \"ERROR\"\n        detail_msg = f\"전체 검사 오류: {str(e)}\"\n\n    print_table_row(item, state, detail_msg)\n\ndef check_snmpd_running():\n    item = \"[U-66] SNMP 서비스 구동 점검\"\n    state = \"GOOD\"\n    reasons = []\n    detail = \"\"\n    try:\n        result = subprocess.run(\n            ['systemctl', 'is-active', '--quiet', 'snmpd']\n        )\n        if result.returncode == 0:\n            state = \"BAD\"\n            reasons.append(\"SNMP 서비스(snmpd)가 실행 중임\")\n        else:\n            state = \"GOOD\"\n            reasons.append(\"SNMP 서비스(snmpd)가 비활성화 상태 (권장)\")\n    except Exception as e:\n        state = \"N/A\"\n        reasons.append(f\"점검 오류: {e}\")\n    detail = \"; \".join(reasons)\n    print_table_row(item, state, detail)\n\n\ndef check_snmp_community_string():\n    item = \"[U-67] SNMP 서비스 Community String의 복잡성 설정\"\n    state = \"GOOD\"\n    reasons = []\n    config_file = \"/etc/snmp/snmpd.conf\"\n    if not os.path.isfile(config_file):\n        state = \"GOOD\"\n        reasons.append(\"SNMP 미설치 또는 설정 파일 없음\")\n    else:\n        matches = []\n        try:\n            with open(config_file, 'r') as f:\n                for line in f:\n                    if line.strip().startswith('#'):\n                        continue\n                    if re.search(r'rocommunity\\s+(public|private)\\b', line, re.IGNORECASE):\n                        matches.append(line.strip())\n        except Exception as e:\n            state = \"N/A\"\n            reasons.append(f\"파일 읽기 오류: {e}\")\n        if matches:\n            state = \"BAD\"\n            reasons.append(f\"취약한 community string 발견: {', '.join(matches)}\")\n    detail = \"; \".join(reasons) if state != \"GOOD\" else \"SNMP 미설치 또는 설정 파일 없음\"\n    print_table_row(item, state, detail)\n\ndef check_logon_warning():\n    item = \"[U-68] 로그온 시 경고 메시지 제공\"\n    state = \"GOOD\"\n    good_reasons = []\n    bad_reasons = []\n    checked_files = 0\n\n    # 검사 대상 파일과 권장 설정 패턴\n    configs = {\n        \"/etc/motd\": re.compile(r\"Unauthorized.access.prohibited\", re.IGNORECASE),\n        \"/etc/issue.net\": re.compile(r\"Authorized.users.only\", re.IGNORECASE),\n        \"/etc/vsftpd.conf\": re.compile(r\"^banner_file\\s*=\\s*/etc/vsftpd\\.banner\", re.MULTILINE),\n        \"/etc/mail/sendmail.cf\": re.compile(r\"^GreetingMessage\\s*=\\s*\\$j.Sendmail\", re.MULTILINE),\n        \"/etc/named.conf\": re.compile(r\"^directory\\s+\\\"/var/named\\\"\", re.MULTILINE)\n    }\n\n    for file_path, pattern in configs.items():\n        if not os.path.isfile(file_path):\n            continue\n        checked_files += 1\n\n        try:\n            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:\n                content = f.read()\n                match = pattern.search(content)\n\n                if match:\n                    # GOOD: 설정 라인 하이라이트\n                    lines = content.split('\\n')\n                    for line_num, line in enumerate(lines, 1):\n                        if pattern.search(line):\n                            good_reasons.append(\n                                f\"{file_path} {line_num}번 줄: \"\n                                f\"'{line.strip()}'\"\n                            )\n                else:\n                    bad_reasons.append(f\"{file_path} 경고 메시지 미설정\")\n                    state = \"BAD\"\n\n        except Exception as e:\n            state = \"ERROR\"\n            bad_reasons.append(f\"{file_path} 읽기 오류: {str(e)}\")\n\n    # 결과 메시지 구성\n    if state == \"GOOD\":\n        if checked_files > 0:\n            detail = \"적절한 경고 메시지 설정 확인:\\n- \" + \"\\n- \".join(good_reasons)\n        else:\n            state = \"N/A\"\n            detail = \"로그온 메시지 설정 파일이 없음 (추가 설정 권장)\"\n    elif state == \"BAD\":\n        detail = \"문제 발견:\\n- \" + \"\\n- \".join(bad_reasons)\n    else:\n        detail = \"\\n\".join(bad_reasons)\n\n    print_table_row(item, state, detail)\n\n\ndef check_nfs_exports():\n    item = \"[U-69] NFS 설정파일 접근권한\"\n    state = \"GOOD\"\n    detail = \"\"\n    config_file = \"/etc/exports\"\n    \n    if not os.path.isfile(config_file):\n        state = \"N/A\"\n        detail = \"NFS 미설정 (설정 파일 없음)\"\n    else:\n        try:\n            file_stat = os.stat(config_file)\n            owner_uid = file_stat.st_uid\n            owner_name = pwd.getpwuid(owner_uid).pw_name\n            permissions = file_stat.st_mode & 0o777  # 파일 권한 정수값 추출\n            \n            # 권한 검사 기준\n            owner_valid = (owner_name == \"root\")\n            perm_valid = (permissions <= 0o644)  # 0o644 = owner RW, group R, others R\n\n            if owner_valid and perm_valid:\n                detail = f\"\"\"적절한 권한 설정 확인:\n- 소유자: {owner_name}\n- 파일 권한: {oct(permissions)[-3:]} (최대 644 권한 권장)\"\"\"\n            else:\n                state = \"BAD\"\n                issues = []\n                if not owner_valid:\n                    issues.append(f\"소유자: {owner_name} (root 계정 필요)\")\n                if not perm_valid:\n                    issues.append(f\"권한: {oct(permissions)[-3:]} (644 이하로 설정 필요)\")\n                detail = \"문제 발견:\\n- \" + \"\\n- \".join(issues)\n\n        except PermissionError:\n            state = \"ERROR\"\n            detail = \"파일 접근 권한 없음 (root 권한 필요)\"\n        except Exception as e:\n            state = \"ERROR\"\n            detail = f\"파일 검사 오류: {str(e)}\"\n    \n    print_table_row(item, state, detail)\n\n\ndef check_expn_vrfy():\n    item = \"[U-70] EXPN, VRFY 명령어 제한\"\n    state = \"GOOD\"\n    config_file = \"/etc/mail/sendmail.cf\"\n    noexpn_lines = []\n    novrfy_lines = []\n\n    if not os.path.isfile(config_file):\n        state = \"N/A\"\n        detail = \"Sendmail 미설치 또는 설정 파일 없음\"\n    else:\n        try:\n            with open(config_file, 'r', encoding='utf-8', errors='ignore') as f:\n                for line_num, line in enumerate(f, 1):\n                    line_clean = line.strip()\n                    if re.search(r'noexpn', line_clean, re.IGNORECASE):\n                        noexpn_lines.append(f\"{line_num}번 줄: {line_clean}\")\n                    if re.search(r'novrfy', line_clean, re.IGNORECASE):\n                        novrfy_lines.append(f\"{line_num}번 줄: {line_clean}\")\n\n            # 결과 판정\n            if noexpn_lines and novrfy_lines:\n                detail = f\"\"\"EXPN/VRFY 명령어 제한 설정 확인:\n- noexpn 설정:\n  {'  '.join(noexpn_lines)}\n- novrfy 설정:\n  {'  '.join(novrfy_lines)}\"\"\"\n            else:\n                state = \"BAD\"\n                issues = []\n                if not noexpn_lines:\n                    issues.append(\"noexpn 미설정\")\n                if not novrfy_lines:\n                    issues.append(\"novrfy 미설정\")\n                detail = \"문제 발견: \" + \", \".join(issues)\n\n        except Exception as e:\n            state = \"ERROR\"\n            detail = f\"파일 읽기 오류: {str(e)}\"\n\n    print_table_row(item, state, detail)\n\n\ndef get_service_status(service):\n    \"\"\"서비스 상태 확인 함수\"\"\"\n    try:\n        result = subprocess.run(\n            ['systemctl', 'is-active', service],\n            stdout=subprocess.PIPE,\n            stderr=subprocess.DEVNULL,\n            universal_newlines=True\n        )\n        return result.stdout.strip()\n    except Exception:\n        return \"unknown\"\n\ndef check_security_updates():\n    item = \"[U-42] 최신 보안패치 및 벤더 권고사항 적용\"\n    state = \"GOOD\"\n    reasons = []\n\n    # 패키지 매니저 확인\n    package_manager = None\n    for pm in ['apt', 'yum', 'dnf']:\n        result = subprocess.run(\n            ['which', pm],\n            stdout=subprocess.DEVNULL,\n            stderr=subprocess.DEVNULL\n        )\n        if result.returncode == 0:\n            package_manager = pm\n            break\n\n    if not package_manager:\n        state = \"N/A\"\n        reasons.append(\"지원하지 않는 패키지 관리자\")\n    else:\n        try:\n            if package_manager == 'apt':\n                result = subprocess.run(\n                    ['apt', 'list', '--upgradable'],\n                    stdout=subprocess.PIPE,\n                    stderr=subprocess.PIPE,\n                    universal_newlines=True\n                )\n                security_updates = sum(1 for line in result.stdout.splitlines() if 'security' in line.lower())\n                if security_updates > 0:\n                    state = \"BAD\"\n                    reasons.append(f\"{security_updates}개의 보안 업데이트 필요\")\n            elif package_manager in ['yum', 'dnf']:\n                result = subprocess.run(\n                    [package_manager, 'check-update', '--security'],\n                    stdout=subprocess.PIPE,\n                    stderr=subprocess.PIPE,\n                    universal_newlines=True\n                )\n                if 'Security' in result.stdout:\n                    state = \"BAD\"\n                    reasons.append(\"보안 업데이트 필요\")\n        except Exception as e:\n            state = \"N/A\"\n            reasons.append(f\"업데이트 확인 중 오류: {e}\")\n\n    detail = \"; \".join(reasons) if state != \"GOOD\" else \"모든 보안 패치 적용 완료\"\n    print_table_row(item, state, detail)\n\n\ndef check_log():\n    item = \"[U-43] 로그의 정기적 검토 및 보고\"\n    state = \"GOOD\"\n    log_details = []\n    reasons = []\n\n    # 개별 로그 검사 함수 (상태와 출력 반환)\n    def check_single_log(filepath, command=None, lines=None, sudo=False, filter_str=None):\n        if not os.path.exists(filepath):\n            return {\"status\": \"N/A\", \"output\": f\"{filepath} 없음\"}\n        try:\n            cmd = command if command else f\"tail -n {lines} {filepath}\" if lines else f\"cat {filepath}\"\n            if sudo:\n                cmd = f\"sudo {cmd}\"\n            result = subprocess.run(\n                cmd, shell=True, check=False,\n                stdout=subprocess.PIPE, stderr=subprocess.STDOUT, \n                universal_newlines=True, timeout=10\n            )\n            output = result.stdout.strip()[:1000]  # 출력 길이 제한\n            \n            # 검사 조건 판정\n            status = \"GOOD\"\n            if filter_str and filter_str not in output:\n                status = \"BAD\"\n            elif lines and len(output.split('\\n')) < lines:\n                status = \"BAD\"\n                \n            return {\"status\": status, \"output\": output}\n            \n        except Exception as e:\n            return {\"status\": \"ERROR\", \"output\": str(e)}\n\n    # 검사 대상 로그 정의\n    log_checks = [\n        {\n            \"name\": \"시스템 로그인 기록 (wtmp)\",\n            \"params\": {\n                \"filepath\": \"/var/log/wtmp\",\n                \"command\": \"last -F -n 10\",  # 최근 10개 로그인 기록\n                \"lines\": 10\n            }\n        },\n        {\n            \"name\": \"실패한 로그인 시도 (btmp)\",\n            \"params\": {\n                \"filepath\": \"/var/log/btmp\",\n                \"command\": \"lastb -F -n 10\",\n                \"sudo\": True,\n                \"lines\": 10\n            }\n        },\n        {\n            \"name\": \"권한 상승 시도 (auth.log)\",\n            \"params\": {\n                \"filepath\": \"/var/log/auth.log\",\n                \"filter_str\": \"su:\",  # su 명령어 사용 기록 필터\n                \"lines\": 10\n            }\n        }\n    ]\n\n    # 각 로그별 검사 수행\n    for check in log_checks:\n        res = check_single_log(**check[\"params\"])\n        \n        if res[\"status\"] == \"GOOD\":\n            log_details.append(\n                f\"\"\"▼ {check['name']} ▼\n{res['output']}\n───────────────────────────────\"\"\")\n        else:\n            state = \"BAD\"\n            reasons.append(f\"{check['name']}: {res['status']} - {res['output']}\")\n\n    # 결과 메시지 구성\n    if state == \"GOOD\":\n        detail = f\"\"\"정기 로그 모니터링 활성화 확인:\n        \n{''.join(log_details)}\"\"\"\n    else:\n        detail = \"문제 발견:\\n- \" + \"\\n- \".join(reasons)\n\n    print_table_row(item, state, detail)\n\n\ndef check_syslog_config():\n    item = \"[U-72] 정책에 따른 시스템 로깅 설정\"\n    state = \"GOOD\"\n    details = []\n    error_flag = False\n    config_found = False\n    log_config_files = [\"/etc/rsyslog.conf\"] + glob.glob(\"/etc/rsyslog.d/*.conf\")\n    pattern = re.compile(r'^\\s*([^#]\\S+\\s+\\.*/var/log/(secure|auth\\.log))', re.IGNORECASE)\n\n    # 1. 설정 파일 존재 여부 확인\n    existing_configs = [f for f in log_config_files if os.path.isfile(f)]\n    if not existing_configs:\n        print_table_row(item, \"N/A\", \"rsyslog 설정 파일 없음\")\n        return\n\n    # 2. 각 설정 파일 검사\n    for file_path in existing_configs:\n        try:\n            with open(file_path, 'r') as f:\n                for line_num, line in enumerate(f, 1):\n                    line_clean = line.strip()\n                    match = pattern.search(line_clean)\n                    if match:\n                        config_found = True\n                        details.append(\n                            f\"{os.path.basename(file_path)} {line_num}번 줄: \"\n                            f\"{match.group(1).strip()}\"\n                        )\n        except Exception as e:\n            error_flag = True\n            details.append(f\"{file_path} 읽기 오류: {str(e)}\")\n\n    # 3. 결과 판정\n    if error_flag:\n        state = \"ERROR\"\n    elif not config_found:\n        state = \"BAD\"\n        details.append(\"인증 로그 설정 미확인 (auth/authpriv facility 설정 필요)\")\n\n    # 4. 결과 메시지 구성\n    if state == \"GOOD\":\n        formatted_details = \"적절한 로깅 설정 확인:\\n- \" + \"\\n- \".join(details)\n    else:\n        formatted_details = \"문제 발견:\\n- \" + \"\\n- \".join(details)\n\n    print_table_row(item, state, formatted_details)\n\n\ndef check_apache_info_hiding():\n    item = \"[U-71] Apache 웹 서비스 정보 숨김\"\n    state = \"GOOD\"\n    details = []\n    config_files = [\n        \"/etc/apache2/conf-enabled/security.conf\",\n        \"/etc/apache2/apache2.conf\",\n        \"/etc/httpd/conf/httpd.conf\",\n        \"/etc/httpd/conf.d/security.conf\"\n    ]\n    found_settings = {\n        'ServerTokens': {'value': None, 'location': ''},\n        'ServerSignature': {'value': None, 'location': ''}\n    }\n\n    # 1. 설정 파일 검색\n    existing_configs = [f for f in config_files if os.path.isfile(f)]\n    if not existing_configs:\n        print_table_row(item, \"N/A\", \"Apache 설정 파일을 찾을 수 없음\")\n        return\n\n    # 2. 각 설정 파일에서 지시어 검색\n    for config_file in existing_configs:\n        try:\n            with open(config_file, 'r') as f:\n                for line_num, line in enumerate(f, 1):\n                    line_clean = line.strip()\n                    if line_clean.startswith('#'):\n                        continue\n\n                    # ServerTokens 검색\n                    if re.match(r'^ServerTokens\\s+', line_clean, re.I):\n                        parts = line_clean.split()\n                        found_settings['ServerTokens']['value'] = parts[1]\n                        found_settings['ServerTokens']['location'] = f\"{config_file} {line_num}번 줄\"\n                        \n                    # ServerSignature 검색\n                    if re.match(r'^ServerSignature\\s+', line_clean, re.I):\n                        parts = line_clean.split()\n                        found_settings['ServerSignature']['value'] = parts[1]\n                        found_settings['ServerSignature']['location'] = f\"{config_file} {line_num}번 줄\"\n\n        except Exception as e:\n            state = \"ERROR\"\n            details.append(f\"{config_file} 읽기 오류: {str(e)}\")\n            continue\n\n    # 3. 설정 값 검증\n    tokens_valid = (found_settings['ServerTokens']['value'] in ['Prod', 'ProductOnly'])\n    signature_valid = (found_settings['ServerSignature']['value'] == 'Off')\n\n    # 4. 결과 판정\n    if not all([found_settings['ServerTokens']['value'], found_settings['ServerSignature']['value']]):\n        state = \"BAD\"\n        if not found_settings['ServerTokens']['value']:\n            details.append(\"ServerTokens 지시어 없음\")\n        if not found_settings['ServerSignature']['value']:\n            details.append(\"ServerSignature 지시어 없음\")\n    elif not tokens_valid or not signature_valid:\n        state = \"BAD\"\n        if not tokens_valid:\n            details.append(f\"ServerTokens={found_settings['ServerTokens']['value']} (Prod/ProductOnly 필요)\")\n        if not signature_valid:\n            details.append(f\"ServerSignature={found_settings['ServerSignature']['value']} (Off 필요)\")\n    else:\n        details.append(\n            f\"\"\"적절한 정보 숨김 설정 적용:\n- ServerTokens ({found_settings['ServerTokens']['location']}): {found_settings['ServerTokens']['value']}\n- ServerSignature ({found_settings['ServerSignature']['location']}): {found_settings['ServerSignature']['value']}\n※ 실제 적용 확인: `curl -I http://localhost | grep 'Server'` 실행 확인\"\"\"\n        )\n\n    print_table_row(item, state, \"\\n\".join(details))\n\n\n\ndef save_results_to_csv(filename=\"security_check_results.csv\"):\n    with open(filename, \"w\", newline='', encoding=\"utf-8-sig\") as csvfile:\n        writer = csv.writer(csvfile)\n        writer.writerow([\"항목\", \"결과\", \"상세\"])\n        writer.writerows(results)\n    print(f\"\\n[+] 결과가 '{filename}' 파일로 저장되었습니다.\")\n\nif __name__ == \"__main__\":\n    print(\"\\n------------------------------------<<계정관리>>-------------------------------------\")\n    results.append([\"------------------------------------<<계정관리>>-------------------------------------\", \"\", \"\"])\n    print_table_header()\n    check_remote_service()\n    check_password_complexity()\n    check_common_auth()\n    protect_hash_pwd_file()\n    only_root_uid()\n    check_su_restriction()\n    check_pwd_length()\n    check_pwd_maxdays()\n    check_pwd_mindays()\n    useless_user()\n    check_admin_groups()\n    check_useless_groups()\n    no_same_uid()\n    check_user_shell()\n    session_timeout()\n\n    print(\"\\n------------------------------------<<파일 및 디렉토리>>-------------------------------------\")\n    results.append([\"------------------------------------<<파일 및 디렉토리>>-------------------------------------\", \"\", \"\"])\n    print_table_header()\n    check_path()\n    check_owner_fd()\n    check_fowner_auth()\n    check_shaowner_auth()\n    check_hostsowner_auth()\n    inetd_owner_auth()\n    check_owner_perm([\"/etc/rsyslog.conf\", \"/etc/rsyslog.d\"])\n    check_servicesowner_auth()\n    check_suid_sgid()\n    check_startsetting_auth()\n    check_world_writable()\n    check_device_dev()\n    check_hosts_notuse()\n    run_ip_port_restriction_check()\n    check_hosts_lpd()\n    check_umask()\n    check_home_permissions()\n    check_home_directories()\n    find_hidden_files_and_dirs()\n\n    print(\"\\n------------------------------------<<서비스 관리>>-------------------------------------\")\n    results.append([\"------------------------------------<<서비스 관리>>-------------------------------------\", \"\", \"\"])\n    print_table_header()\n    check_finger_service()\n    check_ftp_anonymous()\n    run_r_commands_check()\n    run_cron_permission_check()\n    check_dos_services()\n    check_nfs_services()\n    check_nfs_access()\n    check_automountd()\n    check_rpc_services()\n    check_nis_services()\n    check_services()\n    check_sendmail_version()\n    check_mail_relay_restriction()\n    check_sendmail_restrictqrun()\n    check_dns_version_and_status()\n    check_zone_transfer()\n    check_directory_listing()\n    check_apache_user_group()\n    check_allowoverride()\n    check_unnecessary_apache_files()\n    check_followsymlinks()\n    check_limit_request_body()\n    check_document_root()\n    check_remote_services()\n    check_ftp_service()\n    check_ftp_shell()\n    check_ftpusers_file()\n    check_ftp_root_access()\n    check_at_permissions()\n    check_snmpd_running()\n    check_snmp_community_string()\n    check_logon_warning()\n    check_nfs_exports()\n    check_expn_vrfy()\n    check_apache_info_hiding()\n\n    print(\"\\n------------------------------------<<패치 관리>>-------------------------------------\")\n    results.append([\"------------------------------------<<패치 관리>>-------------------------------------\", \"\", \"\"])\n    print_table_header()\n    check_security_updates()\n\n    print(\"\\n------------------------------------<<로그 관리>>-------------------------------------\")\n    results.append([\"------------------------------------<<로그 관리>>-------------------------------------\", \"\", \"\"])\n    print_table_header()\n    check_log()\n    check_syslog_config()\n\n\n    save_results_to_csv()"
      }
    ],
    "type": "shell"
  },
  {
    "id": 4,
    "name": "yaml 파일",
    "description": "테스트",
    "lastRun": "실행 안됨",
    "status": "대기중",
    "tasks": 4,
    "filename": "4_playbook.yml",
    "sections": null,
    "type": "ansible"
  },
  {
    "id": 5,
    "name": "센트",
    "description": "1111111111",
    "lastRun": "실행 안됨",
    "status": "대기중",
    "tasks": 14,
    "filename": "5_playbook.yml",
    "sections": null,
    "type": "ansible"
  }
]